// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-monero.proto

#include "messages-monero.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace hw {
namespace trezor {
namespace messages {
namespace monero {
PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.commitment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal() {}
  union {
    MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroOutputEntry::MoneroTransactionSourceEntry_MoneroOutputEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.idx_)*/uint64_t{0u}} {}
struct MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal() {}
  union {
    MoneroTransactionSourceEntry_MoneroOutputEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroOutputEntry_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroMultisigKLRki::MoneroTransactionSourceEntry_MoneroMultisigKLRki(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.k_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.l_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.r_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ki_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal() {}
  union {
    MoneroTransactionSourceEntry_MoneroMultisigKLRki _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry::MoneroTransactionSourceEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.outputs_)*/{}
  , /*decltype(_impl_.real_out_additional_tx_keys_)*/{}
  , /*decltype(_impl_.real_out_tx_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mask_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.multisig_klrki_)*/nullptr
  , /*decltype(_impl_.real_output_)*/uint64_t{0u}
  , /*decltype(_impl_.real_output_in_tx_index_)*/uint64_t{0u}
  , /*decltype(_impl_.amount_)*/uint64_t{0u}
  , /*decltype(_impl_.rct_)*/false
  , /*decltype(_impl_.subaddr_minor_)*/0u} {}
struct MoneroTransactionSourceEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSourceEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSourceEntryDefaultTypeInternal() {}
  union {
    MoneroTransactionSourceEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSourceEntryDefaultTypeInternal _MoneroTransactionSourceEntry_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.spend_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.view_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal() {}
  union {
    MoneroTransactionDestinationEntry_MoneroAccountPublicAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal _MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionDestinationEntry::MoneroTransactionDestinationEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.original_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.addr_)*/nullptr
  , /*decltype(_impl_.amount_)*/uint64_t{0u}
  , /*decltype(_impl_.is_subaddress_)*/false
  , /*decltype(_impl_.is_integrated_)*/false} {}
struct MoneroTransactionDestinationEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionDestinationEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionDestinationEntryDefaultTypeInternal() {}
  union {
    MoneroTransactionDestinationEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionDestinationEntryDefaultTypeInternal _MoneroTransactionDestinationEntry_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionRsigData::MoneroTransactionRsigData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.grouping_)*/{}
  , /*decltype(_impl_.rsig_parts_)*/{}
  , /*decltype(_impl_.mask_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rsig_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rsig_type_)*/0u
  , /*decltype(_impl_.offload_type_)*/0u
  , /*decltype(_impl_.bp_version_)*/0u} {}
struct MoneroTransactionRsigDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionRsigDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionRsigDataDefaultTypeInternal() {}
  union {
    MoneroTransactionRsigData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionRsigDataDefaultTypeInternal _MoneroTransactionRsigData_default_instance_;
PROTOBUF_CONSTEXPR MoneroGetAddress::MoneroGetAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.payment_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.show_display_)*/false
  , /*decltype(_impl_.network_type_)*/0
  , /*decltype(_impl_.account_)*/0u
  , /*decltype(_impl_.minor_)*/0u} {}
struct MoneroGetAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroGetAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroGetAddressDefaultTypeInternal() {}
  union {
    MoneroGetAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroGetAddressDefaultTypeInternal _MoneroGetAddress_default_instance_;
PROTOBUF_CONSTEXPR MoneroAddress::MoneroAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroAddressDefaultTypeInternal() {}
  union {
    MoneroAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroAddressDefaultTypeInternal _MoneroAddress_default_instance_;
PROTOBUF_CONSTEXPR MoneroGetWatchKey::MoneroGetWatchKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.network_type_)*/0} {}
struct MoneroGetWatchKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroGetWatchKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroGetWatchKeyDefaultTypeInternal() {}
  union {
    MoneroGetWatchKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroGetWatchKeyDefaultTypeInternal _MoneroGetWatchKey_default_instance_;
PROTOBUF_CONSTEXPR MoneroWatchKey::MoneroWatchKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.watch_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroWatchKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroWatchKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroWatchKeyDefaultTypeInternal() {}
  union {
    MoneroWatchKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroWatchKeyDefaultTypeInternal _MoneroWatchKey_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionInitRequest_MoneroTransactionData::MoneroTransactionInitRequest_MoneroTransactionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.outputs_)*/{}
  , /*decltype(_impl_.minor_indices_)*/{}
  , /*decltype(_impl_.integrated_indices_)*/{}
  , /*decltype(_impl_.payment_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.monero_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.change_dts_)*/nullptr
  , /*decltype(_impl_.rsig_data_)*/nullptr
  , /*decltype(_impl_.unlock_time_)*/uint64_t{0u}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.num_inputs_)*/0u
  , /*decltype(_impl_.fee_)*/uint64_t{0u}
  , /*decltype(_impl_.mixin_)*/0u
  , /*decltype(_impl_.account_)*/0u
  , /*decltype(_impl_.client_version_)*/0u
  , /*decltype(_impl_.hard_fork_)*/0u} {}
struct MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal() {}
  union {
    MoneroTransactionInitRequest_MoneroTransactionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal _MoneroTransactionInitRequest_MoneroTransactionData_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionInitRequest::MoneroTransactionInitRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.tsx_data_)*/nullptr
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.network_type_)*/0} {}
struct MoneroTransactionInitRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionInitRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionInitRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionInitRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionInitRequestDefaultTypeInternal _MoneroTransactionInitRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionInitAck::MoneroTransactionInitAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hmacs_)*/{}
  , /*decltype(_impl_.rsig_data_)*/nullptr} {}
struct MoneroTransactionInitAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionInitAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionInitAckDefaultTypeInternal() {}
  union {
    MoneroTransactionInitAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionInitAckDefaultTypeInternal _MoneroTransactionInitAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSetInputRequest::MoneroTransactionSetInputRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.src_entr_)*/nullptr} {}
struct MoneroTransactionSetInputRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSetInputRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSetInputRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionSetInputRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSetInputRequestDefaultTypeInternal _MoneroTransactionSetInputRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSetInputAck::MoneroTransactionSetInputAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vini_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vini_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_alpha_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spend_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroTransactionSetInputAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSetInputAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSetInputAckDefaultTypeInternal() {}
  union {
    MoneroTransactionSetInputAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSetInputAckDefaultTypeInternal _MoneroTransactionSetInputAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionInputViniRequest::MoneroTransactionInputViniRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vini_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vini_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.src_entr_)*/nullptr
  , /*decltype(_impl_.orig_idx_)*/0u} {}
struct MoneroTransactionInputViniRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionInputViniRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionInputViniRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionInputViniRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionInputViniRequestDefaultTypeInternal _MoneroTransactionInputViniRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionInputViniAck::MoneroTransactionInputViniAck(
    ::_pbi::ConstantInitialized) {}
struct MoneroTransactionInputViniAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionInputViniAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionInputViniAckDefaultTypeInternal() {}
  union {
    MoneroTransactionInputViniAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionInputViniAckDefaultTypeInternal _MoneroTransactionInputViniAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionAllInputsSetRequest::MoneroTransactionAllInputsSetRequest(
    ::_pbi::ConstantInitialized) {}
struct MoneroTransactionAllInputsSetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionAllInputsSetRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionAllInputsSetRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionAllInputsSetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionAllInputsSetRequestDefaultTypeInternal _MoneroTransactionAllInputsSetRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionAllInputsSetAck::MoneroTransactionAllInputsSetAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rsig_data_)*/nullptr} {}
struct MoneroTransactionAllInputsSetAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionAllInputsSetAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionAllInputsSetAckDefaultTypeInternal() {}
  union {
    MoneroTransactionAllInputsSetAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionAllInputsSetAckDefaultTypeInternal _MoneroTransactionAllInputsSetAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSetOutputRequest::MoneroTransactionSetOutputRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dst_entr_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dst_entr_)*/nullptr
  , /*decltype(_impl_.rsig_data_)*/nullptr
  , /*decltype(_impl_.is_offloaded_bp_)*/false} {}
struct MoneroTransactionSetOutputRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSetOutputRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSetOutputRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionSetOutputRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSetOutputRequestDefaultTypeInternal _MoneroTransactionSetOutputRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSetOutputAck::MoneroTransactionSetOutputAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tx_out_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vouti_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.out_pk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ecdh_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rsig_data_)*/nullptr} {}
struct MoneroTransactionSetOutputAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSetOutputAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSetOutputAckDefaultTypeInternal() {}
  union {
    MoneroTransactionSetOutputAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSetOutputAckDefaultTypeInternal _MoneroTransactionSetOutputAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetRequest::MoneroTransactionAllOutSetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rsig_data_)*/nullptr} {}
struct MoneroTransactionAllOutSetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionAllOutSetRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionAllOutSetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionAllOutSetRequestDefaultTypeInternal _MoneroTransactionAllOutSetRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetAck_MoneroRingCtSig::MoneroTransactionAllOutSetAck_MoneroRingCtSig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.txn_fee_)*/uint64_t{0u}
  , /*decltype(_impl_.rv_type_)*/0u} {}
struct MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal() {}
  union {
    MoneroTransactionAllOutSetAck_MoneroRingCtSig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal _MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetAck::MoneroTransactionAllOutSetAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.extra_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_prefix_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.full_message_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rv_)*/nullptr} {}
struct MoneroTransactionAllOutSetAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionAllOutSetAckDefaultTypeInternal() {}
  union {
    MoneroTransactionAllOutSetAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionAllOutSetAckDefaultTypeInternal _MoneroTransactionAllOutSetAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSignInputRequest::MoneroTransactionSignInputRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vini_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vini_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_hmac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_alpha_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spend_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.src_entr_)*/nullptr
  , /*decltype(_impl_.orig_idx_)*/0u} {}
struct MoneroTransactionSignInputRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSignInputRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSignInputRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionSignInputRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSignInputRequestDefaultTypeInternal _MoneroTransactionSignInputRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionSignInputAck::MoneroTransactionSignInputAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pseudo_out_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroTransactionSignInputAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionSignInputAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionSignInputAckDefaultTypeInternal() {}
  union {
    MoneroTransactionSignInputAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionSignInputAckDefaultTypeInternal _MoneroTransactionSignInputAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionFinalRequest::MoneroTransactionFinalRequest(
    ::_pbi::ConstantInitialized) {}
struct MoneroTransactionFinalRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionFinalRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionFinalRequestDefaultTypeInternal() {}
  union {
    MoneroTransactionFinalRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionFinalRequestDefaultTypeInternal _MoneroTransactionFinalRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroTransactionFinalAck::MoneroTransactionFinalAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cout_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rand_mult_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_enc_keys_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.opening_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroTransactionFinalAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroTransactionFinalAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroTransactionFinalAckDefaultTypeInternal() {}
  union {
    MoneroTransactionFinalAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroTransactionFinalAckDefaultTypeInternal _MoneroTransactionFinalAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minor_indices_)*/{}
  , /*decltype(_impl_.account_)*/0u} {}
struct MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal() {}
  union {
    MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal _MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageExportInitRequest::MoneroKeyImageExportInitRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.subs_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.num_)*/uint64_t{0u}
  , /*decltype(_impl_.network_type_)*/0} {}
struct MoneroKeyImageExportInitRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageExportInitRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageExportInitRequestDefaultTypeInternal() {}
  union {
    MoneroKeyImageExportInitRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageExportInitRequestDefaultTypeInternal _MoneroKeyImageExportInitRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageExportInitAck::MoneroKeyImageExportInitAck(
    ::_pbi::ConstantInitialized) {}
struct MoneroKeyImageExportInitAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageExportInitAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageExportInitAckDefaultTypeInternal() {}
  union {
    MoneroKeyImageExportInitAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageExportInitAckDefaultTypeInternal _MoneroKeyImageExportInitAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepRequest_MoneroTransferDetails::MoneroKeyImageSyncStepRequest_MoneroTransferDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.additional_tx_pub_keys_)*/{}
  , /*decltype(_impl_.out_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_pub_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.internal_output_index_)*/uint64_t{0u}
  , /*decltype(_impl_.sub_addr_major_)*/0u
  , /*decltype(_impl_.sub_addr_minor_)*/0u} {}
struct MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal() {}
  union {
    MoneroKeyImageSyncStepRequest_MoneroTransferDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal _MoneroKeyImageSyncStepRequest_MoneroTransferDetails_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepRequest::MoneroKeyImageSyncStepRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tdis_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoneroKeyImageSyncStepRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageSyncStepRequestDefaultTypeInternal() {}
  union {
    MoneroKeyImageSyncStepRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageSyncStepRequestDefaultTypeInternal _MoneroKeyImageSyncStepRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.iv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.blob_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal() {}
  union {
    MoneroKeyImageSyncStepAck_MoneroExportedKeyImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal _MoneroKeyImageSyncStepAck_MoneroExportedKeyImage_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepAck::MoneroKeyImageSyncStepAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kis_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoneroKeyImageSyncStepAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageSyncStepAckDefaultTypeInternal() {}
  union {
    MoneroKeyImageSyncStepAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageSyncStepAckDefaultTypeInternal _MoneroKeyImageSyncStepAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageSyncFinalRequest::MoneroKeyImageSyncFinalRequest(
    ::_pbi::ConstantInitialized) {}
struct MoneroKeyImageSyncFinalRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageSyncFinalRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageSyncFinalRequestDefaultTypeInternal() {}
  union {
    MoneroKeyImageSyncFinalRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageSyncFinalRequestDefaultTypeInternal _MoneroKeyImageSyncFinalRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroKeyImageSyncFinalAck::MoneroKeyImageSyncFinalAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enc_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroKeyImageSyncFinalAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroKeyImageSyncFinalAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroKeyImageSyncFinalAckDefaultTypeInternal() {}
  union {
    MoneroKeyImageSyncFinalAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroKeyImageSyncFinalAckDefaultTypeInternal _MoneroKeyImageSyncFinalAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroGetTxKeyRequest::MoneroGetTxKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.salt1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.salt2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_enc_keys_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_prefix_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.view_public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.network_type_)*/0
  , /*decltype(_impl_.reason_)*/0u} {}
struct MoneroGetTxKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroGetTxKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroGetTxKeyRequestDefaultTypeInternal() {}
  union {
    MoneroGetTxKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroGetTxKeyRequestDefaultTypeInternal _MoneroGetTxKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroGetTxKeyAck::MoneroGetTxKeyAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_keys_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_derivations_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroGetTxKeyAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroGetTxKeyAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroGetTxKeyAckDefaultTypeInternal() {}
  union {
    MoneroGetTxKeyAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroGetTxKeyAckDefaultTypeInternal _MoneroGetTxKeyAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroLiveRefreshStartRequest::MoneroLiveRefreshStartRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.network_type_)*/0} {}
struct MoneroLiveRefreshStartRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroLiveRefreshStartRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroLiveRefreshStartRequestDefaultTypeInternal() {}
  union {
    MoneroLiveRefreshStartRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroLiveRefreshStartRequestDefaultTypeInternal _MoneroLiveRefreshStartRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroLiveRefreshStartAck::MoneroLiveRefreshStartAck(
    ::_pbi::ConstantInitialized) {}
struct MoneroLiveRefreshStartAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroLiveRefreshStartAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroLiveRefreshStartAckDefaultTypeInternal() {}
  union {
    MoneroLiveRefreshStartAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroLiveRefreshStartAckDefaultTypeInternal _MoneroLiveRefreshStartAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroLiveRefreshStepRequest::MoneroLiveRefreshStepRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.out_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recv_deriv_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.real_out_idx_)*/uint64_t{0u}
  , /*decltype(_impl_.sub_addr_major_)*/0u
  , /*decltype(_impl_.sub_addr_minor_)*/0u} {}
struct MoneroLiveRefreshStepRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroLiveRefreshStepRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroLiveRefreshStepRequestDefaultTypeInternal() {}
  union {
    MoneroLiveRefreshStepRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroLiveRefreshStepRequestDefaultTypeInternal _MoneroLiveRefreshStepRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroLiveRefreshStepAck::MoneroLiveRefreshStepAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_image_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct MoneroLiveRefreshStepAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroLiveRefreshStepAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroLiveRefreshStepAckDefaultTypeInternal() {}
  union {
    MoneroLiveRefreshStepAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroLiveRefreshStepAckDefaultTypeInternal _MoneroLiveRefreshStepAck_default_instance_;
PROTOBUF_CONSTEXPR MoneroLiveRefreshFinalRequest::MoneroLiveRefreshFinalRequest(
    ::_pbi::ConstantInitialized) {}
struct MoneroLiveRefreshFinalRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroLiveRefreshFinalRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroLiveRefreshFinalRequestDefaultTypeInternal() {}
  union {
    MoneroLiveRefreshFinalRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroLiveRefreshFinalRequestDefaultTypeInternal _MoneroLiveRefreshFinalRequest_default_instance_;
PROTOBUF_CONSTEXPR MoneroLiveRefreshFinalAck::MoneroLiveRefreshFinalAck(
    ::_pbi::ConstantInitialized) {}
struct MoneroLiveRefreshFinalAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoneroLiveRefreshFinalAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoneroLiveRefreshFinalAckDefaultTypeInternal() {}
  union {
    MoneroLiveRefreshFinalAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoneroLiveRefreshFinalAckDefaultTypeInternal _MoneroLiveRefreshFinalAck_default_instance_;
PROTOBUF_CONSTEXPR DebugMoneroDiagRequest::DebugMoneroDiagRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pd_)*/{}
  , /*decltype(_impl_.data1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ins_)*/uint64_t{0u}
  , /*decltype(_impl_.p1_)*/uint64_t{0u}
  , /*decltype(_impl_.p2_)*/uint64_t{0u}} {}
struct DebugMoneroDiagRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugMoneroDiagRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugMoneroDiagRequestDefaultTypeInternal() {}
  union {
    DebugMoneroDiagRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugMoneroDiagRequestDefaultTypeInternal _DebugMoneroDiagRequest_default_instance_;
PROTOBUF_CONSTEXPR DebugMoneroDiagAck::DebugMoneroDiagAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pd_)*/{}
  , /*decltype(_impl_.data1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ins_)*/uint64_t{0u}
  , /*decltype(_impl_.p1_)*/uint64_t{0u}
  , /*decltype(_impl_.p2_)*/uint64_t{0u}} {}
struct DebugMoneroDiagAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugMoneroDiagAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugMoneroDiagAckDefaultTypeInternal() {}
  union {
    DebugMoneroDiagAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugMoneroDiagAckDefaultTypeInternal _DebugMoneroDiagAck_default_instance_;
}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw
static ::_pb::Metadata file_level_metadata_messages_2dmonero_2eproto[48];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_messages_2dmonero_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_messages_2dmonero_2eproto = nullptr;

const uint32_t TableStruct_messages_2dmonero_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic, _impl_.dest_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic, _impl_.commitment_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry, _impl_.idx_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry, _impl_.key_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki, _impl_.k_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki, _impl_.l_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki, _impl_.ki_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.outputs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.real_output_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.real_out_tx_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.real_out_additional_tx_keys_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.real_output_in_tx_index_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.rct_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.multisig_klrki_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSourceEntry, _impl_.subaddr_minor_),
  ~0u,
  3,
  0,
  ~0u,
  4,
  5,
  6,
  1,
  2,
  7,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress, _impl_.spend_public_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress, _impl_.view_public_key_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _impl_.amount_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _impl_.addr_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _impl_.is_subaddress_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _impl_.original_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry, _impl_.is_integrated_),
  2,
  1,
  3,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.rsig_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.offload_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.grouping_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.rsig_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.rsig_parts_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionRsigData, _impl_.bp_version_),
  2,
  3,
  ~0u,
  0,
  1,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_.show_display_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_.network_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_.account_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_.minor_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetAddress, _impl_.payment_id_),
  ~0u,
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroAddress, _impl_.address_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetWatchKey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetWatchKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetWatchKey, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetWatchKey, _impl_.network_type_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroWatchKey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroWatchKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroWatchKey, _impl_.watch_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroWatchKey, _impl_.address_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.payment_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.unlock_time_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.outputs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.change_dts_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.num_inputs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.mixin_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.fee_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.account_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.minor_indices_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.rsig_data_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.integrated_indices_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.client_version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.hard_fork_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData, _impl_.monero_version_),
  5,
  0,
  4,
  ~0u,
  2,
  6,
  8,
  7,
  9,
  ~0u,
  3,
  ~0u,
  10,
  11,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest, _impl_.network_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitRequest, _impl_.tsx_data_),
  1,
  ~0u,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitAck, _impl_.hmacs_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInitAck, _impl_.rsig_data_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputRequest, _impl_.src_entr_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_.vini_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_.vini_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_.pseudo_out_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_.pseudo_out_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_.pseudo_out_alpha_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetInputAck, _impl_.spend_key_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_.src_entr_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_.vini_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_.vini_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_.pseudo_out_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_.pseudo_out_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest, _impl_.orig_idx_),
  4,
  0,
  1,
  2,
  3,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionInputViniAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck, _impl_.rsig_data_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest, _impl_.dst_entr_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest, _impl_.dst_entr_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest, _impl_.rsig_data_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest, _impl_.is_offloaded_bp_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _impl_.tx_out_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _impl_.vouti_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _impl_.rsig_data_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _impl_.out_pk_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck, _impl_.ecdh_info_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest, _impl_.rsig_data_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig, _impl_.txn_fee_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig, _impl_.rv_type_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck, _impl_.extra_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck, _impl_.tx_prefix_hash_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck, _impl_.rv_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck, _impl_.full_message_hash_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.src_entr_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.vini_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.vini_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.pseudo_out_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.pseudo_out_hmac_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.pseudo_out_alpha_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.spend_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest, _impl_.orig_idx_),
  6,
  0,
  1,
  2,
  3,
  4,
  5,
  7,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputAck, _impl_.signature_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionSignInputAck, _impl_.pseudo_out_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _impl_.cout_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _impl_.salt_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _impl_.rand_mult_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _impl_.tx_enc_keys_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroTransactionFinalAck, _impl_.opening_key_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList, _impl_.account_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList, _impl_.minor_indices_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _impl_.num_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _impl_.hash_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _impl_.network_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest, _impl_.subs_),
  1,
  0,
  ~0u,
  2,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageExportInitAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.out_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.tx_pub_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.additional_tx_pub_keys_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.internal_output_index_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.sub_addr_major_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.sub_addr_minor_),
  0,
  1,
  ~0u,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest, _impl_.tdis_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage, _impl_.iv_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage, _impl_.blob_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck, _impl_.kis_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck, _impl_.enc_key_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.network_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.salt1_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.salt2_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.tx_enc_keys_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.tx_prefix_hash_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyRequest, _impl_.view_public_key_),
  ~0u,
  5,
  0,
  1,
  2,
  3,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyAck, _impl_.salt_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyAck, _impl_.tx_keys_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroGetTxKeyAck, _impl_.tx_derivations_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest, _impl_.network_type_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStartAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _impl_.out_key_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _impl_.recv_deriv_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _impl_.real_out_idx_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _impl_.sub_addr_major_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest, _impl_.sub_addr_minor_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepAck, _impl_.salt_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshStepAck, _impl_.key_image_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_.ins_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_.p1_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_.p2_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_.pd_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_.data1_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagRequest, _impl_.data2_),
  2,
  3,
  4,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_.ins_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_.p1_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_.p2_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_.pd_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_.data1_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::monero::DebugMoneroDiagAck, _impl_.data2_),
  2,
  3,
  4,
  ~0u,
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic)},
  { 10, 18, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry)},
  { 20, 30, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki)},
  { 34, 50, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSourceEntry)},
  { 60, 68, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress)},
  { 70, 81, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry)},
  { 86, 99, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionRsigData)},
  { 106, 118, -1, sizeof(::hw::trezor::messages::monero::MoneroGetAddress)},
  { 124, 131, -1, sizeof(::hw::trezor::messages::monero::MoneroAddress)},
  { 132, 140, -1, sizeof(::hw::trezor::messages::monero::MoneroGetWatchKey)},
  { 142, 150, -1, sizeof(::hw::trezor::messages::monero::MoneroWatchKey)},
  { 152, 173, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData)},
  { 188, 198, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionInitRequest)},
  { 202, 210, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionInitAck)},
  { 212, 219, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSetInputRequest)},
  { 220, 232, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSetInputAck)},
  { 238, 250, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest)},
  { 256, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionInputViniAck)},
  { 262, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest)},
  { 268, 275, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck)},
  { 276, 286, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest)},
  { 290, 301, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSetOutputAck)},
  { 306, 313, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest)},
  { 314, 323, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig)},
  { 326, 336, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck)},
  { 340, 354, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest)},
  { 362, 370, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionSignInputAck)},
  { 372, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionFinalRequest)},
  { 378, 389, -1, sizeof(::hw::trezor::messages::monero::MoneroTransactionFinalAck)},
  { 394, 402, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList)},
  { 404, 415, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest)},
  { 420, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageExportInitAck)},
  { 426, 438, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails)},
  { 444, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest)},
  { 451, 459, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage)},
  { 461, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck)},
  { 468, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest)},
  { 474, 481, -1, sizeof(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck)},
  { 482, 496, -1, sizeof(::hw::trezor::messages::monero::MoneroGetTxKeyRequest)},
  { 504, 513, -1, sizeof(::hw::trezor::messages::monero::MoneroGetTxKeyAck)},
  { 516, 524, -1, sizeof(::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest)},
  { 526, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroLiveRefreshStartAck)},
  { 532, 543, -1, sizeof(::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest)},
  { 548, 556, -1, sizeof(::hw::trezor::messages::monero::MoneroLiveRefreshStepAck)},
  { 558, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest)},
  { 564, -1, -1, sizeof(::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck)},
  { 570, 582, -1, sizeof(::hw::trezor::messages::monero::DebugMoneroDiagRequest)},
  { 588, 600, -1, sizeof(::hw::trezor::messages::monero::DebugMoneroDiagAck)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroOutputEntry_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroGetAddress_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroAddress_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroGetWatchKey_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroWatchKey_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionInitRequest_MoneroTransactionData_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionInitRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionInitAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSetInputRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSetInputAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionInputViniRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionInputViniAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionAllInputsSetRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionAllInputsSetAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSetOutputRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSetOutputAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionAllOutSetRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionAllOutSetAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSignInputRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionSignInputAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionFinalRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroTransactionFinalAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageExportInitRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageExportInitAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageSyncStepRequest_MoneroTransferDetails_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageSyncStepRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageSyncStepAck_MoneroExportedKeyImage_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageSyncStepAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageSyncFinalRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroKeyImageSyncFinalAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroGetTxKeyRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroGetTxKeyAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroLiveRefreshStartRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroLiveRefreshStartAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroLiveRefreshStepRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroLiveRefreshStepAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroLiveRefreshFinalRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_MoneroLiveRefreshFinalAck_default_instance_._instance,
  &::hw::trezor::messages::monero::_DebugMoneroDiagRequest_default_instance_._instance,
  &::hw::trezor::messages::monero::_DebugMoneroDiagAck_default_instance_._instance,
};

const char descriptor_table_protodef_messages_2dmonero_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025messages-monero.proto\022\031hw.trezor.messa"
  "ges.monero\"\237\005\n\034MoneroTransactionSourceEn"
  "try\022Z\n\007outputs\030\001 \003(\0132I.hw.trezor.message"
  "s.monero.MoneroTransactionSourceEntry.Mo"
  "neroOutputEntry\022\023\n\013real_output\030\002 \001(\004\022\027\n\017"
  "real_out_tx_key\030\003 \001(\014\022#\n\033real_out_additi"
  "onal_tx_keys\030\004 \003(\014\022\037\n\027real_output_in_tx_"
  "index\030\005 \001(\004\022\016\n\006amount\030\006 \001(\004\022\013\n\003rct\030\007 \001(\010"
  "\022\014\n\004mask\030\010 \001(\014\022c\n\016multisig_kLRki\030\t \001(\0132K"
  ".hw.trezor.messages.monero.MoneroTransac"
  "tionSourceEntry.MoneroMultisigKLRki\022\025\n\rs"
  "ubaddr_minor\030\n \001(\r\032\303\001\n\021MoneroOutputEntry"
  "\022\013\n\003idx\030\001 \001(\004\022i\n\003key\030\002 \001(\0132\\.hw.trezor.m"
  "essages.monero.MoneroTransactionSourceEn"
  "try.MoneroOutputEntry.MoneroRctKeyPublic"
  "\0326\n\022MoneroRctKeyPublic\022\014\n\004dest\030\001 \002(\014\022\022\n\n"
  "commitment\030\002 \002(\014\032B\n\023MoneroMultisigKLRki\022"
  "\t\n\001K\030\001 \001(\014\022\t\n\001L\030\002 \001(\014\022\t\n\001R\030\003 \001(\014\022\n\n\002ki\030\004"
  " \001(\014\"\253\002\n!MoneroTransactionDestinationEnt"
  "ry\022\016\n\006amount\030\001 \001(\004\022e\n\004addr\030\002 \001(\0132W.hw.tr"
  "ezor.messages.monero.MoneroTransactionDe"
  "stinationEntry.MoneroAccountPublicAddres"
  "s\022\025\n\ris_subaddress\030\003 \001(\010\022\020\n\010original\030\004 \001"
  "(\014\022\025\n\ris_integrated\030\005 \001(\010\032O\n\032MoneroAccou"
  "ntPublicAddress\022\030\n\020spend_public_key\030\001 \001("
  "\014\022\027\n\017view_public_key\030\002 \001(\014\"\232\001\n\031MoneroTra"
  "nsactionRsigData\022\021\n\trsig_type\030\001 \001(\r\022\024\n\014o"
  "ffload_type\030\002 \001(\r\022\020\n\010grouping\030\003 \003(\004\022\014\n\004m"
  "ask\030\004 \001(\014\022\014\n\004rsig\030\005 \001(\014\022\022\n\nrsig_parts\030\006 "
  "\003(\014\022\022\n\nbp_version\030\007 \001(\r\"\274\001\n\020MoneroGetAdd"
  "ress\022\021\n\taddress_n\030\001 \003(\r\022\024\n\014show_display\030"
  "\002 \001(\010\022K\n\014network_type\030\003 \001(\0162,.hw.trezor."
  "messages.monero.MoneroNetworkType:\007MAINN"
  "ET\022\017\n\007account\030\004 \001(\r\022\r\n\005minor\030\005 \001(\r\022\022\n\npa"
  "yment_id\030\006 \001(\014\" \n\rMoneroAddress\022\017\n\007addre"
  "ss\030\001 \001(\014\"s\n\021MoneroGetWatchKey\022\021\n\taddress"
  "_n\030\001 \003(\r\022K\n\014network_type\030\002 \001(\0162,.hw.trez"
  "or.messages.monero.MoneroNetworkType:\007MA"
  "INNET\"4\n\016MoneroWatchKey\022\021\n\twatch_key\030\001 \001"
  "(\014\022\017\n\007address\030\002 \001(\014\"\345\005\n\034MoneroTransactio"
  "nInitRequest\022\017\n\007version\030\001 \001(\r\022\021\n\taddress"
  "_n\030\002 \003(\r\022K\n\014network_type\030\003 \001(\0162,.hw.trez"
  "or.messages.monero.MoneroNetworkType:\007MA"
  "INNET\022_\n\010tsx_data\030\004 \001(\0132M.hw.trezor.mess"
  "ages.monero.MoneroTransactionInitRequest"
  ".MoneroTransactionData\032\362\003\n\025MoneroTransac"
  "tionData\022\017\n\007version\030\001 \001(\r\022\022\n\npayment_id\030"
  "\002 \001(\014\022\023\n\013unlock_time\030\003 \001(\004\022M\n\007outputs\030\004 "
  "\003(\0132<.hw.trezor.messages.monero.MoneroTr"
  "ansactionDestinationEntry\022P\n\nchange_dts\030"
  "\005 \001(\0132<.hw.trezor.messages.monero.Monero"
  "TransactionDestinationEntry\022\022\n\nnum_input"
  "s\030\006 \001(\r\022\r\n\005mixin\030\007 \001(\r\022\013\n\003fee\030\010 \001(\004\022\017\n\007a"
  "ccount\030\t \001(\r\022\025\n\rminor_indices\030\n \003(\r\022G\n\tr"
  "sig_data\030\013 \001(\01324.hw.trezor.messages.mone"
  "ro.MoneroTransactionRsigData\022\032\n\022integrat"
  "ed_indices\030\014 \003(\r\022\026\n\016client_version\030\r \001(\r"
  "\022\021\n\thard_fork\030\016 \001(\r\022\026\n\016monero_version\030\017 "
  "\001(\014\"r\n\030MoneroTransactionInitAck\022\r\n\005hmacs"
  "\030\001 \003(\014\022G\n\trsig_data\030\002 \001(\01324.hw.trezor.me"
  "ssages.monero.MoneroTransactionRsigData\""
  "m\n MoneroTransactionSetInputRequest\022I\n\010s"
  "rc_entr\030\001 \001(\01327.hw.trezor.messages.moner"
  "o.MoneroTransactionSourceEntry\"\231\001\n\034Moner"
  "oTransactionSetInputAck\022\014\n\004vini\030\001 \001(\014\022\021\n"
  "\tvini_hmac\030\002 \001(\014\022\022\n\npseudo_out\030\003 \001(\014\022\027\n\017"
  "pseudo_out_hmac\030\004 \001(\014\022\030\n\020pseudo_out_alph"
  "a\030\005 \001(\014\022\021\n\tspend_key\030\006 \001(\014\"\316\001\n!MoneroTra"
  "nsactionInputViniRequest\022I\n\010src_entr\030\001 \001"
  "(\01327.hw.trezor.messages.monero.MoneroTra"
  "nsactionSourceEntry\022\014\n\004vini\030\002 \001(\014\022\021\n\tvin"
  "i_hmac\030\003 \001(\014\022\022\n\npseudo_out\030\004 \001(\014\022\027\n\017pseu"
  "do_out_hmac\030\005 \001(\014\022\020\n\010orig_idx\030\006 \001(\r\"\037\n\035M"
  "oneroTransactionInputViniAck\"&\n$MoneroTr"
  "ansactionAllInputsSetRequest\"k\n MoneroTr"
  "ansactionAllInputsSetAck\022G\n\trsig_data\030\001 "
  "\001(\01324.hw.trezor.messages.monero.MoneroTr"
  "ansactionRsigData\"\354\001\n!MoneroTransactionS"
  "etOutputRequest\022N\n\010dst_entr\030\001 \001(\0132<.hw.t"
  "rezor.messages.monero.MoneroTransactionD"
  "estinationEntry\022\025\n\rdst_entr_hmac\030\002 \001(\014\022G"
  "\n\trsig_data\030\003 \001(\01324.hw.trezor.messages.m"
  "onero.MoneroTransactionRsigData\022\027\n\017is_of"
  "floaded_bp\030\004 \001(\010\"\257\001\n\035MoneroTransactionSe"
  "tOutputAck\022\016\n\006tx_out\030\001 \001(\014\022\022\n\nvouti_hmac"
  "\030\002 \001(\014\022G\n\trsig_data\030\003 \001(\01324.hw.trezor.me"
  "ssages.monero.MoneroTransactionRsigData\022"
  "\016\n\006out_pk\030\004 \001(\014\022\021\n\tecdh_info\030\005 \001(\014\"l\n!Mo"
  "neroTransactionAllOutSetRequest\022G\n\trsig_"
  "data\030\001 \001(\01324.hw.trezor.messages.monero.M"
  "oneroTransactionRsigData\"\375\001\n\035MoneroTrans"
  "actionAllOutSetAck\022\r\n\005extra\030\001 \001(\014\022\026\n\016tx_"
  "prefix_hash\030\002 \001(\014\022T\n\002rv\030\004 \001(\0132H.hw.trezo"
  "r.messages.monero.MoneroTransactionAllOu"
  "tSetAck.MoneroRingCtSig\022\031\n\021full_message_"
  "hash\030\005 \001(\014\032D\n\017MoneroRingCtSig\022\017\n\007txn_fee"
  "\030\001 \001(\004\022\017\n\007message\030\002 \001(\014\022\017\n\007rv_type\030\003 \001(\r"
  "\"\373\001\n!MoneroTransactionSignInputRequest\022I"
  "\n\010src_entr\030\001 \001(\01327.hw.trezor.messages.mo"
  "nero.MoneroTransactionSourceEntry\022\014\n\004vin"
  "i\030\002 \001(\014\022\021\n\tvini_hmac\030\003 \001(\014\022\022\n\npseudo_out"
  "\030\004 \001(\014\022\027\n\017pseudo_out_hmac\030\005 \001(\014\022\030\n\020pseud"
  "o_out_alpha\030\006 \001(\014\022\021\n\tspend_key\030\007 \001(\014\022\020\n\010"
  "orig_idx\030\010 \001(\r\"F\n\035MoneroTransactionSignI"
  "nputAck\022\021\n\tsignature\030\001 \001(\014\022\022\n\npseudo_out"
  "\030\002 \001(\014\"\037\n\035MoneroTransactionFinalRequest\""
  "x\n\031MoneroTransactionFinalAck\022\020\n\010cout_key"
  "\030\001 \001(\014\022\014\n\004salt\030\002 \001(\014\022\021\n\trand_mult\030\003 \001(\014\022"
  "\023\n\013tx_enc_keys\030\004 \001(\014\022\023\n\013opening_key\030\005 \001("
  "\014\"\311\002\n\037MoneroKeyImageExportInitRequest\022\013\n"
  "\003num\030\001 \002(\004\022\014\n\004hash\030\002 \002(\014\022\021\n\taddress_n\030\003 "
  "\003(\r\022K\n\014network_type\030\004 \001(\0162,.hw.trezor.me"
  "ssages.monero.MoneroNetworkType:\007MAINNET"
  "\022d\n\004subs\030\005 \003(\0132V.hw.trezor.messages.mone"
  "ro.MoneroKeyImageExportInitRequest.Moner"
  "oSubAddressIndicesList\032E\n\033MoneroSubAddre"
  "ssIndicesList\022\017\n\007account\030\001 \002(\r\022\025\n\rminor_"
  "indices\030\002 \003(\r\"\035\n\033MoneroKeyImageExportIni"
  "tAck\"\253\002\n\035MoneroKeyImageSyncStepRequest\022\\"
  "\n\004tdis\030\001 \003(\0132N.hw.trezor.messages.monero"
  ".MoneroKeyImageSyncStepRequest.MoneroTra"
  "nsferDetails\032\253\001\n\025MoneroTransferDetails\022\017"
  "\n\007out_key\030\001 \002(\014\022\022\n\ntx_pub_key\030\002 \002(\014\022\036\n\026a"
  "dditional_tx_pub_keys\030\003 \003(\014\022\035\n\025internal_"
  "output_index\030\004 \002(\004\022\026\n\016sub_addr_major\030\005 \001"
  "(\r\022\026\n\016sub_addr_minor\030\006 \001(\r\"\251\001\n\031MoneroKey"
  "ImageSyncStepAck\022X\n\003kis\030\001 \003(\0132K.hw.trezo"
  "r.messages.monero.MoneroKeyImageSyncStep"
  "Ack.MoneroExportedKeyImage\0322\n\026MoneroExpo"
  "rtedKeyImage\022\n\n\002iv\030\001 \001(\014\022\014\n\004blob\030\003 \001(\014\" "
  "\n\036MoneroKeyImageSyncFinalRequest\"-\n\032Mone"
  "roKeyImageSyncFinalAck\022\017\n\007enc_key\030\001 \001(\014\""
  "\353\001\n\025MoneroGetTxKeyRequest\022\021\n\taddress_n\030\001"
  " \003(\r\022K\n\014network_type\030\002 \001(\0162,.hw.trezor.m"
  "essages.monero.MoneroNetworkType:\007MAINNE"
  "T\022\r\n\005salt1\030\003 \002(\014\022\r\n\005salt2\030\004 \002(\014\022\023\n\013tx_en"
  "c_keys\030\005 \002(\014\022\026\n\016tx_prefix_hash\030\006 \002(\014\022\016\n\006"
  "reason\030\007 \001(\r\022\027\n\017view_public_key\030\010 \001(\014\"J\n"
  "\021MoneroGetTxKeyAck\022\014\n\004salt\030\001 \001(\014\022\017\n\007tx_k"
  "eys\030\002 \001(\014\022\026\n\016tx_derivations\030\003 \001(\014\"\177\n\035Mon"
  "eroLiveRefreshStartRequest\022\021\n\taddress_n\030"
  "\001 \003(\r\022K\n\014network_type\030\002 \001(\0162,.hw.trezor."
  "messages.monero.MoneroNetworkType:\007MAINN"
  "ET\"\033\n\031MoneroLiveRefreshStartAck\"\211\001\n\034Mone"
  "roLiveRefreshStepRequest\022\017\n\007out_key\030\001 \002("
  "\014\022\022\n\nrecv_deriv\030\002 \002(\014\022\024\n\014real_out_idx\030\003 "
  "\002(\004\022\026\n\016sub_addr_major\030\004 \002(\r\022\026\n\016sub_addr_"
  "minor\030\005 \002(\r\";\n\030MoneroLiveRefreshStepAck\022"
  "\014\n\004salt\030\001 \001(\014\022\021\n\tkey_image\030\002 \001(\014\"\037\n\035Mone"
  "roLiveRefreshFinalRequest\"\033\n\031MoneroLiveR"
  "efreshFinalAck\"g\n\026DebugMoneroDiagRequest"
  "\022\013\n\003ins\030\001 \001(\004\022\n\n\002p1\030\002 \001(\004\022\n\n\002p2\030\003 \001(\004\022\n\n"
  "\002pd\030\004 \003(\004\022\r\n\005data1\030\005 \001(\014\022\r\n\005data2\030\006 \001(\014\""
  "c\n\022DebugMoneroDiagAck\022\013\n\003ins\030\001 \001(\004\022\n\n\002p1"
  "\030\002 \001(\004\022\n\n\002p2\030\003 \001(\004\022\n\n\002pd\030\004 \003(\004\022\r\n\005data1\030"
  "\005 \001(\014\022\r\n\005data2\030\006 \001(\014*J\n\021MoneroNetworkTyp"
  "e\022\013\n\007MAINNET\020\000\022\013\n\007TESTNET\020\001\022\014\n\010STAGENET\020"
  "\002\022\r\n\tFAKECHAIN\020\003B:\n#com.satoshilabs.trez"
  "or.lib.protobufB\023TrezorMessageMonero"
  ;
static ::_pbi::once_flag descriptor_table_messages_2dmonero_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_messages_2dmonero_2eproto = {
    false, false, 6356, descriptor_table_protodef_messages_2dmonero_2eproto,
    "messages-monero.proto",
    &descriptor_table_messages_2dmonero_2eproto_once, nullptr, 0, 48,
    schemas, file_default_instances, TableStruct_messages_2dmonero_2eproto::offsets,
    file_level_metadata_messages_2dmonero_2eproto, file_level_enum_descriptors_messages_2dmonero_2eproto,
    file_level_service_descriptors_messages_2dmonero_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_messages_2dmonero_2eproto_getter() {
  return &descriptor_table_messages_2dmonero_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_messages_2dmonero_2eproto(&descriptor_table_messages_2dmonero_2eproto);
namespace hw {
namespace trezor {
namespace messages {
namespace monero {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoneroNetworkType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmonero_2eproto);
  return file_level_enum_descriptors_messages_2dmonero_2eproto[0];
}
bool MoneroNetworkType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>()._impl_._has_bits_);
  static void set_has_dest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_commitment(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
}
MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dest_){}
    , decltype(_impl_.commitment_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.dest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dest()) {
    _this->_impl_.dest_.Set(from._internal_dest(), 
      _this->GetArenaForAllocation());
  }
  _impl_.commitment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.commitment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_commitment()) {
    _this->_impl_.commitment_.Set(from._internal_commitment(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
}

inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dest_){}
    , decltype(_impl_.commitment_){}
  };
  _impl_.dest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.commitment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.commitment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::~MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dest_.Destroy();
  _impl_.commitment_.Destroy();
}

void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.dest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.commitment_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes dest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_dest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes commitment = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_commitment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes dest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_dest(), target);
  }

  // required bytes commitment = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_commitment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  return target;
}

size_t MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  size_t total_size = 0;

  if (_internal_has_dest()) {
    // required bytes dest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_dest());
  }

  if (_internal_has_commitment()) {
    // required bytes commitment = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_commitment());
  }

  return total_size;
}
size_t MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes dest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_dest());

    // required bytes commitment = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_commitment());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::GetClassData() const { return &_class_data_; }


void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dest(from._internal_dest());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_commitment(from._internal_commitment());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::InternalSwap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dest_, lhs_arena,
      &other->_impl_.dest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.commitment_, lhs_arena,
      &other->_impl_.commitment_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[0]);
}

// ===================================================================

class MoneroTransactionSourceEntry_MoneroOutputEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSourceEntry_MoneroOutputEntry>()._impl_._has_bits_);
  static void set_has_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& key(const MoneroTransactionSourceEntry_MoneroOutputEntry* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&
MoneroTransactionSourceEntry_MoneroOutputEntry::_Internal::key(const MoneroTransactionSourceEntry_MoneroOutputEntry* msg) {
  return *msg->_impl_.key_;
}
MoneroTransactionSourceEntry_MoneroOutputEntry::MoneroTransactionSourceEntry_MoneroOutputEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
}
MoneroTransactionSourceEntry_MoneroOutputEntry::MoneroTransactionSourceEntry_MoneroOutputEntry(const MoneroTransactionSourceEntry_MoneroOutputEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSourceEntry_MoneroOutputEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.idx_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(*from._impl_.key_);
  }
  _this->_impl_.idx_ = from._impl_.idx_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
}

inline void MoneroTransactionSourceEntry_MoneroOutputEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.idx_){uint64_t{0u}}
  };
}

MoneroTransactionSourceEntry_MoneroOutputEntry::~MoneroTransactionSourceEntry_MoneroOutputEntry() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSourceEntry_MoneroOutputEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.key_;
}

void MoneroTransactionSourceEntry_MoneroOutputEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSourceEntry_MoneroOutputEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.key_ != nullptr);
    _impl_.key_->Clear();
  }
  _impl_.idx_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSourceEntry_MoneroOutputEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_idx(&has_bits);
          _impl_.idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSourceEntry_MoneroOutputEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 idx = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_idx(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  return target;
}

size_t MoneroTransactionSourceEntry_MoneroOutputEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_);
    }

    // optional uint64 idx = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSourceEntry_MoneroOutputEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSourceEntry_MoneroOutputEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSourceEntry_MoneroOutputEntry::GetClassData() const { return &_class_data_; }


void MoneroTransactionSourceEntry_MoneroOutputEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSourceEntry_MoneroOutputEntry*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSourceEntry_MoneroOutputEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_key()->::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MergeFrom(
          from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.idx_ = from._impl_.idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSourceEntry_MoneroOutputEntry::CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSourceEntry_MoneroOutputEntry::IsInitialized() const {
  if (_internal_has_key()) {
    if (!_impl_.key_->IsInitialized()) return false;
  }
  return true;
}

void MoneroTransactionSourceEntry_MoneroOutputEntry::InternalSwap(MoneroTransactionSourceEntry_MoneroOutputEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionSourceEntry_MoneroOutputEntry, _impl_.idx_)
      + sizeof(MoneroTransactionSourceEntry_MoneroOutputEntry::_impl_.idx_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionSourceEntry_MoneroOutputEntry, _impl_.key_)>(
          reinterpret_cast<char*>(&_impl_.key_),
          reinterpret_cast<char*>(&other->_impl_.key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSourceEntry_MoneroOutputEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[1]);
}

// ===================================================================

class MoneroTransactionSourceEntry_MoneroMultisigKLRki::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSourceEntry_MoneroMultisigKLRki>()._impl_._has_bits_);
  static void set_has_k(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_l(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_r(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ki(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MoneroTransactionSourceEntry_MoneroMultisigKLRki::MoneroTransactionSourceEntry_MoneroMultisigKLRki(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
}
MoneroTransactionSourceEntry_MoneroMultisigKLRki::MoneroTransactionSourceEntry_MoneroMultisigKLRki(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSourceEntry_MoneroMultisigKLRki* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.k_){}
    , decltype(_impl_.l_){}
    , decltype(_impl_.r_){}
    , decltype(_impl_.ki_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.k_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.k_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_k()) {
    _this->_impl_.k_.Set(from._internal_k(), 
      _this->GetArenaForAllocation());
  }
  _impl_.l_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.l_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_l()) {
    _this->_impl_.l_.Set(from._internal_l(), 
      _this->GetArenaForAllocation());
  }
  _impl_.r_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.r_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_r()) {
    _this->_impl_.r_.Set(from._internal_r(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ki_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ki_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ki()) {
    _this->_impl_.ki_.Set(from._internal_ki(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
}

inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.k_){}
    , decltype(_impl_.l_){}
    , decltype(_impl_.r_){}
    , decltype(_impl_.ki_){}
  };
  _impl_.k_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.k_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.l_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.l_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.r_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.r_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ki_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ki_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSourceEntry_MoneroMultisigKLRki::~MoneroTransactionSourceEntry_MoneroMultisigKLRki() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.k_.Destroy();
  _impl_.l_.Destroy();
  _impl_.r_.Destroy();
  _impl_.ki_.Destroy();
}

void MoneroTransactionSourceEntry_MoneroMultisigKLRki::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSourceEntry_MoneroMultisigKLRki::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.k_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.l_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.r_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.ki_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSourceEntry_MoneroMultisigKLRki::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes K = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_k();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes L = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_l();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes R = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_r();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ki = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ki();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSourceEntry_MoneroMultisigKLRki::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes K = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_k(), target);
  }

  // optional bytes L = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_l(), target);
  }

  // optional bytes R = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_r(), target);
  }

  // optional bytes ki = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ki(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  return target;
}

size_t MoneroTransactionSourceEntry_MoneroMultisigKLRki::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes K = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_k());
    }

    // optional bytes L = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_l());
    }

    // optional bytes R = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_r());
    }

    // optional bytes ki = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ki());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSourceEntry_MoneroMultisigKLRki::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSourceEntry_MoneroMultisigKLRki::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSourceEntry_MoneroMultisigKLRki::GetClassData() const { return &_class_data_; }


void MoneroTransactionSourceEntry_MoneroMultisigKLRki::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSourceEntry_MoneroMultisigKLRki*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSourceEntry_MoneroMultisigKLRki&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_k(from._internal_k());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_l(from._internal_l());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_r(from._internal_r());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_ki(from._internal_ki());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSourceEntry_MoneroMultisigKLRki::CopyFrom(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::IsInitialized() const {
  return true;
}

void MoneroTransactionSourceEntry_MoneroMultisigKLRki::InternalSwap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.k_, lhs_arena,
      &other->_impl_.k_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.l_, lhs_arena,
      &other->_impl_.l_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.r_, lhs_arena,
      &other->_impl_.r_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ki_, lhs_arena,
      &other->_impl_.ki_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSourceEntry_MoneroMultisigKLRki::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[2]);
}

// ===================================================================

class MoneroTransactionSourceEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSourceEntry>()._impl_._has_bits_);
  static void set_has_real_output(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_real_out_tx_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_real_output_in_tx_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_rct(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& multisig_klrki(const MoneroTransactionSourceEntry* msg);
  static void set_has_multisig_klrki(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_subaddr_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki&
MoneroTransactionSourceEntry::_Internal::multisig_klrki(const MoneroTransactionSourceEntry* msg) {
  return *msg->_impl_.multisig_klrki_;
}
MoneroTransactionSourceEntry::MoneroTransactionSourceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
}
MoneroTransactionSourceEntry::MoneroTransactionSourceEntry(const MoneroTransactionSourceEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSourceEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outputs_){from._impl_.outputs_}
    , decltype(_impl_.real_out_additional_tx_keys_){from._impl_.real_out_additional_tx_keys_}
    , decltype(_impl_.real_out_tx_key_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.multisig_klrki_){nullptr}
    , decltype(_impl_.real_output_){}
    , decltype(_impl_.real_output_in_tx_index_){}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.rct_){}
    , decltype(_impl_.subaddr_minor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.real_out_tx_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.real_out_tx_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_real_out_tx_key()) {
    _this->_impl_.real_out_tx_key_.Set(from._internal_real_out_tx_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mask()) {
    _this->_impl_.mask_.Set(from._internal_mask(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_multisig_klrki()) {
    _this->_impl_.multisig_klrki_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki(*from._impl_.multisig_klrki_);
  }
  ::memcpy(&_impl_.real_output_, &from._impl_.real_output_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.subaddr_minor_) -
    reinterpret_cast<char*>(&_impl_.real_output_)) + sizeof(_impl_.subaddr_minor_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
}

inline void MoneroTransactionSourceEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outputs_){arena}
    , decltype(_impl_.real_out_additional_tx_keys_){arena}
    , decltype(_impl_.real_out_tx_key_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.multisig_klrki_){nullptr}
    , decltype(_impl_.real_output_){uint64_t{0u}}
    , decltype(_impl_.real_output_in_tx_index_){uint64_t{0u}}
    , decltype(_impl_.amount_){uint64_t{0u}}
    , decltype(_impl_.rct_){false}
    , decltype(_impl_.subaddr_minor_){0u}
  };
  _impl_.real_out_tx_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.real_out_tx_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSourceEntry::~MoneroTransactionSourceEntry() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSourceEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.outputs_.~RepeatedPtrField();
  _impl_.real_out_additional_tx_keys_.~RepeatedPtrField();
  _impl_.real_out_tx_key_.Destroy();
  _impl_.mask_.Destroy();
  if (this != internal_default_instance()) delete _impl_.multisig_klrki_;
}

void MoneroTransactionSourceEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSourceEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.outputs_.Clear();
  _impl_.real_out_additional_tx_keys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.real_out_tx_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.mask_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.multisig_klrki_ != nullptr);
      _impl_.multisig_klrki_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.real_output_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.subaddr_minor_) -
        reinterpret_cast<char*>(&_impl_.real_output_)) + sizeof(_impl_.subaddr_minor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSourceEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 real_output = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_real_output(&has_bits);
          _impl_.real_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes real_out_tx_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_real_out_tx_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes real_out_additional_tx_keys = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_real_out_additional_tx_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 real_output_in_tx_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_real_output_in_tx_index(&has_bits);
          _impl_.real_output_in_tx_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 amount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_amount(&has_bits);
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool rct = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_rct(&has_bits);
          _impl_.rct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes mask = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_mask();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_multisig_klrki(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 subaddr_minor = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_subaddr_minor(&has_bits);
          _impl_.subaddr_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSourceEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outputs_size()); i < n; i++) {
    const auto& repfield = this->_internal_outputs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 real_output = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_real_output(), target);
  }

  // optional bytes real_out_tx_key = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_real_out_tx_key(), target);
  }

  // repeated bytes real_out_additional_tx_keys = 4;
  for (int i = 0, n = this->_internal_real_out_additional_tx_keys_size(); i < n; i++) {
    const auto& s = this->_internal_real_out_additional_tx_keys(i);
    target = stream->WriteBytes(4, s, target);
  }

  // optional uint64 real_output_in_tx_index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_real_output_in_tx_index(), target);
  }

  // optional uint64 amount = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_amount(), target);
  }

  // optional bool rct = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_rct(), target);
  }

  // optional bytes mask = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_mask(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::multisig_klrki(this),
        _Internal::multisig_klrki(this).GetCachedSize(), target, stream);
  }

  // optional uint32 subaddr_minor = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_subaddr_minor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  return target;
}

size_t MoneroTransactionSourceEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
  total_size += 1UL * this->_internal_outputs_size();
  for (const auto& msg : this->_impl_.outputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bytes real_out_additional_tx_keys = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.real_out_additional_tx_keys_.size());
  for (int i = 0, n = _impl_.real_out_additional_tx_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.real_out_additional_tx_keys_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes real_out_tx_key = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_real_out_tx_key());
    }

    // optional bytes mask = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_mask());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.multisig_klrki_);
    }

    // optional uint64 real_output = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_real_output());
    }

    // optional uint64 real_output_in_tx_index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_real_output_in_tx_index());
    }

    // optional uint64 amount = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_amount());
    }

    // optional bool rct = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 subaddr_minor = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_subaddr_minor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSourceEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSourceEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSourceEntry::GetClassData() const { return &_class_data_; }


void MoneroTransactionSourceEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSourceEntry*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSourceEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.outputs_.MergeFrom(from._impl_.outputs_);
  _this->_impl_.real_out_additional_tx_keys_.MergeFrom(from._impl_.real_out_additional_tx_keys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_real_out_tx_key(from._internal_real_out_tx_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_mask(from._internal_mask());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_multisig_klrki()->::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki::MergeFrom(
          from._internal_multisig_klrki());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.real_output_ = from._impl_.real_output_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.real_output_in_tx_index_ = from._impl_.real_output_in_tx_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.rct_ = from._impl_.rct_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.subaddr_minor_ = from._impl_.subaddr_minor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSourceEntry::CopyFrom(const MoneroTransactionSourceEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSourceEntry::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.outputs_))
    return false;
  return true;
}

void MoneroTransactionSourceEntry::InternalSwap(MoneroTransactionSourceEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.outputs_.InternalSwap(&other->_impl_.outputs_);
  _impl_.real_out_additional_tx_keys_.InternalSwap(&other->_impl_.real_out_additional_tx_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.real_out_tx_key_, lhs_arena,
      &other->_impl_.real_out_tx_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mask_, lhs_arena,
      &other->_impl_.mask_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionSourceEntry, _impl_.subaddr_minor_)
      + sizeof(MoneroTransactionSourceEntry::_impl_.subaddr_minor_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionSourceEntry, _impl_.multisig_klrki_)>(
          reinterpret_cast<char*>(&_impl_.multisig_klrki_),
          reinterpret_cast<char*>(&other->_impl_.multisig_klrki_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSourceEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[3]);
}

// ===================================================================

class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>()._impl_._has_bits_);
  static void set_has_spend_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_view_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
}
MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spend_public_key_){}
    , decltype(_impl_.view_public_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.spend_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spend_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_spend_public_key()) {
    _this->_impl_.spend_public_key_.Set(from._internal_spend_public_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.view_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_public_key()) {
    _this->_impl_.view_public_key_.Set(from._internal_view_public_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
}

inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spend_public_key_){}
    , decltype(_impl_.view_public_key_){}
  };
  _impl_.spend_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spend_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.view_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::~MoneroTransactionDestinationEntry_MoneroAccountPublicAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.spend_public_key_.Destroy();
  _impl_.view_public_key_.Destroy();
}

void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.spend_public_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.view_public_key_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes spend_public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_spend_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes view_public_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_view_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes spend_public_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_spend_public_key(), target);
  }

  // optional bytes view_public_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_view_public_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  return target;
}

size_t MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes spend_public_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_spend_public_key());
    }

    // optional bytes view_public_key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_view_public_key());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::GetClassData() const { return &_class_data_; }


void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_spend_public_key(from._internal_spend_public_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_view_public_key(from._internal_view_public_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::CopyFrom(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::IsInitialized() const {
  return true;
}

void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::InternalSwap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.spend_public_key_, lhs_arena,
      &other->_impl_.spend_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.view_public_key_, lhs_arena,
      &other->_impl_.view_public_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[4]);
}

// ===================================================================

class MoneroTransactionDestinationEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionDestinationEntry>()._impl_._has_bits_);
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& addr(const MoneroTransactionDestinationEntry* msg);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_subaddress(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_original(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_integrated(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&
MoneroTransactionDestinationEntry::_Internal::addr(const MoneroTransactionDestinationEntry* msg) {
  return *msg->_impl_.addr_;
}
MoneroTransactionDestinationEntry::MoneroTransactionDestinationEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
}
MoneroTransactionDestinationEntry::MoneroTransactionDestinationEntry(const MoneroTransactionDestinationEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionDestinationEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.original_){}
    , decltype(_impl_.addr_){nullptr}
    , decltype(_impl_.amount_){}
    , decltype(_impl_.is_subaddress_){}
    , decltype(_impl_.is_integrated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.original_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.original_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original()) {
    _this->_impl_.original_.Set(from._internal_original(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_addr()) {
    _this->_impl_.addr_ = new ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(*from._impl_.addr_);
  }
  ::memcpy(&_impl_.amount_, &from._impl_.amount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_integrated_) -
    reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.is_integrated_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
}

inline void MoneroTransactionDestinationEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.original_){}
    , decltype(_impl_.addr_){nullptr}
    , decltype(_impl_.amount_){uint64_t{0u}}
    , decltype(_impl_.is_subaddress_){false}
    , decltype(_impl_.is_integrated_){false}
  };
  _impl_.original_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.original_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionDestinationEntry::~MoneroTransactionDestinationEntry() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionDestinationEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.original_.Destroy();
  if (this != internal_default_instance()) delete _impl_.addr_;
}

void MoneroTransactionDestinationEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionDestinationEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.original_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.addr_ != nullptr);
      _impl_.addr_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.amount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_integrated_) -
        reinterpret_cast<char*>(&_impl_.amount_)) + sizeof(_impl_.is_integrated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionDestinationEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 amount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_amount(&has_bits);
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_addr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_subaddress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_subaddress(&has_bits);
          _impl_.is_subaddress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes original = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_original();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_integrated = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_integrated(&has_bits);
          _impl_.is_integrated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionDestinationEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 amount = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_amount(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::addr(this),
        _Internal::addr(this).GetCachedSize(), target, stream);
  }

  // optional bool is_subaddress = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_subaddress(), target);
  }

  // optional bytes original = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_original(), target);
  }

  // optional bool is_integrated = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_integrated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  return target;
}

size_t MoneroTransactionDestinationEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes original = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_original());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.addr_);
    }

    // optional uint64 amount = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_amount());
    }

    // optional bool is_subaddress = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_integrated = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionDestinationEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionDestinationEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionDestinationEntry::GetClassData() const { return &_class_data_; }


void MoneroTransactionDestinationEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionDestinationEntry*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionDestinationEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_original(from._internal_original());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_addr()->::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MergeFrom(
          from._internal_addr());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_subaddress_ = from._impl_.is_subaddress_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_integrated_ = from._impl_.is_integrated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionDestinationEntry::CopyFrom(const MoneroTransactionDestinationEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionDestinationEntry::IsInitialized() const {
  return true;
}

void MoneroTransactionDestinationEntry::InternalSwap(MoneroTransactionDestinationEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.original_, lhs_arena,
      &other->_impl_.original_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionDestinationEntry, _impl_.is_integrated_)
      + sizeof(MoneroTransactionDestinationEntry::_impl_.is_integrated_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionDestinationEntry, _impl_.addr_)>(
          reinterpret_cast<char*>(&_impl_.addr_),
          reinterpret_cast<char*>(&other->_impl_.addr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionDestinationEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[5]);
}

// ===================================================================

class MoneroTransactionRsigData::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionRsigData>()._impl_._has_bits_);
  static void set_has_rsig_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offload_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rsig(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bp_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

MoneroTransactionRsigData::MoneroTransactionRsigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionRsigData)
}
MoneroTransactionRsigData::MoneroTransactionRsigData(const MoneroTransactionRsigData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionRsigData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grouping_){from._impl_.grouping_}
    , decltype(_impl_.rsig_parts_){from._impl_.rsig_parts_}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.rsig_){}
    , decltype(_impl_.rsig_type_){}
    , decltype(_impl_.offload_type_){}
    , decltype(_impl_.bp_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mask()) {
    _this->_impl_.mask_.Set(from._internal_mask(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rsig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rsig_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rsig()) {
    _this->_impl_.rsig_.Set(from._internal_rsig(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.rsig_type_, &from._impl_.rsig_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bp_version_) -
    reinterpret_cast<char*>(&_impl_.rsig_type_)) + sizeof(_impl_.bp_version_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionRsigData)
}

inline void MoneroTransactionRsigData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grouping_){arena}
    , decltype(_impl_.rsig_parts_){arena}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.rsig_){}
    , decltype(_impl_.rsig_type_){0u}
    , decltype(_impl_.offload_type_){0u}
    , decltype(_impl_.bp_version_){0u}
  };
  _impl_.mask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rsig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rsig_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionRsigData::~MoneroTransactionRsigData() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionRsigData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionRsigData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.grouping_.~RepeatedField();
  _impl_.rsig_parts_.~RepeatedPtrField();
  _impl_.mask_.Destroy();
  _impl_.rsig_.Destroy();
}

void MoneroTransactionRsigData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionRsigData::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionRsigData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.grouping_.Clear();
  _impl_.rsig_parts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.mask_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.rsig_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.rsig_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bp_version_) -
        reinterpret_cast<char*>(&_impl_.rsig_type_)) + sizeof(_impl_.bp_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionRsigData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rsig_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rsig_type(&has_bits);
          _impl_.rsig_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 offload_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_offload_type(&has_bits);
          _impl_.offload_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 grouping = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_grouping(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_grouping(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes mask = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mask();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes rsig = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_rsig();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes rsig_parts = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_rsig_parts();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bp_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bp_version(&has_bits);
          _impl_.bp_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionRsigData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionRsigData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rsig_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rsig_type(), target);
  }

  // optional uint32 offload_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_offload_type(), target);
  }

  // repeated uint64 grouping = 3;
  for (int i = 0, n = this->_internal_grouping_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_grouping(i), target);
  }

  // optional bytes mask = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_mask(), target);
  }

  // optional bytes rsig = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_rsig(), target);
  }

  // repeated bytes rsig_parts = 6;
  for (int i = 0, n = this->_internal_rsig_parts_size(); i < n; i++) {
    const auto& s = this->_internal_rsig_parts(i);
    target = stream->WriteBytes(6, s, target);
  }

  // optional uint32 bp_version = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_bp_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionRsigData)
  return target;
}

size_t MoneroTransactionRsigData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionRsigData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 grouping = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.grouping_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_grouping_size());
    total_size += data_size;
  }

  // repeated bytes rsig_parts = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.rsig_parts_.size());
  for (int i = 0, n = _impl_.rsig_parts_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.rsig_parts_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes mask = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_mask());
    }

    // optional bytes rsig = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rsig());
    }

    // optional uint32 rsig_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rsig_type());
    }

    // optional uint32 offload_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_offload_type());
    }

    // optional uint32 bp_version = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bp_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionRsigData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionRsigData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionRsigData::GetClassData() const { return &_class_data_; }


void MoneroTransactionRsigData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionRsigData*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionRsigData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionRsigData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.grouping_.MergeFrom(from._impl_.grouping_);
  _this->_impl_.rsig_parts_.MergeFrom(from._impl_.rsig_parts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_mask(from._internal_mask());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_rsig(from._internal_rsig());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rsig_type_ = from._impl_.rsig_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.offload_type_ = from._impl_.offload_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bp_version_ = from._impl_.bp_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionRsigData::CopyFrom(const MoneroTransactionRsigData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionRsigData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionRsigData::IsInitialized() const {
  return true;
}

void MoneroTransactionRsigData::InternalSwap(MoneroTransactionRsigData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.grouping_.InternalSwap(&other->_impl_.grouping_);
  _impl_.rsig_parts_.InternalSwap(&other->_impl_.rsig_parts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mask_, lhs_arena,
      &other->_impl_.mask_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rsig_, lhs_arena,
      &other->_impl_.rsig_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionRsigData, _impl_.bp_version_)
      + sizeof(MoneroTransactionRsigData::_impl_.bp_version_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionRsigData, _impl_.rsig_type_)>(
          reinterpret_cast<char*>(&_impl_.rsig_type_),
          reinterpret_cast<char*>(&other->_impl_.rsig_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionRsigData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[6]);
}

// ===================================================================

class MoneroGetAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroGetAddress>()._impl_._has_bits_);
  static void set_has_show_display(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_account(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_payment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MoneroGetAddress::MoneroGetAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroGetAddress)
}
MoneroGetAddress::MoneroGetAddress(const MoneroGetAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroGetAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.payment_id_){}
    , decltype(_impl_.show_display_){}
    , decltype(_impl_.network_type_){}
    , decltype(_impl_.account_){}
    , decltype(_impl_.minor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.payment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payment_id()) {
    _this->_impl_.payment_id_.Set(from._internal_payment_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.show_display_, &from._impl_.show_display_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.minor_) -
    reinterpret_cast<char*>(&_impl_.show_display_)) + sizeof(_impl_.minor_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroGetAddress)
}

inline void MoneroGetAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.payment_id_){}
    , decltype(_impl_.show_display_){false}
    , decltype(_impl_.network_type_){0}
    , decltype(_impl_.account_){0u}
    , decltype(_impl_.minor_){0u}
  };
  _impl_.payment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroGetAddress::~MoneroGetAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroGetAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroGetAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
  _impl_.payment_id_.Destroy();
}

void MoneroGetAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroGetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroGetAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.payment_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.show_display_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.minor_) -
        reinterpret_cast<char*>(&_impl_.show_display_)) + sizeof(_impl_.minor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroGetAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_display = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_show_display(&has_bits);
          _impl_.show_display_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(val))) {
            _internal_set_network_type(static_cast<::hw::trezor::messages::monero::MoneroNetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_account(&has_bits);
          _impl_.account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 minor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_minor(&has_bits);
          _impl_.minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payment_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_payment_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroGetAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroGetAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_address_n(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_show_display(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_network_type(), target);
  }

  // optional uint32 account = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_account(), target);
  }

  // optional uint32 minor = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_minor(), target);
  }

  // optional bytes payment_id = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_payment_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroGetAddress)
  return target;
}

size_t MoneroGetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroGetAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes payment_id = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payment_id());
    }

    // optional bool show_display = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_network_type());
    }

    // optional uint32 account = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account());
    }

    // optional uint32 minor = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroGetAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroGetAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroGetAddress::GetClassData() const { return &_class_data_; }


void MoneroGetAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroGetAddress*>(&to_msg);
  auto& from = static_cast<const MoneroGetAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroGetAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_payment_id(from._internal_payment_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.show_display_ = from._impl_.show_display_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.network_type_ = from._impl_.network_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.account_ = from._impl_.account_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.minor_ = from._impl_.minor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroGetAddress::CopyFrom(const MoneroGetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroGetAddress::IsInitialized() const {
  return true;
}

void MoneroGetAddress::InternalSwap(MoneroGetAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payment_id_, lhs_arena,
      &other->_impl_.payment_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroGetAddress, _impl_.minor_)
      + sizeof(MoneroGetAddress::_impl_.minor_)
      - PROTOBUF_FIELD_OFFSET(MoneroGetAddress, _impl_.show_display_)>(
          reinterpret_cast<char*>(&_impl_.show_display_),
          reinterpret_cast<char*>(&other->_impl_.show_display_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroGetAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[7]);
}

// ===================================================================

class MoneroAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroAddress>()._impl_._has_bits_);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MoneroAddress::MoneroAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroAddress)
}
MoneroAddress::MoneroAddress(const MoneroAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroAddress)
}

inline void MoneroAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_){}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroAddress::~MoneroAddress() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
}

void MoneroAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.address_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroAddress)
  return target;
}

size_t MoneroAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes address = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroAddress::GetClassData() const { return &_class_data_; }


void MoneroAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroAddress*>(&to_msg);
  auto& from = static_cast<const MoneroAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_address()) {
    _this->_internal_set_address(from._internal_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroAddress::CopyFrom(const MoneroAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroAddress::IsInitialized() const {
  return true;
}

void MoneroAddress::InternalSwap(MoneroAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[8]);
}

// ===================================================================

class MoneroGetWatchKey::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroGetWatchKey>()._impl_._has_bits_);
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MoneroGetWatchKey::MoneroGetWatchKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroGetWatchKey)
}
MoneroGetWatchKey::MoneroGetWatchKey(const MoneroGetWatchKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroGetWatchKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.network_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.network_type_ = from._impl_.network_type_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroGetWatchKey)
}

inline void MoneroGetWatchKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.network_type_){0}
  };
}

MoneroGetWatchKey::~MoneroGetWatchKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroGetWatchKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroGetWatchKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
}

void MoneroGetWatchKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroGetWatchKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroGetWatchKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  _impl_.network_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroGetWatchKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(val))) {
            _internal_set_network_type(static_cast<::hw::trezor::messages::monero::MoneroNetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroGetWatchKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroGetWatchKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_address_n(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_network_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroGetWatchKey)
  return target;
}

size_t MoneroGetWatchKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroGetWatchKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_network_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroGetWatchKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroGetWatchKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroGetWatchKey::GetClassData() const { return &_class_data_; }


void MoneroGetWatchKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroGetWatchKey*>(&to_msg);
  auto& from = static_cast<const MoneroGetWatchKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroGetWatchKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  if (from._internal_has_network_type()) {
    _this->_internal_set_network_type(from._internal_network_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroGetWatchKey::CopyFrom(const MoneroGetWatchKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroGetWatchKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroGetWatchKey::IsInitialized() const {
  return true;
}

void MoneroGetWatchKey::InternalSwap(MoneroGetWatchKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  swap(_impl_.network_type_, other->_impl_.network_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroGetWatchKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[9]);
}

// ===================================================================

class MoneroWatchKey::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroWatchKey>()._impl_._has_bits_);
  static void set_has_watch_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MoneroWatchKey::MoneroWatchKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroWatchKey)
}
MoneroWatchKey::MoneroWatchKey(const MoneroWatchKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroWatchKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.watch_key_){}
    , decltype(_impl_.address_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.watch_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.watch_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_watch_key()) {
    _this->_impl_.watch_key_.Set(from._internal_watch_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroWatchKey)
}

inline void MoneroWatchKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.watch_key_){}
    , decltype(_impl_.address_){}
  };
  _impl_.watch_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.watch_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroWatchKey::~MoneroWatchKey() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroWatchKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroWatchKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.watch_key_.Destroy();
  _impl_.address_.Destroy();
}

void MoneroWatchKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroWatchKey::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroWatchKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.watch_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroWatchKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes watch_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_watch_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroWatchKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroWatchKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes watch_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_watch_key(), target);
  }

  // optional bytes address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroWatchKey)
  return target;
}

size_t MoneroWatchKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroWatchKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes watch_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_watch_key());
    }

    // optional bytes address = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_address());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroWatchKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroWatchKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroWatchKey::GetClassData() const { return &_class_data_; }


void MoneroWatchKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroWatchKey*>(&to_msg);
  auto& from = static_cast<const MoneroWatchKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroWatchKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_watch_key(from._internal_watch_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_address(from._internal_address());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroWatchKey::CopyFrom(const MoneroWatchKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroWatchKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroWatchKey::IsInitialized() const {
  return true;
}

void MoneroWatchKey::InternalSwap(MoneroWatchKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.watch_key_, lhs_arena,
      &other->_impl_.watch_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroWatchKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[10]);
}

// ===================================================================

class MoneroTransactionInitRequest_MoneroTransactionData::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionInitRequest_MoneroTransactionData>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_unlock_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& change_dts(const MoneroTransactionInitRequest_MoneroTransactionData* msg);
  static void set_has_change_dts(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_inputs(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mixin(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_account(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data(const MoneroTransactionInitRequest_MoneroTransactionData* msg);
  static void set_has_rsig_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hard_fork(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_monero_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry&
MoneroTransactionInitRequest_MoneroTransactionData::_Internal::change_dts(const MoneroTransactionInitRequest_MoneroTransactionData* msg) {
  return *msg->_impl_.change_dts_;
}
const ::hw::trezor::messages::monero::MoneroTransactionRsigData&
MoneroTransactionInitRequest_MoneroTransactionData::_Internal::rsig_data(const MoneroTransactionInitRequest_MoneroTransactionData* msg) {
  return *msg->_impl_.rsig_data_;
}
MoneroTransactionInitRequest_MoneroTransactionData::MoneroTransactionInitRequest_MoneroTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
}
MoneroTransactionInitRequest_MoneroTransactionData::MoneroTransactionInitRequest_MoneroTransactionData(const MoneroTransactionInitRequest_MoneroTransactionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionInitRequest_MoneroTransactionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outputs_){from._impl_.outputs_}
    , decltype(_impl_.minor_indices_){from._impl_.minor_indices_}
    , decltype(_impl_.integrated_indices_){from._impl_.integrated_indices_}
    , decltype(_impl_.payment_id_){}
    , decltype(_impl_.monero_version_){}
    , decltype(_impl_.change_dts_){nullptr}
    , decltype(_impl_.rsig_data_){nullptr}
    , decltype(_impl_.unlock_time_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.num_inputs_){}
    , decltype(_impl_.fee_){}
    , decltype(_impl_.mixin_){}
    , decltype(_impl_.account_){}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.hard_fork_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.payment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payment_id()) {
    _this->_impl_.payment_id_.Set(from._internal_payment_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.monero_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.monero_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_monero_version()) {
    _this->_impl_.monero_version_.Set(from._internal_monero_version(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_change_dts()) {
    _this->_impl_.change_dts_ = new ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry(*from._impl_.change_dts_);
  }
  if (from._internal_has_rsig_data()) {
    _this->_impl_.rsig_data_ = new ::hw::trezor::messages::monero::MoneroTransactionRsigData(*from._impl_.rsig_data_);
  }
  ::memcpy(&_impl_.unlock_time_, &from._impl_.unlock_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hard_fork_) -
    reinterpret_cast<char*>(&_impl_.unlock_time_)) + sizeof(_impl_.hard_fork_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
}

inline void MoneroTransactionInitRequest_MoneroTransactionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.outputs_){arena}
    , decltype(_impl_.minor_indices_){arena}
    , decltype(_impl_.integrated_indices_){arena}
    , decltype(_impl_.payment_id_){}
    , decltype(_impl_.monero_version_){}
    , decltype(_impl_.change_dts_){nullptr}
    , decltype(_impl_.rsig_data_){nullptr}
    , decltype(_impl_.unlock_time_){uint64_t{0u}}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.num_inputs_){0u}
    , decltype(_impl_.fee_){uint64_t{0u}}
    , decltype(_impl_.mixin_){0u}
    , decltype(_impl_.account_){0u}
    , decltype(_impl_.client_version_){0u}
    , decltype(_impl_.hard_fork_){0u}
  };
  _impl_.payment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.monero_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.monero_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionInitRequest_MoneroTransactionData::~MoneroTransactionInitRequest_MoneroTransactionData() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionInitRequest_MoneroTransactionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.outputs_.~RepeatedPtrField();
  _impl_.minor_indices_.~RepeatedField();
  _impl_.integrated_indices_.~RepeatedField();
  _impl_.payment_id_.Destroy();
  _impl_.monero_version_.Destroy();
  if (this != internal_default_instance()) delete _impl_.change_dts_;
  if (this != internal_default_instance()) delete _impl_.rsig_data_;
}

void MoneroTransactionInitRequest_MoneroTransactionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionInitRequest_MoneroTransactionData::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.outputs_.Clear();
  _impl_.minor_indices_.Clear();
  _impl_.integrated_indices_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.payment_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.monero_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.change_dts_ != nullptr);
      _impl_.change_dts_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rsig_data_ != nullptr);
      _impl_.rsig_data_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.unlock_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fee_) -
        reinterpret_cast<char*>(&_impl_.unlock_time_)) + sizeof(_impl_.fee_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.mixin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hard_fork_) -
        reinterpret_cast<char*>(&_impl_.mixin_)) + sizeof(_impl_.hard_fork_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionInitRequest_MoneroTransactionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payment_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payment_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 unlock_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unlock_time(&has_bits);
          _impl_.unlock_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_dts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_inputs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_inputs(&has_bits);
          _impl_.num_inputs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mixin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_mixin(&has_bits);
          _impl_.mixin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fee = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_fee(&has_bits);
          _impl_.fee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 account = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_account(&has_bits);
          _impl_.account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 minor_indices = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_minor_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<80>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_minor_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsig_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 integrated_indices = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_integrated_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_integrated_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_version = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_client_version(&has_bits);
          _impl_.client_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hard_fork = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_hard_fork(&has_bits);
          _impl_.hard_fork_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes monero_version = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_monero_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionInitRequest_MoneroTransactionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // optional bytes payment_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_payment_id(), target);
  }

  // optional uint64 unlock_time = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_unlock_time(), target);
  }

  // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outputs_size()); i < n; i++) {
    const auto& repfield = this->_internal_outputs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::change_dts(this),
        _Internal::change_dts(this).GetCachedSize(), target, stream);
  }

  // optional uint32 num_inputs = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_num_inputs(), target);
  }

  // optional uint32 mixin = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_mixin(), target);
  }

  // optional uint64 fee = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_fee(), target);
  }

  // optional uint32 account = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_account(), target);
  }

  // repeated uint32 minor_indices = 10;
  for (int i = 0, n = this->_internal_minor_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_minor_indices(i), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::rsig_data(this),
        _Internal::rsig_data(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 integrated_indices = 12;
  for (int i = 0, n = this->_internal_integrated_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_integrated_indices(i), target);
  }

  // optional uint32 client_version = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_client_version(), target);
  }

  // optional uint32 hard_fork = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_hard_fork(), target);
  }

  // optional bytes monero_version = 15;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_monero_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  return target;
}

size_t MoneroTransactionInitRequest_MoneroTransactionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
  total_size += 1UL * this->_internal_outputs_size();
  for (const auto& msg : this->_impl_.outputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 minor_indices = 10;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.minor_indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_minor_indices_size());
    total_size += data_size;
  }

  // repeated uint32 integrated_indices = 12;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.integrated_indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_integrated_indices_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes payment_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payment_id());
    }

    // optional bytes monero_version = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_monero_version());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.change_dts_);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rsig_data_);
    }

    // optional uint64 unlock_time = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_unlock_time());
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 num_inputs = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_inputs());
    }

    // optional uint64 fee = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fee());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 mixin = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mixin());
    }

    // optional uint32 account = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account());
    }

    // optional uint32 client_version = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_client_version());
    }

    // optional uint32 hard_fork = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hard_fork());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionInitRequest_MoneroTransactionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionInitRequest_MoneroTransactionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionInitRequest_MoneroTransactionData::GetClassData() const { return &_class_data_; }


void MoneroTransactionInitRequest_MoneroTransactionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionInitRequest_MoneroTransactionData*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionInitRequest_MoneroTransactionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.outputs_.MergeFrom(from._impl_.outputs_);
  _this->_impl_.minor_indices_.MergeFrom(from._impl_.minor_indices_);
  _this->_impl_.integrated_indices_.MergeFrom(from._impl_.integrated_indices_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_payment_id(from._internal_payment_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_monero_version(from._internal_monero_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_change_dts()->::hw::trezor::messages::monero::MoneroTransactionDestinationEntry::MergeFrom(
          from._internal_change_dts());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rsig_data()->::hw::trezor::messages::monero::MoneroTransactionRsigData::MergeFrom(
          from._internal_rsig_data());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.unlock_time_ = from._impl_.unlock_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_inputs_ = from._impl_.num_inputs_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.fee_ = from._impl_.fee_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.mixin_ = from._impl_.mixin_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.account_ = from._impl_.account_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.client_version_ = from._impl_.client_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.hard_fork_ = from._impl_.hard_fork_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionInitRequest_MoneroTransactionData::CopyFrom(const MoneroTransactionInitRequest_MoneroTransactionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionInitRequest_MoneroTransactionData::IsInitialized() const {
  return true;
}

void MoneroTransactionInitRequest_MoneroTransactionData::InternalSwap(MoneroTransactionInitRequest_MoneroTransactionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.outputs_.InternalSwap(&other->_impl_.outputs_);
  _impl_.minor_indices_.InternalSwap(&other->_impl_.minor_indices_);
  _impl_.integrated_indices_.InternalSwap(&other->_impl_.integrated_indices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payment_id_, lhs_arena,
      &other->_impl_.payment_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.monero_version_, lhs_arena,
      &other->_impl_.monero_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionInitRequest_MoneroTransactionData, _impl_.hard_fork_)
      + sizeof(MoneroTransactionInitRequest_MoneroTransactionData::_impl_.hard_fork_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionInitRequest_MoneroTransactionData, _impl_.change_dts_)>(
          reinterpret_cast<char*>(&_impl_.change_dts_),
          reinterpret_cast<char*>(&other->_impl_.change_dts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionInitRequest_MoneroTransactionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[11]);
}

// ===================================================================

class MoneroTransactionInitRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionInitRequest>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& tsx_data(const MoneroTransactionInitRequest* msg);
  static void set_has_tsx_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData&
MoneroTransactionInitRequest::_Internal::tsx_data(const MoneroTransactionInitRequest* msg) {
  return *msg->_impl_.tsx_data_;
}
MoneroTransactionInitRequest::MoneroTransactionInitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionInitRequest)
}
MoneroTransactionInitRequest::MoneroTransactionInitRequest(const MoneroTransactionInitRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionInitRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.tsx_data_){nullptr}
    , decltype(_impl_.version_){}
    , decltype(_impl_.network_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tsx_data()) {
    _this->_impl_.tsx_data_ = new ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData(*from._impl_.tsx_data_);
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.network_type_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.network_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionInitRequest)
}

inline void MoneroTransactionInitRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.tsx_data_){nullptr}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.network_type_){0}
  };
}

MoneroTransactionInitRequest::~MoneroTransactionInitRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionInitRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.tsx_data_;
}

void MoneroTransactionInitRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionInitRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tsx_data_ != nullptr);
    _impl_.tsx_data_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.network_type_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.network_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionInitRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 address_n = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(val))) {
            _internal_set_network_type(static_cast<::hw::trezor::messages::monero::MoneroNetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tsx_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionInitRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_address_n(i), target);
  }

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_network_type(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::tsx_data(this),
        _Internal::tsx_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  return target;
}

size_t MoneroTransactionInitRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tsx_data_);
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_network_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionInitRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionInitRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionInitRequest::GetClassData() const { return &_class_data_; }


void MoneroTransactionInitRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionInitRequest*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionInitRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tsx_data()->::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData::MergeFrom(
          from._internal_tsx_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.network_type_ = from._impl_.network_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionInitRequest::CopyFrom(const MoneroTransactionInitRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionInitRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionInitRequest::IsInitialized() const {
  return true;
}

void MoneroTransactionInitRequest::InternalSwap(MoneroTransactionInitRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionInitRequest, _impl_.network_type_)
      + sizeof(MoneroTransactionInitRequest::_impl_.network_type_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionInitRequest, _impl_.tsx_data_)>(
          reinterpret_cast<char*>(&_impl_.tsx_data_),
          reinterpret_cast<char*>(&other->_impl_.tsx_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionInitRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[12]);
}

// ===================================================================

class MoneroTransactionInitAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionInitAck>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data(const MoneroTransactionInitAck* msg);
  static void set_has_rsig_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionRsigData&
MoneroTransactionInitAck::_Internal::rsig_data(const MoneroTransactionInitAck* msg) {
  return *msg->_impl_.rsig_data_;
}
MoneroTransactionInitAck::MoneroTransactionInitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionInitAck)
}
MoneroTransactionInitAck::MoneroTransactionInitAck(const MoneroTransactionInitAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionInitAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hmacs_){from._impl_.hmacs_}
    , decltype(_impl_.rsig_data_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rsig_data()) {
    _this->_impl_.rsig_data_ = new ::hw::trezor::messages::monero::MoneroTransactionRsigData(*from._impl_.rsig_data_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionInitAck)
}

inline void MoneroTransactionInitAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hmacs_){arena}
    , decltype(_impl_.rsig_data_){nullptr}
  };
}

MoneroTransactionInitAck::~MoneroTransactionInitAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionInitAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionInitAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hmacs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.rsig_data_;
}

void MoneroTransactionInitAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionInitAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionInitAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hmacs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.rsig_data_ != nullptr);
    _impl_.rsig_data_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionInitAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes hmacs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hmacs();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsig_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionInitAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionInitAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes hmacs = 1;
  for (int i = 0, n = this->_internal_hmacs_size(); i < n; i++) {
    const auto& s = this->_internal_hmacs(i);
    target = stream->WriteBytes(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rsig_data(this),
        _Internal::rsig_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionInitAck)
  return target;
}

size_t MoneroTransactionInitAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionInitAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hmacs = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hmacs_.size());
  for (int i = 0, n = _impl_.hmacs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.hmacs_.Get(i));
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rsig_data_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionInitAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionInitAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionInitAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionInitAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionInitAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionInitAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionInitAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hmacs_.MergeFrom(from._impl_.hmacs_);
  if (from._internal_has_rsig_data()) {
    _this->_internal_mutable_rsig_data()->::hw::trezor::messages::monero::MoneroTransactionRsigData::MergeFrom(
        from._internal_rsig_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionInitAck::CopyFrom(const MoneroTransactionInitAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionInitAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionInitAck::IsInitialized() const {
  return true;
}

void MoneroTransactionInitAck::InternalSwap(MoneroTransactionInitAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hmacs_.InternalSwap(&other->_impl_.hmacs_);
  swap(_impl_.rsig_data_, other->_impl_.rsig_data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionInitAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[13]);
}

// ===================================================================

class MoneroTransactionSetInputRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSetInputRequest>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr(const MoneroTransactionSetInputRequest* msg);
  static void set_has_src_entr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry&
MoneroTransactionSetInputRequest::_Internal::src_entr(const MoneroTransactionSetInputRequest* msg) {
  return *msg->_impl_.src_entr_;
}
MoneroTransactionSetInputRequest::MoneroTransactionSetInputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
}
MoneroTransactionSetInputRequest::MoneroTransactionSetInputRequest(const MoneroTransactionSetInputRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSetInputRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_entr_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_src_entr()) {
    _this->_impl_.src_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry(*from._impl_.src_entr_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
}

inline void MoneroTransactionSetInputRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.src_entr_){nullptr}
  };
}

MoneroTransactionSetInputRequest::~MoneroTransactionSetInputRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSetInputRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.src_entr_;
}

void MoneroTransactionSetInputRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSetInputRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.src_entr_ != nullptr);
    _impl_.src_entr_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSetInputRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_entr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSetInputRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::src_entr(this),
        _Internal::src_entr(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  return target;
}

size_t MoneroTransactionSetInputRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.src_entr_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSetInputRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSetInputRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSetInputRequest::GetClassData() const { return &_class_data_; }


void MoneroTransactionSetInputRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSetInputRequest*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSetInputRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_src_entr()) {
    _this->_internal_mutable_src_entr()->::hw::trezor::messages::monero::MoneroTransactionSourceEntry::MergeFrom(
        from._internal_src_entr());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSetInputRequest::CopyFrom(const MoneroTransactionSetInputRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSetInputRequest::IsInitialized() const {
  if (_internal_has_src_entr()) {
    if (!_impl_.src_entr_->IsInitialized()) return false;
  }
  return true;
}

void MoneroTransactionSetInputRequest::InternalSwap(MoneroTransactionSetInputRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.src_entr_, other->_impl_.src_entr_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSetInputRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[14]);
}

// ===================================================================

class MoneroTransactionSetInputAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSetInputAck>()._impl_._has_bits_);
  static void set_has_vini(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vini_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pseudo_out(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pseudo_out_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pseudo_out_alpha(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_spend_key(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MoneroTransactionSetInputAck::MoneroTransactionSetInputAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
}
MoneroTransactionSetInputAck::MoneroTransactionSetInputAck(const MoneroTransactionSetInputAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSetInputAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vini_){}
    , decltype(_impl_.vini_hmac_){}
    , decltype(_impl_.pseudo_out_){}
    , decltype(_impl_.pseudo_out_hmac_){}
    , decltype(_impl_.pseudo_out_alpha_){}
    , decltype(_impl_.spend_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vini_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vini()) {
    _this->_impl_.vini_.Set(from._internal_vini(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vini_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vini_hmac()) {
    _this->_impl_.vini_hmac_.Set(from._internal_vini_hmac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out()) {
    _this->_impl_.pseudo_out_.Set(from._internal_pseudo_out(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out_hmac()) {
    _this->_impl_.pseudo_out_hmac_.Set(from._internal_pseudo_out_hmac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_alpha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out_alpha()) {
    _this->_impl_.pseudo_out_alpha_.Set(from._internal_pseudo_out_alpha(), 
      _this->GetArenaForAllocation());
  }
  _impl_.spend_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_spend_key()) {
    _this->_impl_.spend_key_.Set(from._internal_spend_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
}

inline void MoneroTransactionSetInputAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vini_){}
    , decltype(_impl_.vini_hmac_){}
    , decltype(_impl_.pseudo_out_){}
    , decltype(_impl_.pseudo_out_hmac_){}
    , decltype(_impl_.pseudo_out_alpha_){}
    , decltype(_impl_.spend_key_){}
  };
  _impl_.vini_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vini_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_alpha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.spend_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSetInputAck::~MoneroTransactionSetInputAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSetInputAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vini_.Destroy();
  _impl_.vini_hmac_.Destroy();
  _impl_.pseudo_out_.Destroy();
  _impl_.pseudo_out_hmac_.Destroy();
  _impl_.pseudo_out_alpha_.Destroy();
  _impl_.spend_key_.Destroy();
}

void MoneroTransactionSetInputAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSetInputAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vini_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.vini_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.pseudo_out_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.pseudo_out_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.pseudo_out_alpha_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.spend_key_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSetInputAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes vini = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vini();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vini_hmac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_vini_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_pseudo_out();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out_hmac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pseudo_out_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out_alpha = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_pseudo_out_alpha();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes spend_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_spend_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSetInputAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes vini = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_vini(), target);
  }

  // optional bytes vini_hmac = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_vini_hmac(), target);
  }

  // optional bytes pseudo_out = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_pseudo_out(), target);
  }

  // optional bytes pseudo_out_hmac = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_pseudo_out_hmac(), target);
  }

  // optional bytes pseudo_out_alpha = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_pseudo_out_alpha(), target);
  }

  // optional bytes spend_key = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_spend_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  return target;
}

size_t MoneroTransactionSetInputAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes vini = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vini());
    }

    // optional bytes vini_hmac = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vini_hmac());
    }

    // optional bytes pseudo_out = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out());
    }

    // optional bytes pseudo_out_hmac = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out_hmac());
    }

    // optional bytes pseudo_out_alpha = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out_alpha());
    }

    // optional bytes spend_key = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_spend_key());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSetInputAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSetInputAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSetInputAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionSetInputAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSetInputAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSetInputAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vini(from._internal_vini());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_vini_hmac(from._internal_vini_hmac());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_pseudo_out(from._internal_pseudo_out());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_pseudo_out_hmac(from._internal_pseudo_out_hmac());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_pseudo_out_alpha(from._internal_pseudo_out_alpha());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_spend_key(from._internal_spend_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSetInputAck::CopyFrom(const MoneroTransactionSetInputAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSetInputAck::IsInitialized() const {
  return true;
}

void MoneroTransactionSetInputAck::InternalSwap(MoneroTransactionSetInputAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vini_, lhs_arena,
      &other->_impl_.vini_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vini_hmac_, lhs_arena,
      &other->_impl_.vini_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_, lhs_arena,
      &other->_impl_.pseudo_out_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_hmac_, lhs_arena,
      &other->_impl_.pseudo_out_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_alpha_, lhs_arena,
      &other->_impl_.pseudo_out_alpha_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.spend_key_, lhs_arena,
      &other->_impl_.spend_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSetInputAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[15]);
}

// ===================================================================

class MoneroTransactionInputViniRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionInputViniRequest>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr(const MoneroTransactionInputViniRequest* msg);
  static void set_has_src_entr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_vini(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vini_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pseudo_out(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pseudo_out_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_orig_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry&
MoneroTransactionInputViniRequest::_Internal::src_entr(const MoneroTransactionInputViniRequest* msg) {
  return *msg->_impl_.src_entr_;
}
MoneroTransactionInputViniRequest::MoneroTransactionInputViniRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
}
MoneroTransactionInputViniRequest::MoneroTransactionInputViniRequest(const MoneroTransactionInputViniRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionInputViniRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vini_){}
    , decltype(_impl_.vini_hmac_){}
    , decltype(_impl_.pseudo_out_){}
    , decltype(_impl_.pseudo_out_hmac_){}
    , decltype(_impl_.src_entr_){nullptr}
    , decltype(_impl_.orig_idx_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vini_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vini()) {
    _this->_impl_.vini_.Set(from._internal_vini(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vini_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vini_hmac()) {
    _this->_impl_.vini_hmac_.Set(from._internal_vini_hmac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out()) {
    _this->_impl_.pseudo_out_.Set(from._internal_pseudo_out(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out_hmac()) {
    _this->_impl_.pseudo_out_hmac_.Set(from._internal_pseudo_out_hmac(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_src_entr()) {
    _this->_impl_.src_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry(*from._impl_.src_entr_);
  }
  _this->_impl_.orig_idx_ = from._impl_.orig_idx_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
}

inline void MoneroTransactionInputViniRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vini_){}
    , decltype(_impl_.vini_hmac_){}
    , decltype(_impl_.pseudo_out_){}
    , decltype(_impl_.pseudo_out_hmac_){}
    , decltype(_impl_.src_entr_){nullptr}
    , decltype(_impl_.orig_idx_){0u}
  };
  _impl_.vini_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vini_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionInputViniRequest::~MoneroTransactionInputViniRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionInputViniRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vini_.Destroy();
  _impl_.vini_hmac_.Destroy();
  _impl_.pseudo_out_.Destroy();
  _impl_.pseudo_out_hmac_.Destroy();
  if (this != internal_default_instance()) delete _impl_.src_entr_;
}

void MoneroTransactionInputViniRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionInputViniRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vini_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.vini_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.pseudo_out_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.pseudo_out_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.src_entr_ != nullptr);
      _impl_.src_entr_->Clear();
    }
  }
  _impl_.orig_idx_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionInputViniRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_entr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vini = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_vini();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vini_hmac = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_vini_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pseudo_out();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out_hmac = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_pseudo_out_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orig_idx = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_orig_idx(&has_bits);
          _impl_.orig_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionInputViniRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::src_entr(this),
        _Internal::src_entr(this).GetCachedSize(), target, stream);
  }

  // optional bytes vini = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_vini(), target);
  }

  // optional bytes vini_hmac = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_vini_hmac(), target);
  }

  // optional bytes pseudo_out = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_pseudo_out(), target);
  }

  // optional bytes pseudo_out_hmac = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_pseudo_out_hmac(), target);
  }

  // optional uint32 orig_idx = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_orig_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  return target;
}

size_t MoneroTransactionInputViniRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes vini = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vini());
    }

    // optional bytes vini_hmac = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vini_hmac());
    }

    // optional bytes pseudo_out = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out());
    }

    // optional bytes pseudo_out_hmac = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out_hmac());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.src_entr_);
    }

    // optional uint32 orig_idx = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orig_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionInputViniRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionInputViniRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionInputViniRequest::GetClassData() const { return &_class_data_; }


void MoneroTransactionInputViniRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionInputViniRequest*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionInputViniRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vini(from._internal_vini());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_vini_hmac(from._internal_vini_hmac());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_pseudo_out(from._internal_pseudo_out());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_pseudo_out_hmac(from._internal_pseudo_out_hmac());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_src_entr()->::hw::trezor::messages::monero::MoneroTransactionSourceEntry::MergeFrom(
          from._internal_src_entr());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.orig_idx_ = from._impl_.orig_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionInputViniRequest::CopyFrom(const MoneroTransactionInputViniRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionInputViniRequest::IsInitialized() const {
  if (_internal_has_src_entr()) {
    if (!_impl_.src_entr_->IsInitialized()) return false;
  }
  return true;
}

void MoneroTransactionInputViniRequest::InternalSwap(MoneroTransactionInputViniRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vini_, lhs_arena,
      &other->_impl_.vini_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vini_hmac_, lhs_arena,
      &other->_impl_.vini_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_, lhs_arena,
      &other->_impl_.pseudo_out_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_hmac_, lhs_arena,
      &other->_impl_.pseudo_out_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionInputViniRequest, _impl_.orig_idx_)
      + sizeof(MoneroTransactionInputViniRequest::_impl_.orig_idx_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionInputViniRequest, _impl_.src_entr_)>(
          reinterpret_cast<char*>(&_impl_.src_entr_),
          reinterpret_cast<char*>(&other->_impl_.src_entr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionInputViniRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[16]);
}

// ===================================================================

class MoneroTransactionInputViniAck::_Internal {
 public:
};

MoneroTransactionInputViniAck::MoneroTransactionInputViniAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
}
MoneroTransactionInputViniAck::MoneroTransactionInputViniAck(const MoneroTransactionInputViniAck& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroTransactionInputViniAck* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionInputViniAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionInputViniAck::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionInputViniAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[17]);
}

// ===================================================================

class MoneroTransactionAllInputsSetRequest::_Internal {
 public:
};

MoneroTransactionAllInputsSetRequest::MoneroTransactionAllInputsSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest)
}
MoneroTransactionAllInputsSetRequest::MoneroTransactionAllInputsSetRequest(const MoneroTransactionAllInputsSetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroTransactionAllInputsSetRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionAllInputsSetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionAllInputsSetRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionAllInputsSetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[18]);
}

// ===================================================================

class MoneroTransactionAllInputsSetAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionAllInputsSetAck>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data(const MoneroTransactionAllInputsSetAck* msg);
  static void set_has_rsig_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionRsigData&
MoneroTransactionAllInputsSetAck::_Internal::rsig_data(const MoneroTransactionAllInputsSetAck* msg) {
  return *msg->_impl_.rsig_data_;
}
MoneroTransactionAllInputsSetAck::MoneroTransactionAllInputsSetAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
}
MoneroTransactionAllInputsSetAck::MoneroTransactionAllInputsSetAck(const MoneroTransactionAllInputsSetAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionAllInputsSetAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rsig_data_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rsig_data()) {
    _this->_impl_.rsig_data_ = new ::hw::trezor::messages::monero::MoneroTransactionRsigData(*from._impl_.rsig_data_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
}

inline void MoneroTransactionAllInputsSetAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rsig_data_){nullptr}
  };
}

MoneroTransactionAllInputsSetAck::~MoneroTransactionAllInputsSetAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionAllInputsSetAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rsig_data_;
}

void MoneroTransactionAllInputsSetAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionAllInputsSetAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.rsig_data_ != nullptr);
    _impl_.rsig_data_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionAllInputsSetAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsig_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionAllInputsSetAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rsig_data(this),
        _Internal::rsig_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  return target;
}

size_t MoneroTransactionAllInputsSetAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rsig_data_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionAllInputsSetAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionAllInputsSetAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionAllInputsSetAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionAllInputsSetAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionAllInputsSetAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionAllInputsSetAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rsig_data()) {
    _this->_internal_mutable_rsig_data()->::hw::trezor::messages::monero::MoneroTransactionRsigData::MergeFrom(
        from._internal_rsig_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionAllInputsSetAck::CopyFrom(const MoneroTransactionAllInputsSetAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionAllInputsSetAck::IsInitialized() const {
  return true;
}

void MoneroTransactionAllInputsSetAck::InternalSwap(MoneroTransactionAllInputsSetAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rsig_data_, other->_impl_.rsig_data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionAllInputsSetAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[19]);
}

// ===================================================================

class MoneroTransactionSetOutputRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSetOutputRequest>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& dst_entr(const MoneroTransactionSetOutputRequest* msg);
  static void set_has_dst_entr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dst_entr_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data(const MoneroTransactionSetOutputRequest* msg);
  static void set_has_rsig_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_offloaded_bp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry&
MoneroTransactionSetOutputRequest::_Internal::dst_entr(const MoneroTransactionSetOutputRequest* msg) {
  return *msg->_impl_.dst_entr_;
}
const ::hw::trezor::messages::monero::MoneroTransactionRsigData&
MoneroTransactionSetOutputRequest::_Internal::rsig_data(const MoneroTransactionSetOutputRequest* msg) {
  return *msg->_impl_.rsig_data_;
}
MoneroTransactionSetOutputRequest::MoneroTransactionSetOutputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
}
MoneroTransactionSetOutputRequest::MoneroTransactionSetOutputRequest(const MoneroTransactionSetOutputRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSetOutputRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dst_entr_hmac_){}
    , decltype(_impl_.dst_entr_){nullptr}
    , decltype(_impl_.rsig_data_){nullptr}
    , decltype(_impl_.is_offloaded_bp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.dst_entr_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dst_entr_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dst_entr_hmac()) {
    _this->_impl_.dst_entr_hmac_.Set(from._internal_dst_entr_hmac(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_dst_entr()) {
    _this->_impl_.dst_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry(*from._impl_.dst_entr_);
  }
  if (from._internal_has_rsig_data()) {
    _this->_impl_.rsig_data_ = new ::hw::trezor::messages::monero::MoneroTransactionRsigData(*from._impl_.rsig_data_);
  }
  _this->_impl_.is_offloaded_bp_ = from._impl_.is_offloaded_bp_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
}

inline void MoneroTransactionSetOutputRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dst_entr_hmac_){}
    , decltype(_impl_.dst_entr_){nullptr}
    , decltype(_impl_.rsig_data_){nullptr}
    , decltype(_impl_.is_offloaded_bp_){false}
  };
  _impl_.dst_entr_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dst_entr_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSetOutputRequest::~MoneroTransactionSetOutputRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSetOutputRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dst_entr_hmac_.Destroy();
  if (this != internal_default_instance()) delete _impl_.dst_entr_;
  if (this != internal_default_instance()) delete _impl_.rsig_data_;
}

void MoneroTransactionSetOutputRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSetOutputRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.dst_entr_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dst_entr_ != nullptr);
      _impl_.dst_entr_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.rsig_data_ != nullptr);
      _impl_.rsig_data_->Clear();
    }
  }
  _impl_.is_offloaded_bp_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSetOutputRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dst_entr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dst_entr_hmac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dst_entr_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsig_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_offloaded_bp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_offloaded_bp(&has_bits);
          _impl_.is_offloaded_bp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSetOutputRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::dst_entr(this),
        _Internal::dst_entr(this).GetCachedSize(), target, stream);
  }

  // optional bytes dst_entr_hmac = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_dst_entr_hmac(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rsig_data(this),
        _Internal::rsig_data(this).GetCachedSize(), target, stream);
  }

  // optional bool is_offloaded_bp = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_offloaded_bp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  return target;
}

size_t MoneroTransactionSetOutputRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes dst_entr_hmac = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dst_entr_hmac());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dst_entr_);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rsig_data_);
    }

    // optional bool is_offloaded_bp = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSetOutputRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSetOutputRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSetOutputRequest::GetClassData() const { return &_class_data_; }


void MoneroTransactionSetOutputRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSetOutputRequest*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSetOutputRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dst_entr_hmac(from._internal_dst_entr_hmac());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dst_entr()->::hw::trezor::messages::monero::MoneroTransactionDestinationEntry::MergeFrom(
          from._internal_dst_entr());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_rsig_data()->::hw::trezor::messages::monero::MoneroTransactionRsigData::MergeFrom(
          from._internal_rsig_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_offloaded_bp_ = from._impl_.is_offloaded_bp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSetOutputRequest::CopyFrom(const MoneroTransactionSetOutputRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSetOutputRequest::IsInitialized() const {
  return true;
}

void MoneroTransactionSetOutputRequest::InternalSwap(MoneroTransactionSetOutputRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dst_entr_hmac_, lhs_arena,
      &other->_impl_.dst_entr_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionSetOutputRequest, _impl_.is_offloaded_bp_)
      + sizeof(MoneroTransactionSetOutputRequest::_impl_.is_offloaded_bp_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionSetOutputRequest, _impl_.dst_entr_)>(
          reinterpret_cast<char*>(&_impl_.dst_entr_),
          reinterpret_cast<char*>(&other->_impl_.dst_entr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSetOutputRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[20]);
}

// ===================================================================

class MoneroTransactionSetOutputAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSetOutputAck>()._impl_._has_bits_);
  static void set_has_tx_out(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vouti_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data(const MoneroTransactionSetOutputAck* msg);
  static void set_has_rsig_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_out_pk(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ecdh_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionRsigData&
MoneroTransactionSetOutputAck::_Internal::rsig_data(const MoneroTransactionSetOutputAck* msg) {
  return *msg->_impl_.rsig_data_;
}
MoneroTransactionSetOutputAck::MoneroTransactionSetOutputAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
}
MoneroTransactionSetOutputAck::MoneroTransactionSetOutputAck(const MoneroTransactionSetOutputAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSetOutputAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tx_out_){}
    , decltype(_impl_.vouti_hmac_){}
    , decltype(_impl_.out_pk_){}
    , decltype(_impl_.ecdh_info_){}
    , decltype(_impl_.rsig_data_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tx_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_out()) {
    _this->_impl_.tx_out_.Set(from._internal_tx_out(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vouti_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vouti_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vouti_hmac()) {
    _this->_impl_.vouti_hmac_.Set(from._internal_vouti_hmac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.out_pk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_pk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_out_pk()) {
    _this->_impl_.out_pk_.Set(from._internal_out_pk(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ecdh_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ecdh_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ecdh_info()) {
    _this->_impl_.ecdh_info_.Set(from._internal_ecdh_info(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_rsig_data()) {
    _this->_impl_.rsig_data_ = new ::hw::trezor::messages::monero::MoneroTransactionRsigData(*from._impl_.rsig_data_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
}

inline void MoneroTransactionSetOutputAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tx_out_){}
    , decltype(_impl_.vouti_hmac_){}
    , decltype(_impl_.out_pk_){}
    , decltype(_impl_.ecdh_info_){}
    , decltype(_impl_.rsig_data_){nullptr}
  };
  _impl_.tx_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vouti_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vouti_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.out_pk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_pk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ecdh_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ecdh_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSetOutputAck::~MoneroTransactionSetOutputAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSetOutputAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tx_out_.Destroy();
  _impl_.vouti_hmac_.Destroy();
  _impl_.out_pk_.Destroy();
  _impl_.ecdh_info_.Destroy();
  if (this != internal_default_instance()) delete _impl_.rsig_data_;
}

void MoneroTransactionSetOutputAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSetOutputAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.tx_out_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.vouti_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.out_pk_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.ecdh_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.rsig_data_ != nullptr);
      _impl_.rsig_data_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSetOutputAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes tx_out = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tx_out();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vouti_hmac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_vouti_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsig_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes out_pk = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_out_pk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ecdh_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ecdh_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSetOutputAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes tx_out = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_tx_out(), target);
  }

  // optional bytes vouti_hmac = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_vouti_hmac(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rsig_data(this),
        _Internal::rsig_data(this).GetCachedSize(), target, stream);
  }

  // optional bytes out_pk = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_out_pk(), target);
  }

  // optional bytes ecdh_info = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_ecdh_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  return target;
}

size_t MoneroTransactionSetOutputAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes tx_out = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_tx_out());
    }

    // optional bytes vouti_hmac = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vouti_hmac());
    }

    // optional bytes out_pk = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_out_pk());
    }

    // optional bytes ecdh_info = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdh_info());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rsig_data_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSetOutputAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSetOutputAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSetOutputAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionSetOutputAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSetOutputAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSetOutputAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_tx_out(from._internal_tx_out());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_vouti_hmac(from._internal_vouti_hmac());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_out_pk(from._internal_out_pk());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_ecdh_info(from._internal_ecdh_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_rsig_data()->::hw::trezor::messages::monero::MoneroTransactionRsigData::MergeFrom(
          from._internal_rsig_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSetOutputAck::CopyFrom(const MoneroTransactionSetOutputAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSetOutputAck::IsInitialized() const {
  return true;
}

void MoneroTransactionSetOutputAck::InternalSwap(MoneroTransactionSetOutputAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_out_, lhs_arena,
      &other->_impl_.tx_out_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vouti_hmac_, lhs_arena,
      &other->_impl_.vouti_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.out_pk_, lhs_arena,
      &other->_impl_.out_pk_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ecdh_info_, lhs_arena,
      &other->_impl_.ecdh_info_, rhs_arena
  );
  swap(_impl_.rsig_data_, other->_impl_.rsig_data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSetOutputAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[21]);
}

// ===================================================================

class MoneroTransactionAllOutSetRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionAllOutSetRequest>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data(const MoneroTransactionAllOutSetRequest* msg);
  static void set_has_rsig_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionRsigData&
MoneroTransactionAllOutSetRequest::_Internal::rsig_data(const MoneroTransactionAllOutSetRequest* msg) {
  return *msg->_impl_.rsig_data_;
}
MoneroTransactionAllOutSetRequest::MoneroTransactionAllOutSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
}
MoneroTransactionAllOutSetRequest::MoneroTransactionAllOutSetRequest(const MoneroTransactionAllOutSetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionAllOutSetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rsig_data_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rsig_data()) {
    _this->_impl_.rsig_data_ = new ::hw::trezor::messages::monero::MoneroTransactionRsigData(*from._impl_.rsig_data_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
}

inline void MoneroTransactionAllOutSetRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rsig_data_){nullptr}
  };
}

MoneroTransactionAllOutSetRequest::~MoneroTransactionAllOutSetRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionAllOutSetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rsig_data_;
}

void MoneroTransactionAllOutSetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionAllOutSetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.rsig_data_ != nullptr);
    _impl_.rsig_data_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionAllOutSetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rsig_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionAllOutSetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rsig_data(this),
        _Internal::rsig_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  return target;
}

size_t MoneroTransactionAllOutSetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rsig_data_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionAllOutSetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionAllOutSetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionAllOutSetRequest::GetClassData() const { return &_class_data_; }


void MoneroTransactionAllOutSetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionAllOutSetRequest*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionAllOutSetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rsig_data()) {
    _this->_internal_mutable_rsig_data()->::hw::trezor::messages::monero::MoneroTransactionRsigData::MergeFrom(
        from._internal_rsig_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionAllOutSetRequest::CopyFrom(const MoneroTransactionAllOutSetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionAllOutSetRequest::IsInitialized() const {
  return true;
}

void MoneroTransactionAllOutSetRequest::InternalSwap(MoneroTransactionAllOutSetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.rsig_data_, other->_impl_.rsig_data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionAllOutSetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[22]);
}

// ===================================================================

class MoneroTransactionAllOutSetAck_MoneroRingCtSig::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionAllOutSetAck_MoneroRingCtSig>()._impl_._has_bits_);
  static void set_has_txn_fee(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rv_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MoneroTransactionAllOutSetAck_MoneroRingCtSig::MoneroTransactionAllOutSetAck_MoneroRingCtSig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
}
MoneroTransactionAllOutSetAck_MoneroRingCtSig::MoneroTransactionAllOutSetAck_MoneroRingCtSig(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionAllOutSetAck_MoneroRingCtSig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.txn_fee_){}
    , decltype(_impl_.rv_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.txn_fee_, &from._impl_.txn_fee_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rv_type_) -
    reinterpret_cast<char*>(&_impl_.txn_fee_)) + sizeof(_impl_.rv_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
}

inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.txn_fee_){uint64_t{0u}}
    , decltype(_impl_.rv_type_){0u}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionAllOutSetAck_MoneroRingCtSig::~MoneroTransactionAllOutSetAck_MoneroRingCtSig() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void MoneroTransactionAllOutSetAck_MoneroRingCtSig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionAllOutSetAck_MoneroRingCtSig::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.txn_fee_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rv_type_) -
        reinterpret_cast<char*>(&_impl_.txn_fee_)) + sizeof(_impl_.rv_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionAllOutSetAck_MoneroRingCtSig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 txn_fee = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_txn_fee(&has_bits);
          _impl_.txn_fee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rv_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rv_type(&has_bits);
          _impl_.rv_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionAllOutSetAck_MoneroRingCtSig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 txn_fee = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_txn_fee(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  // optional uint32 rv_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rv_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  return target;
}

size_t MoneroTransactionAllOutSetAck_MoneroRingCtSig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message());
    }

    // optional uint64 txn_fee = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_fee());
    }

    // optional uint32 rv_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rv_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionAllOutSetAck_MoneroRingCtSig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionAllOutSetAck_MoneroRingCtSig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionAllOutSetAck_MoneroRingCtSig::GetClassData() const { return &_class_data_; }


void MoneroTransactionAllOutSetAck_MoneroRingCtSig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionAllOutSetAck_MoneroRingCtSig*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionAllOutSetAck_MoneroRingCtSig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.txn_fee_ = from._impl_.txn_fee_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rv_type_ = from._impl_.rv_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionAllOutSetAck_MoneroRingCtSig::CopyFrom(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::IsInitialized() const {
  return true;
}

void MoneroTransactionAllOutSetAck_MoneroRingCtSig::InternalSwap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionAllOutSetAck_MoneroRingCtSig, _impl_.rv_type_)
      + sizeof(MoneroTransactionAllOutSetAck_MoneroRingCtSig::_impl_.rv_type_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionAllOutSetAck_MoneroRingCtSig, _impl_.txn_fee_)>(
          reinterpret_cast<char*>(&_impl_.txn_fee_),
          reinterpret_cast<char*>(&other->_impl_.txn_fee_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionAllOutSetAck_MoneroRingCtSig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[23]);
}

// ===================================================================

class MoneroTransactionAllOutSetAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionAllOutSetAck>()._impl_._has_bits_);
  static void set_has_extra(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_prefix_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& rv(const MoneroTransactionAllOutSetAck* msg);
  static void set_has_rv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_full_message_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig&
MoneroTransactionAllOutSetAck::_Internal::rv(const MoneroTransactionAllOutSetAck* msg) {
  return *msg->_impl_.rv_;
}
MoneroTransactionAllOutSetAck::MoneroTransactionAllOutSetAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
}
MoneroTransactionAllOutSetAck::MoneroTransactionAllOutSetAck(const MoneroTransactionAllOutSetAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionAllOutSetAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extra_){}
    , decltype(_impl_.tx_prefix_hash_){}
    , decltype(_impl_.full_message_hash_){}
    , decltype(_impl_.rv_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.extra_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extra_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra()) {
    _this->_impl_.extra_.Set(from._internal_extra(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_prefix_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_prefix_hash()) {
    _this->_impl_.tx_prefix_hash_.Set(from._internal_tx_prefix_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.full_message_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_message_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_full_message_hash()) {
    _this->_impl_.full_message_hash_.Set(from._internal_full_message_hash(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_rv()) {
    _this->_impl_.rv_ = new ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig(*from._impl_.rv_);
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
}

inline void MoneroTransactionAllOutSetAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extra_){}
    , decltype(_impl_.tx_prefix_hash_){}
    , decltype(_impl_.full_message_hash_){}
    , decltype(_impl_.rv_){nullptr}
  };
  _impl_.extra_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extra_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_prefix_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.full_message_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_message_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionAllOutSetAck::~MoneroTransactionAllOutSetAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionAllOutSetAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extra_.Destroy();
  _impl_.tx_prefix_hash_.Destroy();
  _impl_.full_message_hash_.Destroy();
  if (this != internal_default_instance()) delete _impl_.rv_;
}

void MoneroTransactionAllOutSetAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionAllOutSetAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.extra_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tx_prefix_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.full_message_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rv_ != nullptr);
      _impl_.rv_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionAllOutSetAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes extra = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_extra();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes tx_prefix_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tx_prefix_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes full_message_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_full_message_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionAllOutSetAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes extra = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_extra(), target);
  }

  // optional bytes tx_prefix_hash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_tx_prefix_hash(), target);
  }

  // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rv(this),
        _Internal::rv(this).GetCachedSize(), target, stream);
  }

  // optional bytes full_message_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_full_message_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  return target;
}

size_t MoneroTransactionAllOutSetAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes extra = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_extra());
    }

    // optional bytes tx_prefix_hash = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_tx_prefix_hash());
    }

    // optional bytes full_message_hash = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_full_message_hash());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rv_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionAllOutSetAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionAllOutSetAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionAllOutSetAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionAllOutSetAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionAllOutSetAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionAllOutSetAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_extra(from._internal_extra());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tx_prefix_hash(from._internal_tx_prefix_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_full_message_hash(from._internal_full_message_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rv()->::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig::MergeFrom(
          from._internal_rv());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionAllOutSetAck::CopyFrom(const MoneroTransactionAllOutSetAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionAllOutSetAck::IsInitialized() const {
  return true;
}

void MoneroTransactionAllOutSetAck::InternalSwap(MoneroTransactionAllOutSetAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extra_, lhs_arena,
      &other->_impl_.extra_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_prefix_hash_, lhs_arena,
      &other->_impl_.tx_prefix_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.full_message_hash_, lhs_arena,
      &other->_impl_.full_message_hash_, rhs_arena
  );
  swap(_impl_.rv_, other->_impl_.rv_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionAllOutSetAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[24]);
}

// ===================================================================

class MoneroTransactionSignInputRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSignInputRequest>()._impl_._has_bits_);
  static const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr(const MoneroTransactionSignInputRequest* msg);
  static void set_has_src_entr(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_vini(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vini_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pseudo_out(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pseudo_out_hmac(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pseudo_out_alpha(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_spend_key(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_orig_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry&
MoneroTransactionSignInputRequest::_Internal::src_entr(const MoneroTransactionSignInputRequest* msg) {
  return *msg->_impl_.src_entr_;
}
MoneroTransactionSignInputRequest::MoneroTransactionSignInputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
}
MoneroTransactionSignInputRequest::MoneroTransactionSignInputRequest(const MoneroTransactionSignInputRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSignInputRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vini_){}
    , decltype(_impl_.vini_hmac_){}
    , decltype(_impl_.pseudo_out_){}
    , decltype(_impl_.pseudo_out_hmac_){}
    , decltype(_impl_.pseudo_out_alpha_){}
    , decltype(_impl_.spend_key_){}
    , decltype(_impl_.src_entr_){nullptr}
    , decltype(_impl_.orig_idx_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vini_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vini()) {
    _this->_impl_.vini_.Set(from._internal_vini(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vini_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vini_hmac()) {
    _this->_impl_.vini_hmac_.Set(from._internal_vini_hmac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out()) {
    _this->_impl_.pseudo_out_.Set(from._internal_pseudo_out(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out_hmac()) {
    _this->_impl_.pseudo_out_hmac_.Set(from._internal_pseudo_out_hmac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_alpha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out_alpha()) {
    _this->_impl_.pseudo_out_alpha_.Set(from._internal_pseudo_out_alpha(), 
      _this->GetArenaForAllocation());
  }
  _impl_.spend_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_spend_key()) {
    _this->_impl_.spend_key_.Set(from._internal_spend_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_src_entr()) {
    _this->_impl_.src_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry(*from._impl_.src_entr_);
  }
  _this->_impl_.orig_idx_ = from._impl_.orig_idx_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
}

inline void MoneroTransactionSignInputRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vini_){}
    , decltype(_impl_.vini_hmac_){}
    , decltype(_impl_.pseudo_out_){}
    , decltype(_impl_.pseudo_out_hmac_){}
    , decltype(_impl_.pseudo_out_alpha_){}
    , decltype(_impl_.spend_key_){}
    , decltype(_impl_.src_entr_){nullptr}
    , decltype(_impl_.orig_idx_){0u}
  };
  _impl_.vini_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vini_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_hmac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_alpha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.spend_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSignInputRequest::~MoneroTransactionSignInputRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSignInputRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vini_.Destroy();
  _impl_.vini_hmac_.Destroy();
  _impl_.pseudo_out_.Destroy();
  _impl_.pseudo_out_hmac_.Destroy();
  _impl_.pseudo_out_alpha_.Destroy();
  _impl_.spend_key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.src_entr_;
}

void MoneroTransactionSignInputRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSignInputRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vini_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.vini_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.pseudo_out_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.pseudo_out_hmac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.pseudo_out_alpha_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.spend_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.src_entr_ != nullptr);
      _impl_.src_entr_->Clear();
    }
  }
  _impl_.orig_idx_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSignInputRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_entr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vini = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_vini();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vini_hmac = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_vini_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pseudo_out();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out_hmac = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_pseudo_out_hmac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out_alpha = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_pseudo_out_alpha();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes spend_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_spend_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orig_idx = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_orig_idx(&has_bits);
          _impl_.orig_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSignInputRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::src_entr(this),
        _Internal::src_entr(this).GetCachedSize(), target, stream);
  }

  // optional bytes vini = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_vini(), target);
  }

  // optional bytes vini_hmac = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_vini_hmac(), target);
  }

  // optional bytes pseudo_out = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_pseudo_out(), target);
  }

  // optional bytes pseudo_out_hmac = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_pseudo_out_hmac(), target);
  }

  // optional bytes pseudo_out_alpha = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_pseudo_out_alpha(), target);
  }

  // optional bytes spend_key = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_spend_key(), target);
  }

  // optional uint32 orig_idx = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_orig_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  return target;
}

size_t MoneroTransactionSignInputRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes vini = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vini());
    }

    // optional bytes vini_hmac = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vini_hmac());
    }

    // optional bytes pseudo_out = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out());
    }

    // optional bytes pseudo_out_hmac = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out_hmac());
    }

    // optional bytes pseudo_out_alpha = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out_alpha());
    }

    // optional bytes spend_key = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_spend_key());
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.src_entr_);
    }

    // optional uint32 orig_idx = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orig_idx());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSignInputRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSignInputRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSignInputRequest::GetClassData() const { return &_class_data_; }


void MoneroTransactionSignInputRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSignInputRequest*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSignInputRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vini(from._internal_vini());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_vini_hmac(from._internal_vini_hmac());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_pseudo_out(from._internal_pseudo_out());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_pseudo_out_hmac(from._internal_pseudo_out_hmac());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_pseudo_out_alpha(from._internal_pseudo_out_alpha());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_spend_key(from._internal_spend_key());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_src_entr()->::hw::trezor::messages::monero::MoneroTransactionSourceEntry::MergeFrom(
          from._internal_src_entr());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.orig_idx_ = from._impl_.orig_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSignInputRequest::CopyFrom(const MoneroTransactionSignInputRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSignInputRequest::IsInitialized() const {
  if (_internal_has_src_entr()) {
    if (!_impl_.src_entr_->IsInitialized()) return false;
  }
  return true;
}

void MoneroTransactionSignInputRequest::InternalSwap(MoneroTransactionSignInputRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vini_, lhs_arena,
      &other->_impl_.vini_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vini_hmac_, lhs_arena,
      &other->_impl_.vini_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_, lhs_arena,
      &other->_impl_.pseudo_out_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_hmac_, lhs_arena,
      &other->_impl_.pseudo_out_hmac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_alpha_, lhs_arena,
      &other->_impl_.pseudo_out_alpha_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.spend_key_, lhs_arena,
      &other->_impl_.spend_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroTransactionSignInputRequest, _impl_.orig_idx_)
      + sizeof(MoneroTransactionSignInputRequest::_impl_.orig_idx_)
      - PROTOBUF_FIELD_OFFSET(MoneroTransactionSignInputRequest, _impl_.src_entr_)>(
          reinterpret_cast<char*>(&_impl_.src_entr_),
          reinterpret_cast<char*>(&other->_impl_.src_entr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSignInputRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[25]);
}

// ===================================================================

class MoneroTransactionSignInputAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionSignInputAck>()._impl_._has_bits_);
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pseudo_out(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MoneroTransactionSignInputAck::MoneroTransactionSignInputAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
}
MoneroTransactionSignInputAck::MoneroTransactionSignInputAck(const MoneroTransactionSignInputAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionSignInputAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.pseudo_out_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_out()) {
    _this->_impl_.pseudo_out_.Set(from._internal_pseudo_out(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
}

inline void MoneroTransactionSignInputAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signature_){}
    , decltype(_impl_.pseudo_out_){}
  };
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pseudo_out_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionSignInputAck::~MoneroTransactionSignInputAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionSignInputAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signature_.Destroy();
  _impl_.pseudo_out_.Destroy();
}

void MoneroTransactionSignInputAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionSignInputAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pseudo_out_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionSignInputAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes signature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pseudo_out = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pseudo_out();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionSignInputAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes signature = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signature(), target);
  }

  // optional bytes pseudo_out = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_pseudo_out(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  return target;
}

size_t MoneroTransactionSignInputAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes signature = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional bytes pseudo_out = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pseudo_out());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionSignInputAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionSignInputAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionSignInputAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionSignInputAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionSignInputAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionSignInputAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pseudo_out(from._internal_pseudo_out());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionSignInputAck::CopyFrom(const MoneroTransactionSignInputAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionSignInputAck::IsInitialized() const {
  return true;
}

void MoneroTransactionSignInputAck::InternalSwap(MoneroTransactionSignInputAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pseudo_out_, lhs_arena,
      &other->_impl_.pseudo_out_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionSignInputAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[26]);
}

// ===================================================================

class MoneroTransactionFinalRequest::_Internal {
 public:
};

MoneroTransactionFinalRequest::MoneroTransactionFinalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
}
MoneroTransactionFinalRequest::MoneroTransactionFinalRequest(const MoneroTransactionFinalRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroTransactionFinalRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionFinalRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionFinalRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionFinalRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[27]);
}

// ===================================================================

class MoneroTransactionFinalAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroTransactionFinalAck>()._impl_._has_bits_);
  static void set_has_cout_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rand_mult(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tx_enc_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_opening_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

MoneroTransactionFinalAck::MoneroTransactionFinalAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroTransactionFinalAck)
}
MoneroTransactionFinalAck::MoneroTransactionFinalAck(const MoneroTransactionFinalAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroTransactionFinalAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cout_key_){}
    , decltype(_impl_.salt_){}
    , decltype(_impl_.rand_mult_){}
    , decltype(_impl_.tx_enc_keys_){}
    , decltype(_impl_.opening_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cout_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cout_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cout_key()) {
    _this->_impl_.cout_key_.Set(from._internal_cout_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_salt()) {
    _this->_impl_.salt_.Set(from._internal_salt(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rand_mult_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rand_mult_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rand_mult()) {
    _this->_impl_.rand_mult_.Set(from._internal_rand_mult(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_enc_keys_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_enc_keys()) {
    _this->_impl_.tx_enc_keys_.Set(from._internal_tx_enc_keys(), 
      _this->GetArenaForAllocation());
  }
  _impl_.opening_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.opening_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_opening_key()) {
    _this->_impl_.opening_key_.Set(from._internal_opening_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroTransactionFinalAck)
}

inline void MoneroTransactionFinalAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cout_key_){}
    , decltype(_impl_.salt_){}
    , decltype(_impl_.rand_mult_){}
    , decltype(_impl_.tx_enc_keys_){}
    , decltype(_impl_.opening_key_){}
  };
  _impl_.cout_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cout_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rand_mult_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rand_mult_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_enc_keys_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.opening_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.opening_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroTransactionFinalAck::~MoneroTransactionFinalAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroTransactionFinalAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cout_key_.Destroy();
  _impl_.salt_.Destroy();
  _impl_.rand_mult_.Destroy();
  _impl_.tx_enc_keys_.Destroy();
  _impl_.opening_key_.Destroy();
}

void MoneroTransactionFinalAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroTransactionFinalAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.cout_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.salt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.rand_mult_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.tx_enc_keys_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.opening_key_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroTransactionFinalAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes cout_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cout_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes salt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes rand_mult = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rand_mult();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes tx_enc_keys = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_tx_enc_keys();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes opening_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_opening_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroTransactionFinalAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes cout_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_cout_key(), target);
  }

  // optional bytes salt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_salt(), target);
  }

  // optional bytes rand_mult = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_rand_mult(), target);
  }

  // optional bytes tx_enc_keys = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_tx_enc_keys(), target);
  }

  // optional bytes opening_key = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_opening_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  return target;
}

size_t MoneroTransactionFinalAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes cout_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cout_key());
    }

    // optional bytes salt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_salt());
    }

    // optional bytes rand_mult = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_rand_mult());
    }

    // optional bytes tx_enc_keys = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_tx_enc_keys());
    }

    // optional bytes opening_key = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_opening_key());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroTransactionFinalAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroTransactionFinalAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroTransactionFinalAck::GetClassData() const { return &_class_data_; }


void MoneroTransactionFinalAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroTransactionFinalAck*>(&to_msg);
  auto& from = static_cast<const MoneroTransactionFinalAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cout_key(from._internal_cout_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_salt(from._internal_salt());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_rand_mult(from._internal_rand_mult());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_tx_enc_keys(from._internal_tx_enc_keys());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_opening_key(from._internal_opening_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroTransactionFinalAck::CopyFrom(const MoneroTransactionFinalAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroTransactionFinalAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroTransactionFinalAck::IsInitialized() const {
  return true;
}

void MoneroTransactionFinalAck::InternalSwap(MoneroTransactionFinalAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cout_key_, lhs_arena,
      &other->_impl_.cout_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.salt_, lhs_arena,
      &other->_impl_.salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rand_mult_, lhs_arena,
      &other->_impl_.rand_mult_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_enc_keys_, lhs_arena,
      &other->_impl_.tx_enc_keys_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.opening_key_, lhs_arena,
      &other->_impl_.opening_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroTransactionFinalAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[28]);
}

// ===================================================================

class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>()._impl_._has_bits_);
  static void set_has_account(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
}
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minor_indices_){from._impl_.minor_indices_}
    , decltype(_impl_.account_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.account_ = from._impl_.account_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
}

inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minor_indices_){arena}
    , decltype(_impl_.account_){0u}
  };
}

MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::~MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.minor_indices_.~RepeatedField();
}

void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.minor_indices_.Clear();
  _impl_.account_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 account = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_account(&has_bits);
          _impl_.account_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 minor_indices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_minor_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_minor_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 account = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_account(), target);
  }

  // repeated uint32 minor_indices = 2;
  for (int i = 0, n = this->_internal_minor_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_minor_indices(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  return target;
}

size_t MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  size_t total_size = 0;

  // required uint32 account = 1;
  if (_internal_has_account()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_account());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 minor_indices = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.minor_indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_minor_indices_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::GetClassData() const { return &_class_data_; }


void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.minor_indices_.MergeFrom(from._impl_.minor_indices_);
  if (from._internal_has_account()) {
    _this->_internal_set_account(from._internal_account());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::CopyFrom(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::InternalSwap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.minor_indices_.InternalSwap(&other->_impl_.minor_indices_);
  swap(_impl_.account_, other->_impl_.account_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[29]);
}

// ===================================================================

class MoneroKeyImageExportInitRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroKeyImageExportInitRequest>()._impl_._has_bits_);
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

MoneroKeyImageExportInitRequest::MoneroKeyImageExportInitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
}
MoneroKeyImageExportInitRequest::MoneroKeyImageExportInitRequest(const MoneroKeyImageExportInitRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageExportInitRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.subs_){from._impl_.subs_}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.num_){}
    , decltype(_impl_.network_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.num_, &from._impl_.num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.network_type_) -
    reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.network_type_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
}

inline void MoneroKeyImageExportInitRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.subs_){arena}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.num_){uint64_t{0u}}
    , decltype(_impl_.network_type_){0}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroKeyImageExportInitRequest::~MoneroKeyImageExportInitRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageExportInitRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
  _impl_.subs_.~RepeatedPtrField();
  _impl_.hash_.Destroy();
}

void MoneroKeyImageExportInitRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageExportInitRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  _impl_.subs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.network_type_) -
        reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.network_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageExportInitRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 address_n = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 4 [default = MAINNET];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(val))) {
            _internal_set_network_type(static_cast<::hw::trezor::messages::monero::MoneroNetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageExportInitRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 num = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_num(), target);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  // repeated uint32 address_n = 3;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_address_n(i), target);
  }

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 4 [default = MAINNET];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_network_type(), target);
  }

  // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subs_size()); i < n; i++) {
    const auto& repfield = this->_internal_subs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  return target;
}

size_t MoneroKeyImageExportInitRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  size_t total_size = 0;

  if (_internal_has_hash()) {
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  if (_internal_has_num()) {
    // required uint64 num = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num());
  }

  return total_size;
}
size_t MoneroKeyImageExportInitRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());

    // required uint64 num = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_num());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
  total_size += 1UL * this->_internal_subs_size();
  for (const auto& msg : this->_impl_.subs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 4 [default = MAINNET];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_network_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageExportInitRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageExportInitRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageExportInitRequest::GetClassData() const { return &_class_data_; }


void MoneroKeyImageExportInitRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageExportInitRequest*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageExportInitRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  _this->_impl_.subs_.MergeFrom(from._impl_.subs_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.network_type_ = from._impl_.network_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageExportInitRequest::CopyFrom(const MoneroKeyImageExportInitRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageExportInitRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.subs_))
    return false;
  return true;
}

void MoneroKeyImageExportInitRequest::InternalSwap(MoneroKeyImageExportInitRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  _impl_.subs_.InternalSwap(&other->_impl_.subs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroKeyImageExportInitRequest, _impl_.network_type_)
      + sizeof(MoneroKeyImageExportInitRequest::_impl_.network_type_)
      - PROTOBUF_FIELD_OFFSET(MoneroKeyImageExportInitRequest, _impl_.num_)>(
          reinterpret_cast<char*>(&_impl_.num_),
          reinterpret_cast<char*>(&other->_impl_.num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageExportInitRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[30]);
}

// ===================================================================

class MoneroKeyImageExportInitAck::_Internal {
 public:
};

MoneroKeyImageExportInitAck::MoneroKeyImageExportInitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
}
MoneroKeyImageExportInitAck::MoneroKeyImageExportInitAck(const MoneroKeyImageExportInitAck& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroKeyImageExportInitAck* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageExportInitAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageExportInitAck::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageExportInitAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[31]);
}

// ===================================================================

class MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>()._impl_._has_bits_);
  static void set_has_out_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_pub_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_internal_output_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sub_addr_major(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sub_addr_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

MoneroKeyImageSyncStepRequest_MoneroTransferDetails::MoneroKeyImageSyncStepRequest_MoneroTransferDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
}
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::MoneroKeyImageSyncStepRequest_MoneroTransferDetails(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageSyncStepRequest_MoneroTransferDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additional_tx_pub_keys_){from._impl_.additional_tx_pub_keys_}
    , decltype(_impl_.out_key_){}
    , decltype(_impl_.tx_pub_key_){}
    , decltype(_impl_.internal_output_index_){}
    , decltype(_impl_.sub_addr_major_){}
    , decltype(_impl_.sub_addr_minor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.out_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_out_key()) {
    _this->_impl_.out_key_.Set(from._internal_out_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_pub_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_pub_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_pub_key()) {
    _this->_impl_.tx_pub_key_.Set(from._internal_tx_pub_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.internal_output_index_, &from._impl_.internal_output_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sub_addr_minor_) -
    reinterpret_cast<char*>(&_impl_.internal_output_index_)) + sizeof(_impl_.sub_addr_minor_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
}

inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additional_tx_pub_keys_){arena}
    , decltype(_impl_.out_key_){}
    , decltype(_impl_.tx_pub_key_){}
    , decltype(_impl_.internal_output_index_){uint64_t{0u}}
    , decltype(_impl_.sub_addr_major_){0u}
    , decltype(_impl_.sub_addr_minor_){0u}
  };
  _impl_.out_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_pub_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_pub_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroKeyImageSyncStepRequest_MoneroTransferDetails::~MoneroKeyImageSyncStepRequest_MoneroTransferDetails() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_tx_pub_keys_.~RepeatedPtrField();
  _impl_.out_key_.Destroy();
  _impl_.tx_pub_key_.Destroy();
}

void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_tx_pub_keys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.out_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tx_pub_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.internal_output_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sub_addr_minor_) -
        reinterpret_cast<char*>(&_impl_.internal_output_index_)) + sizeof(_impl_.sub_addr_minor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes out_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_out_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes tx_pub_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tx_pub_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes additional_tx_pub_keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_additional_tx_pub_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required uint64 internal_output_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_internal_output_index(&has_bits);
          _impl_.internal_output_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sub_addr_major = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sub_addr_major(&has_bits);
          _impl_.sub_addr_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sub_addr_minor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_sub_addr_minor(&has_bits);
          _impl_.sub_addr_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes out_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_out_key(), target);
  }

  // required bytes tx_pub_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_tx_pub_key(), target);
  }

  // repeated bytes additional_tx_pub_keys = 3;
  for (int i = 0, n = this->_internal_additional_tx_pub_keys_size(); i < n; i++) {
    const auto& s = this->_internal_additional_tx_pub_keys(i);
    target = stream->WriteBytes(3, s, target);
  }

  // required uint64 internal_output_index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_internal_output_index(), target);
  }

  // optional uint32 sub_addr_major = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_sub_addr_major(), target);
  }

  // optional uint32 sub_addr_minor = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_sub_addr_minor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  return target;
}

size_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  size_t total_size = 0;

  if (_internal_has_out_key()) {
    // required bytes out_key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_out_key());
  }

  if (_internal_has_tx_pub_key()) {
    // required bytes tx_pub_key = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_pub_key());
  }

  if (_internal_has_internal_output_index()) {
    // required uint64 internal_output_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_internal_output_index());
  }

  return total_size;
}
size_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes out_key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_out_key());

    // required bytes tx_pub_key = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_pub_key());

    // required uint64 internal_output_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_internal_output_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes additional_tx_pub_keys = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.additional_tx_pub_keys_.size());
  for (int i = 0, n = _impl_.additional_tx_pub_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.additional_tx_pub_keys_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional uint32 sub_addr_major = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sub_addr_major());
    }

    // optional uint32 sub_addr_minor = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sub_addr_minor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageSyncStepRequest_MoneroTransferDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageSyncStepRequest_MoneroTransferDetails::GetClassData() const { return &_class_data_; }


void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageSyncStepRequest_MoneroTransferDetails*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageSyncStepRequest_MoneroTransferDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_tx_pub_keys_.MergeFrom(from._impl_.additional_tx_pub_keys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_out_key(from._internal_out_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tx_pub_key(from._internal_tx_pub_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.internal_output_index_ = from._impl_.internal_output_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sub_addr_major_ = from._impl_.sub_addr_major_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sub_addr_minor_ = from._impl_.sub_addr_minor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::CopyFrom(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::InternalSwap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.additional_tx_pub_keys_.InternalSwap(&other->_impl_.additional_tx_pub_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.out_key_, lhs_arena,
      &other->_impl_.out_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_pub_key_, lhs_arena,
      &other->_impl_.tx_pub_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.sub_addr_minor_)
      + sizeof(MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_impl_.sub_addr_minor_)
      - PROTOBUF_FIELD_OFFSET(MoneroKeyImageSyncStepRequest_MoneroTransferDetails, _impl_.internal_output_index_)>(
          reinterpret_cast<char*>(&_impl_.internal_output_index_),
          reinterpret_cast<char*>(&other->_impl_.internal_output_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageSyncStepRequest_MoneroTransferDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[32]);
}

// ===================================================================

class MoneroKeyImageSyncStepRequest::_Internal {
 public:
};

MoneroKeyImageSyncStepRequest::MoneroKeyImageSyncStepRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
}
MoneroKeyImageSyncStepRequest::MoneroKeyImageSyncStepRequest(const MoneroKeyImageSyncStepRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageSyncStepRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tdis_){from._impl_.tdis_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
}

inline void MoneroKeyImageSyncStepRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tdis_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MoneroKeyImageSyncStepRequest::~MoneroKeyImageSyncStepRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageSyncStepRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tdis_.~RepeatedPtrField();
}

void MoneroKeyImageSyncStepRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageSyncStepRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tdis_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageSyncStepRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tdis(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageSyncStepRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tdis_size()); i < n; i++) {
    const auto& repfield = this->_internal_tdis(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  return target;
}

size_t MoneroKeyImageSyncStepRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
  total_size += 1UL * this->_internal_tdis_size();
  for (const auto& msg : this->_impl_.tdis_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageSyncStepRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageSyncStepRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageSyncStepRequest::GetClassData() const { return &_class_data_; }


void MoneroKeyImageSyncStepRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageSyncStepRequest*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageSyncStepRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tdis_.MergeFrom(from._impl_.tdis_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageSyncStepRequest::CopyFrom(const MoneroKeyImageSyncStepRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageSyncStepRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.tdis_))
    return false;
  return true;
}

void MoneroKeyImageSyncStepRequest::InternalSwap(MoneroKeyImageSyncStepRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tdis_.InternalSwap(&other->_impl_.tdis_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageSyncStepRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[33]);
}

// ===================================================================

class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>()._impl_._has_bits_);
  static void set_has_iv(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
}
MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iv_){}
    , decltype(_impl_.blob_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.iv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_iv()) {
    _this->_impl_.iv_.Set(from._internal_iv(), 
      _this->GetArenaForAllocation());
  }
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_blob()) {
    _this->_impl_.blob_.Set(from._internal_blob(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
}

inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iv_){}
    , decltype(_impl_.blob_){}
  };
  _impl_.iv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.blob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.blob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::~MoneroKeyImageSyncStepAck_MoneroExportedKeyImage() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.iv_.Destroy();
  _impl_.blob_.Destroy();
}

void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.iv_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.blob_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes iv = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_iv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes blob = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_blob();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes iv = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_iv(), target);
  }

  // optional bytes blob = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_blob(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  return target;
}

size_t MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes iv = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_iv());
    }

    // optional bytes blob = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_blob());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::GetClassData() const { return &_class_data_; }


void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_iv(from._internal_iv());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_blob(from._internal_blob());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::CopyFrom(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::IsInitialized() const {
  return true;
}

void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::InternalSwap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.iv_, lhs_arena,
      &other->_impl_.iv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.blob_, lhs_arena,
      &other->_impl_.blob_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[34]);
}

// ===================================================================

class MoneroKeyImageSyncStepAck::_Internal {
 public:
};

MoneroKeyImageSyncStepAck::MoneroKeyImageSyncStepAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
}
MoneroKeyImageSyncStepAck::MoneroKeyImageSyncStepAck(const MoneroKeyImageSyncStepAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageSyncStepAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.kis_){from._impl_.kis_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
}

inline void MoneroKeyImageSyncStepAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.kis_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MoneroKeyImageSyncStepAck::~MoneroKeyImageSyncStepAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageSyncStepAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.kis_.~RepeatedPtrField();
}

void MoneroKeyImageSyncStepAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageSyncStepAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.kis_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageSyncStepAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kis(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageSyncStepAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_kis_size()); i < n; i++) {
    const auto& repfield = this->_internal_kis(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  return target;
}

size_t MoneroKeyImageSyncStepAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
  total_size += 1UL * this->_internal_kis_size();
  for (const auto& msg : this->_impl_.kis_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageSyncStepAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageSyncStepAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageSyncStepAck::GetClassData() const { return &_class_data_; }


void MoneroKeyImageSyncStepAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageSyncStepAck*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageSyncStepAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.kis_.MergeFrom(from._impl_.kis_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageSyncStepAck::CopyFrom(const MoneroKeyImageSyncStepAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageSyncStepAck::IsInitialized() const {
  return true;
}

void MoneroKeyImageSyncStepAck::InternalSwap(MoneroKeyImageSyncStepAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.kis_.InternalSwap(&other->_impl_.kis_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageSyncStepAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[35]);
}

// ===================================================================

class MoneroKeyImageSyncFinalRequest::_Internal {
 public:
};

MoneroKeyImageSyncFinalRequest::MoneroKeyImageSyncFinalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
}
MoneroKeyImageSyncFinalRequest::MoneroKeyImageSyncFinalRequest(const MoneroKeyImageSyncFinalRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroKeyImageSyncFinalRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageSyncFinalRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageSyncFinalRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageSyncFinalRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[36]);
}

// ===================================================================

class MoneroKeyImageSyncFinalAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroKeyImageSyncFinalAck>()._impl_._has_bits_);
  static void set_has_enc_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MoneroKeyImageSyncFinalAck::MoneroKeyImageSyncFinalAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
}
MoneroKeyImageSyncFinalAck::MoneroKeyImageSyncFinalAck(const MoneroKeyImageSyncFinalAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroKeyImageSyncFinalAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enc_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.enc_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enc_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_enc_key()) {
    _this->_impl_.enc_key_.Set(from._internal_enc_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
}

inline void MoneroKeyImageSyncFinalAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enc_key_){}
  };
  _impl_.enc_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.enc_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroKeyImageSyncFinalAck::~MoneroKeyImageSyncFinalAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroKeyImageSyncFinalAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enc_key_.Destroy();
}

void MoneroKeyImageSyncFinalAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroKeyImageSyncFinalAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.enc_key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroKeyImageSyncFinalAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes enc_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_enc_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroKeyImageSyncFinalAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes enc_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_enc_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  return target;
}

size_t MoneroKeyImageSyncFinalAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes enc_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_enc_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroKeyImageSyncFinalAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroKeyImageSyncFinalAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroKeyImageSyncFinalAck::GetClassData() const { return &_class_data_; }


void MoneroKeyImageSyncFinalAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroKeyImageSyncFinalAck*>(&to_msg);
  auto& from = static_cast<const MoneroKeyImageSyncFinalAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enc_key()) {
    _this->_internal_set_enc_key(from._internal_enc_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroKeyImageSyncFinalAck::CopyFrom(const MoneroKeyImageSyncFinalAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroKeyImageSyncFinalAck::IsInitialized() const {
  return true;
}

void MoneroKeyImageSyncFinalAck::InternalSwap(MoneroKeyImageSyncFinalAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.enc_key_, lhs_arena,
      &other->_impl_.enc_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroKeyImageSyncFinalAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[37]);
}

// ===================================================================

class MoneroGetTxKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroGetTxKeyRequest>()._impl_._has_bits_);
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_salt1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_salt2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tx_enc_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tx_prefix_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_view_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

MoneroGetTxKeyRequest::MoneroGetTxKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
}
MoneroGetTxKeyRequest::MoneroGetTxKeyRequest(const MoneroGetTxKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroGetTxKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.salt1_){}
    , decltype(_impl_.salt2_){}
    , decltype(_impl_.tx_enc_keys_){}
    , decltype(_impl_.tx_prefix_hash_){}
    , decltype(_impl_.view_public_key_){}
    , decltype(_impl_.network_type_){}
    , decltype(_impl_.reason_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.salt1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_salt1()) {
    _this->_impl_.salt1_.Set(from._internal_salt1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.salt2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_salt2()) {
    _this->_impl_.salt2_.Set(from._internal_salt2(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_enc_keys_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_enc_keys()) {
    _this->_impl_.tx_enc_keys_.Set(from._internal_tx_enc_keys(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_prefix_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_prefix_hash()) {
    _this->_impl_.tx_prefix_hash_.Set(from._internal_tx_prefix_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.view_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_public_key()) {
    _this->_impl_.view_public_key_.Set(from._internal_view_public_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.network_type_, &from._impl_.network_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reason_) -
    reinterpret_cast<char*>(&_impl_.network_type_)) + sizeof(_impl_.reason_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
}

inline void MoneroGetTxKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.salt1_){}
    , decltype(_impl_.salt2_){}
    , decltype(_impl_.tx_enc_keys_){}
    , decltype(_impl_.tx_prefix_hash_){}
    , decltype(_impl_.view_public_key_){}
    , decltype(_impl_.network_type_){0}
    , decltype(_impl_.reason_){0u}
  };
  _impl_.salt1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.salt2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_enc_keys_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_prefix_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.view_public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroGetTxKeyRequest::~MoneroGetTxKeyRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroGetTxKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
  _impl_.salt1_.Destroy();
  _impl_.salt2_.Destroy();
  _impl_.tx_enc_keys_.Destroy();
  _impl_.tx_prefix_hash_.Destroy();
  _impl_.view_public_key_.Destroy();
}

void MoneroGetTxKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroGetTxKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.salt1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.salt2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.tx_enc_keys_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.tx_prefix_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.view_public_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.network_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reason_) -
        reinterpret_cast<char*>(&_impl_.network_type_)) + sizeof(_impl_.reason_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroGetTxKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(val))) {
            _internal_set_network_type(static_cast<::hw::trezor::messages::monero::MoneroNetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes salt1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_salt1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes salt2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_salt2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes tx_enc_keys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_tx_enc_keys();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes tx_prefix_hash = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_tx_prefix_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reason = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_reason(&has_bits);
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes view_public_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_view_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroGetTxKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_address_n(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_network_type(), target);
  }

  // required bytes salt1 = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_salt1(), target);
  }

  // required bytes salt2 = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_salt2(), target);
  }

  // required bytes tx_enc_keys = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_tx_enc_keys(), target);
  }

  // required bytes tx_prefix_hash = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_tx_prefix_hash(), target);
  }

  // optional uint32 reason = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_reason(), target);
  }

  // optional bytes view_public_key = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_view_public_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  return target;
}

size_t MoneroGetTxKeyRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  size_t total_size = 0;

  if (_internal_has_salt1()) {
    // required bytes salt1 = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_salt1());
  }

  if (_internal_has_salt2()) {
    // required bytes salt2 = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_salt2());
  }

  if (_internal_has_tx_enc_keys()) {
    // required bytes tx_enc_keys = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_enc_keys());
  }

  if (_internal_has_tx_prefix_hash()) {
    // required bytes tx_prefix_hash = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_prefix_hash());
  }

  return total_size;
}
size_t MoneroGetTxKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes salt1 = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_salt1());

    // required bytes salt2 = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_salt2());

    // required bytes tx_enc_keys = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_enc_keys());

    // required bytes tx_prefix_hash = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_prefix_hash());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000070u) {
    // optional bytes view_public_key = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_view_public_key());
    }

    // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_network_type());
    }

    // optional uint32 reason = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reason());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroGetTxKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroGetTxKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroGetTxKeyRequest::GetClassData() const { return &_class_data_; }


void MoneroGetTxKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroGetTxKeyRequest*>(&to_msg);
  auto& from = static_cast<const MoneroGetTxKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_salt1(from._internal_salt1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_salt2(from._internal_salt2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_tx_enc_keys(from._internal_tx_enc_keys());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_tx_prefix_hash(from._internal_tx_prefix_hash());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_view_public_key(from._internal_view_public_key());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.network_type_ = from._impl_.network_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroGetTxKeyRequest::CopyFrom(const MoneroGetTxKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroGetTxKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MoneroGetTxKeyRequest::InternalSwap(MoneroGetTxKeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.salt1_, lhs_arena,
      &other->_impl_.salt1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.salt2_, lhs_arena,
      &other->_impl_.salt2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_enc_keys_, lhs_arena,
      &other->_impl_.tx_enc_keys_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_prefix_hash_, lhs_arena,
      &other->_impl_.tx_prefix_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.view_public_key_, lhs_arena,
      &other->_impl_.view_public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroGetTxKeyRequest, _impl_.reason_)
      + sizeof(MoneroGetTxKeyRequest::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(MoneroGetTxKeyRequest, _impl_.network_type_)>(
          reinterpret_cast<char*>(&_impl_.network_type_),
          reinterpret_cast<char*>(&other->_impl_.network_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroGetTxKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[38]);
}

// ===================================================================

class MoneroGetTxKeyAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroGetTxKeyAck>()._impl_._has_bits_);
  static void set_has_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tx_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tx_derivations(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MoneroGetTxKeyAck::MoneroGetTxKeyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroGetTxKeyAck)
}
MoneroGetTxKeyAck::MoneroGetTxKeyAck(const MoneroGetTxKeyAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroGetTxKeyAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.salt_){}
    , decltype(_impl_.tx_keys_){}
    , decltype(_impl_.tx_derivations_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_salt()) {
    _this->_impl_.salt_.Set(from._internal_salt(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_keys_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_keys_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_keys()) {
    _this->_impl_.tx_keys_.Set(from._internal_tx_keys(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_derivations_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_derivations_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tx_derivations()) {
    _this->_impl_.tx_derivations_.Set(from._internal_tx_derivations(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroGetTxKeyAck)
}

inline void MoneroGetTxKeyAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.salt_){}
    , decltype(_impl_.tx_keys_){}
    , decltype(_impl_.tx_derivations_){}
  };
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_keys_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_keys_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_derivations_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_derivations_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroGetTxKeyAck::~MoneroGetTxKeyAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroGetTxKeyAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.salt_.Destroy();
  _impl_.tx_keys_.Destroy();
  _impl_.tx_derivations_.Destroy();
}

void MoneroGetTxKeyAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroGetTxKeyAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.salt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.tx_keys_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.tx_derivations_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroGetTxKeyAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes salt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes tx_keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tx_keys();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes tx_derivations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_tx_derivations();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroGetTxKeyAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes salt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_salt(), target);
  }

  // optional bytes tx_keys = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_tx_keys(), target);
  }

  // optional bytes tx_derivations = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_tx_derivations(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  return target;
}

size_t MoneroGetTxKeyAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes salt = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_salt());
    }

    // optional bytes tx_keys = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_tx_keys());
    }

    // optional bytes tx_derivations = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_tx_derivations());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroGetTxKeyAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroGetTxKeyAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroGetTxKeyAck::GetClassData() const { return &_class_data_; }


void MoneroGetTxKeyAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroGetTxKeyAck*>(&to_msg);
  auto& from = static_cast<const MoneroGetTxKeyAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_salt(from._internal_salt());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_tx_keys(from._internal_tx_keys());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_tx_derivations(from._internal_tx_derivations());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroGetTxKeyAck::CopyFrom(const MoneroGetTxKeyAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroGetTxKeyAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroGetTxKeyAck::IsInitialized() const {
  return true;
}

void MoneroGetTxKeyAck::InternalSwap(MoneroGetTxKeyAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.salt_, lhs_arena,
      &other->_impl_.salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_keys_, lhs_arena,
      &other->_impl_.tx_keys_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_derivations_, lhs_arena,
      &other->_impl_.tx_derivations_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroGetTxKeyAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[39]);
}

// ===================================================================

class MoneroLiveRefreshStartRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroLiveRefreshStartRequest>()._impl_._has_bits_);
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MoneroLiveRefreshStartRequest::MoneroLiveRefreshStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
}
MoneroLiveRefreshStartRequest::MoneroLiveRefreshStartRequest(const MoneroLiveRefreshStartRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroLiveRefreshStartRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.network_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.network_type_ = from._impl_.network_type_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
}

inline void MoneroLiveRefreshStartRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.network_type_){0}
  };
}

MoneroLiveRefreshStartRequest::~MoneroLiveRefreshStartRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroLiveRefreshStartRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
}

void MoneroLiveRefreshStartRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroLiveRefreshStartRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  _impl_.network_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroLiveRefreshStartRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(val))) {
            _internal_set_network_type(static_cast<::hw::trezor::messages::monero::MoneroNetworkType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroLiveRefreshStartRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_address_n(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_network_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  return target;
}

size_t MoneroLiveRefreshStartRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_network_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroLiveRefreshStartRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroLiveRefreshStartRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroLiveRefreshStartRequest::GetClassData() const { return &_class_data_; }


void MoneroLiveRefreshStartRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroLiveRefreshStartRequest*>(&to_msg);
  auto& from = static_cast<const MoneroLiveRefreshStartRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  if (from._internal_has_network_type()) {
    _this->_internal_set_network_type(from._internal_network_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroLiveRefreshStartRequest::CopyFrom(const MoneroLiveRefreshStartRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroLiveRefreshStartRequest::IsInitialized() const {
  return true;
}

void MoneroLiveRefreshStartRequest::InternalSwap(MoneroLiveRefreshStartRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  swap(_impl_.network_type_, other->_impl_.network_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroLiveRefreshStartRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[40]);
}

// ===================================================================

class MoneroLiveRefreshStartAck::_Internal {
 public:
};

MoneroLiveRefreshStartAck::MoneroLiveRefreshStartAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStartAck)
}
MoneroLiveRefreshStartAck::MoneroLiveRefreshStartAck(const MoneroLiveRefreshStartAck& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroLiveRefreshStartAck* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStartAck)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroLiveRefreshStartAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroLiveRefreshStartAck::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroLiveRefreshStartAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[41]);
}

// ===================================================================

class MoneroLiveRefreshStepRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroLiveRefreshStepRequest>()._impl_._has_bits_);
  static void set_has_out_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_recv_deriv(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_real_out_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sub_addr_major(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sub_addr_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

MoneroLiveRefreshStepRequest::MoneroLiveRefreshStepRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
}
MoneroLiveRefreshStepRequest::MoneroLiveRefreshStepRequest(const MoneroLiveRefreshStepRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroLiveRefreshStepRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.out_key_){}
    , decltype(_impl_.recv_deriv_){}
    , decltype(_impl_.real_out_idx_){}
    , decltype(_impl_.sub_addr_major_){}
    , decltype(_impl_.sub_addr_minor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.out_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_out_key()) {
    _this->_impl_.out_key_.Set(from._internal_out_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.recv_deriv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recv_deriv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_recv_deriv()) {
    _this->_impl_.recv_deriv_.Set(from._internal_recv_deriv(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.real_out_idx_, &from._impl_.real_out_idx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sub_addr_minor_) -
    reinterpret_cast<char*>(&_impl_.real_out_idx_)) + sizeof(_impl_.sub_addr_minor_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
}

inline void MoneroLiveRefreshStepRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.out_key_){}
    , decltype(_impl_.recv_deriv_){}
    , decltype(_impl_.real_out_idx_){uint64_t{0u}}
    , decltype(_impl_.sub_addr_major_){0u}
    , decltype(_impl_.sub_addr_minor_){0u}
  };
  _impl_.out_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recv_deriv_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recv_deriv_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroLiveRefreshStepRequest::~MoneroLiveRefreshStepRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroLiveRefreshStepRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.out_key_.Destroy();
  _impl_.recv_deriv_.Destroy();
}

void MoneroLiveRefreshStepRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroLiveRefreshStepRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.out_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.recv_deriv_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.real_out_idx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sub_addr_minor_) -
        reinterpret_cast<char*>(&_impl_.real_out_idx_)) + sizeof(_impl_.sub_addr_minor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroLiveRefreshStepRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes out_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_out_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes recv_deriv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_recv_deriv();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 real_out_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_real_out_idx(&has_bits);
          _impl_.real_out_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sub_addr_major = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sub_addr_major(&has_bits);
          _impl_.sub_addr_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sub_addr_minor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sub_addr_minor(&has_bits);
          _impl_.sub_addr_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroLiveRefreshStepRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes out_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_out_key(), target);
  }

  // required bytes recv_deriv = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_recv_deriv(), target);
  }

  // required uint64 real_out_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_real_out_idx(), target);
  }

  // required uint32 sub_addr_major = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sub_addr_major(), target);
  }

  // required uint32 sub_addr_minor = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_sub_addr_minor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  return target;
}

size_t MoneroLiveRefreshStepRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  size_t total_size = 0;

  if (_internal_has_out_key()) {
    // required bytes out_key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_out_key());
  }

  if (_internal_has_recv_deriv()) {
    // required bytes recv_deriv = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recv_deriv());
  }

  if (_internal_has_real_out_idx()) {
    // required uint64 real_out_idx = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_real_out_idx());
  }

  if (_internal_has_sub_addr_major()) {
    // required uint32 sub_addr_major = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sub_addr_major());
  }

  if (_internal_has_sub_addr_minor()) {
    // required uint32 sub_addr_minor = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sub_addr_minor());
  }

  return total_size;
}
size_t MoneroLiveRefreshStepRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required bytes out_key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_out_key());

    // required bytes recv_deriv = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_recv_deriv());

    // required uint64 real_out_idx = 3;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_real_out_idx());

    // required uint32 sub_addr_major = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sub_addr_major());

    // required uint32 sub_addr_minor = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sub_addr_minor());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroLiveRefreshStepRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroLiveRefreshStepRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroLiveRefreshStepRequest::GetClassData() const { return &_class_data_; }


void MoneroLiveRefreshStepRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroLiveRefreshStepRequest*>(&to_msg);
  auto& from = static_cast<const MoneroLiveRefreshStepRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_out_key(from._internal_out_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_recv_deriv(from._internal_recv_deriv());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.real_out_idx_ = from._impl_.real_out_idx_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sub_addr_major_ = from._impl_.sub_addr_major_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sub_addr_minor_ = from._impl_.sub_addr_minor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroLiveRefreshStepRequest::CopyFrom(const MoneroLiveRefreshStepRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroLiveRefreshStepRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MoneroLiveRefreshStepRequest::InternalSwap(MoneroLiveRefreshStepRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.out_key_, lhs_arena,
      &other->_impl_.out_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.recv_deriv_, lhs_arena,
      &other->_impl_.recv_deriv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoneroLiveRefreshStepRequest, _impl_.sub_addr_minor_)
      + sizeof(MoneroLiveRefreshStepRequest::_impl_.sub_addr_minor_)
      - PROTOBUF_FIELD_OFFSET(MoneroLiveRefreshStepRequest, _impl_.real_out_idx_)>(
          reinterpret_cast<char*>(&_impl_.real_out_idx_),
          reinterpret_cast<char*>(&other->_impl_.real_out_idx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroLiveRefreshStepRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[42]);
}

// ===================================================================

class MoneroLiveRefreshStepAck::_Internal {
 public:
  using HasBits = decltype(std::declval<MoneroLiveRefreshStepAck>()._impl_._has_bits_);
  static void set_has_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MoneroLiveRefreshStepAck::MoneroLiveRefreshStepAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
}
MoneroLiveRefreshStepAck::MoneroLiveRefreshStepAck(const MoneroLiveRefreshStepAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoneroLiveRefreshStepAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.salt_){}
    , decltype(_impl_.key_image_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_salt()) {
    _this->_impl_.salt_.Set(from._internal_salt(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key_image()) {
    _this->_impl_.key_image_.Set(from._internal_key_image(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
}

inline void MoneroLiveRefreshStepAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.salt_){}
    , decltype(_impl_.key_image_){}
  };
  _impl_.salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_image_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_image_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoneroLiveRefreshStepAck::~MoneroLiveRefreshStepAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoneroLiveRefreshStepAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.salt_.Destroy();
  _impl_.key_image_.Destroy();
}

void MoneroLiveRefreshStepAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoneroLiveRefreshStepAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.salt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.key_image_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoneroLiveRefreshStepAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes salt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes key_image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key_image();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoneroLiveRefreshStepAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes salt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_salt(), target);
  }

  // optional bytes key_image = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key_image(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  return target;
}

size_t MoneroLiveRefreshStepAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes salt = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_salt());
    }

    // optional bytes key_image = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key_image());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroLiveRefreshStepAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoneroLiveRefreshStepAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroLiveRefreshStepAck::GetClassData() const { return &_class_data_; }


void MoneroLiveRefreshStepAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoneroLiveRefreshStepAck*>(&to_msg);
  auto& from = static_cast<const MoneroLiveRefreshStepAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_salt(from._internal_salt());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_key_image(from._internal_key_image());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoneroLiveRefreshStepAck::CopyFrom(const MoneroLiveRefreshStepAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoneroLiveRefreshStepAck::IsInitialized() const {
  return true;
}

void MoneroLiveRefreshStepAck::InternalSwap(MoneroLiveRefreshStepAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.salt_, lhs_arena,
      &other->_impl_.salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_image_, lhs_arena,
      &other->_impl_.key_image_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata MoneroLiveRefreshStepAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[43]);
}

// ===================================================================

class MoneroLiveRefreshFinalRequest::_Internal {
 public:
};

MoneroLiveRefreshFinalRequest::MoneroLiveRefreshFinalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest)
}
MoneroLiveRefreshFinalRequest::MoneroLiveRefreshFinalRequest(const MoneroLiveRefreshFinalRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroLiveRefreshFinalRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroLiveRefreshFinalRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroLiveRefreshFinalRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroLiveRefreshFinalRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[44]);
}

// ===================================================================

class MoneroLiveRefreshFinalAck::_Internal {
 public:
};

MoneroLiveRefreshFinalAck::MoneroLiveRefreshFinalAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck)
}
MoneroLiveRefreshFinalAck::MoneroLiveRefreshFinalAck(const MoneroLiveRefreshFinalAck& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  MoneroLiveRefreshFinalAck* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoneroLiveRefreshFinalAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoneroLiveRefreshFinalAck::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata MoneroLiveRefreshFinalAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[45]);
}

// ===================================================================

class DebugMoneroDiagRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<DebugMoneroDiagRequest>()._impl_._has_bits_);
  static void set_has_ins(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_p1(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_p2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_data1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DebugMoneroDiagRequest::DebugMoneroDiagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.DebugMoneroDiagRequest)
}
DebugMoneroDiagRequest::DebugMoneroDiagRequest(const DebugMoneroDiagRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DebugMoneroDiagRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pd_){from._impl_.pd_}
    , decltype(_impl_.data1_){}
    , decltype(_impl_.data2_){}
    , decltype(_impl_.ins_){}
    , decltype(_impl_.p1_){}
    , decltype(_impl_.p2_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data1()) {
    _this->_impl_.data1_.Set(from._internal_data1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data2()) {
    _this->_impl_.data2_.Set(from._internal_data2(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ins_, &from._impl_.ins_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.p2_) -
    reinterpret_cast<char*>(&_impl_.ins_)) + sizeof(_impl_.p2_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.DebugMoneroDiagRequest)
}

inline void DebugMoneroDiagRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pd_){arena}
    , decltype(_impl_.data1_){}
    , decltype(_impl_.data2_){}
    , decltype(_impl_.ins_){uint64_t{0u}}
    , decltype(_impl_.p1_){uint64_t{0u}}
    , decltype(_impl_.p2_){uint64_t{0u}}
  };
  _impl_.data1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DebugMoneroDiagRequest::~DebugMoneroDiagRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DebugMoneroDiagRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pd_.~RepeatedField();
  _impl_.data1_.Destroy();
  _impl_.data2_.Destroy();
}

void DebugMoneroDiagRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DebugMoneroDiagRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pd_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.data2_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.ins_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.p2_) -
        reinterpret_cast<char*>(&_impl_.ins_)) + sizeof(_impl_.p2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DebugMoneroDiagRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ins(&has_bits);
          _impl_.ins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 p1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_p1(&has_bits);
          _impl_.p1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 p2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_p2(&has_bits);
          _impl_.p2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 pd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_pd(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_pd(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_data2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DebugMoneroDiagRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ins = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ins(), target);
  }

  // optional uint64 p1 = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_p1(), target);
  }

  // optional uint64 p2 = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_p2(), target);
  }

  // repeated uint64 pd = 4;
  for (int i = 0, n = this->_internal_pd_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pd(i), target);
  }

  // optional bytes data1 = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data1(), target);
  }

  // optional bytes data2 = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_data2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  return target;
}

size_t DebugMoneroDiagRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 pd = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.pd_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_pd_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes data1 = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data1());
    }

    // optional bytes data2 = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data2());
    }

    // optional uint64 ins = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ins());
    }

    // optional uint64 p1 = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_p1());
    }

    // optional uint64 p2 = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_p2());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DebugMoneroDiagRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DebugMoneroDiagRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DebugMoneroDiagRequest::GetClassData() const { return &_class_data_; }


void DebugMoneroDiagRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DebugMoneroDiagRequest*>(&to_msg);
  auto& from = static_cast<const DebugMoneroDiagRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pd_.MergeFrom(from._impl_.pd_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data1(from._internal_data1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_data2(from._internal_data2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ins_ = from._impl_.ins_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.p1_ = from._impl_.p1_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.p2_ = from._impl_.p2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DebugMoneroDiagRequest::CopyFrom(const DebugMoneroDiagRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.DebugMoneroDiagRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugMoneroDiagRequest::IsInitialized() const {
  return true;
}

void DebugMoneroDiagRequest::InternalSwap(DebugMoneroDiagRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pd_.InternalSwap(&other->_impl_.pd_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data1_, lhs_arena,
      &other->_impl_.data1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data2_, lhs_arena,
      &other->_impl_.data2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DebugMoneroDiagRequest, _impl_.p2_)
      + sizeof(DebugMoneroDiagRequest::_impl_.p2_)
      - PROTOBUF_FIELD_OFFSET(DebugMoneroDiagRequest, _impl_.ins_)>(
          reinterpret_cast<char*>(&_impl_.ins_),
          reinterpret_cast<char*>(&other->_impl_.ins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DebugMoneroDiagRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[46]);
}

// ===================================================================

class DebugMoneroDiagAck::_Internal {
 public:
  using HasBits = decltype(std::declval<DebugMoneroDiagAck>()._impl_._has_bits_);
  static void set_has_ins(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_p1(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_p2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_data1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DebugMoneroDiagAck::DebugMoneroDiagAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.monero.DebugMoneroDiagAck)
}
DebugMoneroDiagAck::DebugMoneroDiagAck(const DebugMoneroDiagAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DebugMoneroDiagAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pd_){from._impl_.pd_}
    , decltype(_impl_.data1_){}
    , decltype(_impl_.data2_){}
    , decltype(_impl_.ins_){}
    , decltype(_impl_.p1_){}
    , decltype(_impl_.p2_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data1()) {
    _this->_impl_.data1_.Set(from._internal_data1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data2()) {
    _this->_impl_.data2_.Set(from._internal_data2(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ins_, &from._impl_.ins_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.p2_) -
    reinterpret_cast<char*>(&_impl_.ins_)) + sizeof(_impl_.p2_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.monero.DebugMoneroDiagAck)
}

inline void DebugMoneroDiagAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pd_){arena}
    , decltype(_impl_.data1_){}
    , decltype(_impl_.data2_){}
    , decltype(_impl_.ins_){uint64_t{0u}}
    , decltype(_impl_.p1_){uint64_t{0u}}
    , decltype(_impl_.p2_){uint64_t{0u}}
  };
  _impl_.data1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DebugMoneroDiagAck::~DebugMoneroDiagAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.monero.DebugMoneroDiagAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DebugMoneroDiagAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pd_.~RepeatedField();
  _impl_.data1_.Destroy();
  _impl_.data2_.Destroy();
}

void DebugMoneroDiagAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DebugMoneroDiagAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.monero.DebugMoneroDiagAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pd_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.data1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.data2_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.ins_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.p2_) -
        reinterpret_cast<char*>(&_impl_.ins_)) + sizeof(_impl_.p2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DebugMoneroDiagAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ins(&has_bits);
          _impl_.ins_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 p1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_p1(&has_bits);
          _impl_.p1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 p2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_p2(&has_bits);
          _impl_.p2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 pd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_pd(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_pd(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_data1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_data2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DebugMoneroDiagAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.monero.DebugMoneroDiagAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ins = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ins(), target);
  }

  // optional uint64 p1 = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_p1(), target);
  }

  // optional uint64 p2 = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_p2(), target);
  }

  // repeated uint64 pd = 4;
  for (int i = 0, n = this->_internal_pd_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pd(i), target);
  }

  // optional bytes data1 = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data1(), target);
  }

  // optional bytes data2 = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_data2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.monero.DebugMoneroDiagAck)
  return target;
}

size_t DebugMoneroDiagAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.monero.DebugMoneroDiagAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 pd = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.pd_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_pd_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes data1 = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data1());
    }

    // optional bytes data2 = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data2());
    }

    // optional uint64 ins = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ins());
    }

    // optional uint64 p1 = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_p1());
    }

    // optional uint64 p2 = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_p2());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DebugMoneroDiagAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DebugMoneroDiagAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DebugMoneroDiagAck::GetClassData() const { return &_class_data_; }


void DebugMoneroDiagAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DebugMoneroDiagAck*>(&to_msg);
  auto& from = static_cast<const DebugMoneroDiagAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.monero.DebugMoneroDiagAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pd_.MergeFrom(from._impl_.pd_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data1(from._internal_data1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_data2(from._internal_data2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ins_ = from._impl_.ins_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.p1_ = from._impl_.p1_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.p2_ = from._impl_.p2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DebugMoneroDiagAck::CopyFrom(const DebugMoneroDiagAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.monero.DebugMoneroDiagAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugMoneroDiagAck::IsInitialized() const {
  return true;
}

void DebugMoneroDiagAck::InternalSwap(DebugMoneroDiagAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pd_.InternalSwap(&other->_impl_.pd_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data1_, lhs_arena,
      &other->_impl_.data1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data2_, lhs_arena,
      &other->_impl_.data2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DebugMoneroDiagAck, _impl_.p2_)
      + sizeof(DebugMoneroDiagAck::_impl_.p2_)
      - PROTOBUF_FIELD_OFFSET(DebugMoneroDiagAck, _impl_.ins_)>(
          reinterpret_cast<char*>(&_impl_.ins_),
          reinterpret_cast<char*>(&other->_impl_.ins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DebugMoneroDiagAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmonero_2eproto_getter, &descriptor_table_messages_2dmonero_2eproto_once,
      file_level_metadata_messages_2dmonero_2eproto[47]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSourceEntry*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionRsigData*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionRsigData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionRsigData >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroGetAddress*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroGetAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroGetAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroAddress*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroGetWatchKey*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroGetWatchKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroGetWatchKey >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroWatchKey*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroWatchKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroWatchKey >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionInitRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionInitRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionInitRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionInitAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionInitAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionInitAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSetInputAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSetInputAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSetInputAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionInputViniAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionInputViniAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionInputViniAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSetOutputAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSetOutputAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSetOutputAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionSignInputAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionSignInputAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionSignInputAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionFinalRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionFinalRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionFinalRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroTransactionFinalAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroTransactionFinalAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroTransactionFinalAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageExportInitAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageExportInitAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageExportInitAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroGetTxKeyRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroGetTxKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroGetTxKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroGetTxKeyAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroGetTxKeyAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroGetTxKeyAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroLiveRefreshStartAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroLiveRefreshStartAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroLiveRefreshStartAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroLiveRefreshStepAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroLiveRefreshStepAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroLiveRefreshStepAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::DebugMoneroDiagRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::DebugMoneroDiagRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::DebugMoneroDiagRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::monero::DebugMoneroDiagAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::monero::DebugMoneroDiagAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::monero::DebugMoneroDiagAck >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
