// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-management.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2dmanagement_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2dmanagement_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dmanagement_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dmanagement_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2dmanagement_2eproto;
namespace hw {
namespace trezor {
namespace messages {
namespace management {
class ApplyFlags;
struct ApplyFlagsDefaultTypeInternal;
extern ApplyFlagsDefaultTypeInternal _ApplyFlags_default_instance_;
class ApplySettings;
struct ApplySettingsDefaultTypeInternal;
extern ApplySettingsDefaultTypeInternal _ApplySettings_default_instance_;
class BackupDevice;
struct BackupDeviceDefaultTypeInternal;
extern BackupDeviceDefaultTypeInternal _BackupDevice_default_instance_;
class Cancel;
struct CancelDefaultTypeInternal;
extern CancelDefaultTypeInternal _Cancel_default_instance_;
class CancelAuthorization;
struct CancelAuthorizationDefaultTypeInternal;
extern CancelAuthorizationDefaultTypeInternal _CancelAuthorization_default_instance_;
class ChangePin;
struct ChangePinDefaultTypeInternal;
extern ChangePinDefaultTypeInternal _ChangePin_default_instance_;
class ChangeWipeCode;
struct ChangeWipeCodeDefaultTypeInternal;
extern ChangeWipeCodeDefaultTypeInternal _ChangeWipeCode_default_instance_;
class DoPreauthorized;
struct DoPreauthorizedDefaultTypeInternal;
extern DoPreauthorizedDefaultTypeInternal _DoPreauthorized_default_instance_;
class EndSession;
struct EndSessionDefaultTypeInternal;
extern EndSessionDefaultTypeInternal _EndSession_default_instance_;
class Entropy;
struct EntropyDefaultTypeInternal;
extern EntropyDefaultTypeInternal _Entropy_default_instance_;
class EntropyAck;
struct EntropyAckDefaultTypeInternal;
extern EntropyAckDefaultTypeInternal _EntropyAck_default_instance_;
class EntropyRequest;
struct EntropyRequestDefaultTypeInternal;
extern EntropyRequestDefaultTypeInternal _EntropyRequest_default_instance_;
class Features;
struct FeaturesDefaultTypeInternal;
extern FeaturesDefaultTypeInternal _Features_default_instance_;
class FirmwareHash;
struct FirmwareHashDefaultTypeInternal;
extern FirmwareHashDefaultTypeInternal _FirmwareHash_default_instance_;
class GetEntropy;
struct GetEntropyDefaultTypeInternal;
extern GetEntropyDefaultTypeInternal _GetEntropy_default_instance_;
class GetFeatures;
struct GetFeaturesDefaultTypeInternal;
extern GetFeaturesDefaultTypeInternal _GetFeatures_default_instance_;
class GetFirmwareHash;
struct GetFirmwareHashDefaultTypeInternal;
extern GetFirmwareHashDefaultTypeInternal _GetFirmwareHash_default_instance_;
class GetNextU2FCounter;
struct GetNextU2FCounterDefaultTypeInternal;
extern GetNextU2FCounterDefaultTypeInternal _GetNextU2FCounter_default_instance_;
class GetNonce;
struct GetNonceDefaultTypeInternal;
extern GetNonceDefaultTypeInternal _GetNonce_default_instance_;
class Initialize;
struct InitializeDefaultTypeInternal;
extern InitializeDefaultTypeInternal _Initialize_default_instance_;
class LoadDevice;
struct LoadDeviceDefaultTypeInternal;
extern LoadDeviceDefaultTypeInternal _LoadDevice_default_instance_;
class LockDevice;
struct LockDeviceDefaultTypeInternal;
extern LockDeviceDefaultTypeInternal _LockDevice_default_instance_;
class NextU2FCounter;
struct NextU2FCounterDefaultTypeInternal;
extern NextU2FCounterDefaultTypeInternal _NextU2FCounter_default_instance_;
class Nonce;
struct NonceDefaultTypeInternal;
extern NonceDefaultTypeInternal _Nonce_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PreauthorizedRequest;
struct PreauthorizedRequestDefaultTypeInternal;
extern PreauthorizedRequestDefaultTypeInternal _PreauthorizedRequest_default_instance_;
class RebootToBootloader;
struct RebootToBootloaderDefaultTypeInternal;
extern RebootToBootloaderDefaultTypeInternal _RebootToBootloader_default_instance_;
class RecoveryDevice;
struct RecoveryDeviceDefaultTypeInternal;
extern RecoveryDeviceDefaultTypeInternal _RecoveryDevice_default_instance_;
class ResetDevice;
struct ResetDeviceDefaultTypeInternal;
extern ResetDeviceDefaultTypeInternal _ResetDevice_default_instance_;
class SdProtect;
struct SdProtectDefaultTypeInternal;
extern SdProtectDefaultTypeInternal _SdProtect_default_instance_;
class SetBusy;
struct SetBusyDefaultTypeInternal;
extern SetBusyDefaultTypeInternal _SetBusy_default_instance_;
class SetU2FCounter;
struct SetU2FCounterDefaultTypeInternal;
extern SetU2FCounterDefaultTypeInternal _SetU2FCounter_default_instance_;
class UnlockPath;
struct UnlockPathDefaultTypeInternal;
extern UnlockPathDefaultTypeInternal _UnlockPath_default_instance_;
class UnlockedPathRequest;
struct UnlockedPathRequestDefaultTypeInternal;
extern UnlockedPathRequestDefaultTypeInternal _UnlockedPathRequest_default_instance_;
class WipeDevice;
struct WipeDeviceDefaultTypeInternal;
extern WipeDeviceDefaultTypeInternal _WipeDevice_default_instance_;
class WordAck;
struct WordAckDefaultTypeInternal;
extern WordAckDefaultTypeInternal _WordAck_default_instance_;
class WordRequest;
struct WordRequestDefaultTypeInternal;
extern WordRequestDefaultTypeInternal _WordRequest_default_instance_;
}  // namespace management
}  // namespace messages
}  // namespace trezor
}  // namespace hw
PROTOBUF_NAMESPACE_OPEN
template<> ::hw::trezor::messages::management::ApplyFlags* Arena::CreateMaybeMessage<::hw::trezor::messages::management::ApplyFlags>(Arena*);
template<> ::hw::trezor::messages::management::ApplySettings* Arena::CreateMaybeMessage<::hw::trezor::messages::management::ApplySettings>(Arena*);
template<> ::hw::trezor::messages::management::BackupDevice* Arena::CreateMaybeMessage<::hw::trezor::messages::management::BackupDevice>(Arena*);
template<> ::hw::trezor::messages::management::Cancel* Arena::CreateMaybeMessage<::hw::trezor::messages::management::Cancel>(Arena*);
template<> ::hw::trezor::messages::management::CancelAuthorization* Arena::CreateMaybeMessage<::hw::trezor::messages::management::CancelAuthorization>(Arena*);
template<> ::hw::trezor::messages::management::ChangePin* Arena::CreateMaybeMessage<::hw::trezor::messages::management::ChangePin>(Arena*);
template<> ::hw::trezor::messages::management::ChangeWipeCode* Arena::CreateMaybeMessage<::hw::trezor::messages::management::ChangeWipeCode>(Arena*);
template<> ::hw::trezor::messages::management::DoPreauthorized* Arena::CreateMaybeMessage<::hw::trezor::messages::management::DoPreauthorized>(Arena*);
template<> ::hw::trezor::messages::management::EndSession* Arena::CreateMaybeMessage<::hw::trezor::messages::management::EndSession>(Arena*);
template<> ::hw::trezor::messages::management::Entropy* Arena::CreateMaybeMessage<::hw::trezor::messages::management::Entropy>(Arena*);
template<> ::hw::trezor::messages::management::EntropyAck* Arena::CreateMaybeMessage<::hw::trezor::messages::management::EntropyAck>(Arena*);
template<> ::hw::trezor::messages::management::EntropyRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::management::EntropyRequest>(Arena*);
template<> ::hw::trezor::messages::management::Features* Arena::CreateMaybeMessage<::hw::trezor::messages::management::Features>(Arena*);
template<> ::hw::trezor::messages::management::FirmwareHash* Arena::CreateMaybeMessage<::hw::trezor::messages::management::FirmwareHash>(Arena*);
template<> ::hw::trezor::messages::management::GetEntropy* Arena::CreateMaybeMessage<::hw::trezor::messages::management::GetEntropy>(Arena*);
template<> ::hw::trezor::messages::management::GetFeatures* Arena::CreateMaybeMessage<::hw::trezor::messages::management::GetFeatures>(Arena*);
template<> ::hw::trezor::messages::management::GetFirmwareHash* Arena::CreateMaybeMessage<::hw::trezor::messages::management::GetFirmwareHash>(Arena*);
template<> ::hw::trezor::messages::management::GetNextU2FCounter* Arena::CreateMaybeMessage<::hw::trezor::messages::management::GetNextU2FCounter>(Arena*);
template<> ::hw::trezor::messages::management::GetNonce* Arena::CreateMaybeMessage<::hw::trezor::messages::management::GetNonce>(Arena*);
template<> ::hw::trezor::messages::management::Initialize* Arena::CreateMaybeMessage<::hw::trezor::messages::management::Initialize>(Arena*);
template<> ::hw::trezor::messages::management::LoadDevice* Arena::CreateMaybeMessage<::hw::trezor::messages::management::LoadDevice>(Arena*);
template<> ::hw::trezor::messages::management::LockDevice* Arena::CreateMaybeMessage<::hw::trezor::messages::management::LockDevice>(Arena*);
template<> ::hw::trezor::messages::management::NextU2FCounter* Arena::CreateMaybeMessage<::hw::trezor::messages::management::NextU2FCounter>(Arena*);
template<> ::hw::trezor::messages::management::Nonce* Arena::CreateMaybeMessage<::hw::trezor::messages::management::Nonce>(Arena*);
template<> ::hw::trezor::messages::management::Ping* Arena::CreateMaybeMessage<::hw::trezor::messages::management::Ping>(Arena*);
template<> ::hw::trezor::messages::management::PreauthorizedRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::management::PreauthorizedRequest>(Arena*);
template<> ::hw::trezor::messages::management::RebootToBootloader* Arena::CreateMaybeMessage<::hw::trezor::messages::management::RebootToBootloader>(Arena*);
template<> ::hw::trezor::messages::management::RecoveryDevice* Arena::CreateMaybeMessage<::hw::trezor::messages::management::RecoveryDevice>(Arena*);
template<> ::hw::trezor::messages::management::ResetDevice* Arena::CreateMaybeMessage<::hw::trezor::messages::management::ResetDevice>(Arena*);
template<> ::hw::trezor::messages::management::SdProtect* Arena::CreateMaybeMessage<::hw::trezor::messages::management::SdProtect>(Arena*);
template<> ::hw::trezor::messages::management::SetBusy* Arena::CreateMaybeMessage<::hw::trezor::messages::management::SetBusy>(Arena*);
template<> ::hw::trezor::messages::management::SetU2FCounter* Arena::CreateMaybeMessage<::hw::trezor::messages::management::SetU2FCounter>(Arena*);
template<> ::hw::trezor::messages::management::UnlockPath* Arena::CreateMaybeMessage<::hw::trezor::messages::management::UnlockPath>(Arena*);
template<> ::hw::trezor::messages::management::UnlockedPathRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::management::UnlockedPathRequest>(Arena*);
template<> ::hw::trezor::messages::management::WipeDevice* Arena::CreateMaybeMessage<::hw::trezor::messages::management::WipeDevice>(Arena*);
template<> ::hw::trezor::messages::management::WordAck* Arena::CreateMaybeMessage<::hw::trezor::messages::management::WordAck>(Arena*);
template<> ::hw::trezor::messages::management::WordRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::management::WordRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hw {
namespace trezor {
namespace messages {
namespace management {

enum Features_Capability : int {
  Features_Capability_Capability_Bitcoin = 1,
  Features_Capability_Capability_Bitcoin_like = 2,
  Features_Capability_Capability_Binance = 3,
  Features_Capability_Capability_Cardano = 4,
  Features_Capability_Capability_Crypto = 5,
  Features_Capability_Capability_EOS = 6,
  Features_Capability_Capability_Ethereum = 7,
  Features_Capability_Capability_Lisk PROTOBUF_DEPRECATED_ENUM = 8,
  Features_Capability_Capability_Monero = 9,
  Features_Capability_Capability_NEM = 10,
  Features_Capability_Capability_Ripple = 11,
  Features_Capability_Capability_Stellar = 12,
  Features_Capability_Capability_Tezos = 13,
  Features_Capability_Capability_U2F = 14,
  Features_Capability_Capability_Shamir = 15,
  Features_Capability_Capability_ShamirGroups = 16,
  Features_Capability_Capability_PassphraseEntry = 17
};
bool Features_Capability_IsValid(int value);
constexpr Features_Capability Features_Capability_Capability_MIN = Features_Capability_Capability_Bitcoin;
constexpr Features_Capability Features_Capability_Capability_MAX = Features_Capability_Capability_PassphraseEntry;
constexpr int Features_Capability_Capability_ARRAYSIZE = Features_Capability_Capability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Features_Capability_descriptor();
template<typename T>
inline const std::string& Features_Capability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Features_Capability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Features_Capability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Features_Capability_descriptor(), enum_t_value);
}
inline bool Features_Capability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Features_Capability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Features_Capability>(
    Features_Capability_descriptor(), name, value);
}
enum SdProtect_SdProtectOperationType : int {
  SdProtect_SdProtectOperationType_DISABLE = 0,
  SdProtect_SdProtectOperationType_ENABLE = 1,
  SdProtect_SdProtectOperationType_REFRESH = 2
};
bool SdProtect_SdProtectOperationType_IsValid(int value);
constexpr SdProtect_SdProtectOperationType SdProtect_SdProtectOperationType_SdProtectOperationType_MIN = SdProtect_SdProtectOperationType_DISABLE;
constexpr SdProtect_SdProtectOperationType SdProtect_SdProtectOperationType_SdProtectOperationType_MAX = SdProtect_SdProtectOperationType_REFRESH;
constexpr int SdProtect_SdProtectOperationType_SdProtectOperationType_ARRAYSIZE = SdProtect_SdProtectOperationType_SdProtectOperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SdProtect_SdProtectOperationType_descriptor();
template<typename T>
inline const std::string& SdProtect_SdProtectOperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SdProtect_SdProtectOperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SdProtect_SdProtectOperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SdProtect_SdProtectOperationType_descriptor(), enum_t_value);
}
inline bool SdProtect_SdProtectOperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SdProtect_SdProtectOperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SdProtect_SdProtectOperationType>(
    SdProtect_SdProtectOperationType_descriptor(), name, value);
}
enum RecoveryDevice_RecoveryDeviceType : int {
  RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ScrambledWords = 0,
  RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_Matrix = 1
};
bool RecoveryDevice_RecoveryDeviceType_IsValid(int value);
constexpr RecoveryDevice_RecoveryDeviceType RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MIN = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ScrambledWords;
constexpr RecoveryDevice_RecoveryDeviceType RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MAX = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_Matrix;
constexpr int RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ARRAYSIZE = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecoveryDevice_RecoveryDeviceType_descriptor();
template<typename T>
inline const std::string& RecoveryDevice_RecoveryDeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecoveryDevice_RecoveryDeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecoveryDevice_RecoveryDeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecoveryDevice_RecoveryDeviceType_descriptor(), enum_t_value);
}
inline bool RecoveryDevice_RecoveryDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecoveryDevice_RecoveryDeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecoveryDevice_RecoveryDeviceType>(
    RecoveryDevice_RecoveryDeviceType_descriptor(), name, value);
}
enum WordRequest_WordRequestType : int {
  WordRequest_WordRequestType_WordRequestType_Plain = 0,
  WordRequest_WordRequestType_WordRequestType_Matrix9 = 1,
  WordRequest_WordRequestType_WordRequestType_Matrix6 = 2
};
bool WordRequest_WordRequestType_IsValid(int value);
constexpr WordRequest_WordRequestType WordRequest_WordRequestType_WordRequestType_MIN = WordRequest_WordRequestType_WordRequestType_Plain;
constexpr WordRequest_WordRequestType WordRequest_WordRequestType_WordRequestType_MAX = WordRequest_WordRequestType_WordRequestType_Matrix6;
constexpr int WordRequest_WordRequestType_WordRequestType_ARRAYSIZE = WordRequest_WordRequestType_WordRequestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WordRequest_WordRequestType_descriptor();
template<typename T>
inline const std::string& WordRequest_WordRequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WordRequest_WordRequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WordRequest_WordRequestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WordRequest_WordRequestType_descriptor(), enum_t_value);
}
inline bool WordRequest_WordRequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WordRequest_WordRequestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WordRequest_WordRequestType>(
    WordRequest_WordRequestType_descriptor(), name, value);
}
enum BackupType : int {
  Bip39 = 0,
  Slip39_Basic = 1,
  Slip39_Advanced = 2
};
bool BackupType_IsValid(int value);
constexpr BackupType BackupType_MIN = Bip39;
constexpr BackupType BackupType_MAX = Slip39_Advanced;
constexpr int BackupType_ARRAYSIZE = BackupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BackupType_descriptor();
template<typename T>
inline const std::string& BackupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BackupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BackupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BackupType_descriptor(), enum_t_value);
}
inline bool BackupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BackupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BackupType>(
    BackupType_descriptor(), name, value);
}
enum SafetyCheckLevel : int {
  Strict = 0,
  PromptAlways = 1,
  PromptTemporarily = 2
};
bool SafetyCheckLevel_IsValid(int value);
constexpr SafetyCheckLevel SafetyCheckLevel_MIN = Strict;
constexpr SafetyCheckLevel SafetyCheckLevel_MAX = PromptTemporarily;
constexpr int SafetyCheckLevel_ARRAYSIZE = SafetyCheckLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SafetyCheckLevel_descriptor();
template<typename T>
inline const std::string& SafetyCheckLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SafetyCheckLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SafetyCheckLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SafetyCheckLevel_descriptor(), enum_t_value);
}
inline bool SafetyCheckLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SafetyCheckLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SafetyCheckLevel>(
    SafetyCheckLevel_descriptor(), name, value);
}
enum HomescreenFormat : int {
  Toif144x144 = 1,
  Jpeg240x240 = 2
};
bool HomescreenFormat_IsValid(int value);
constexpr HomescreenFormat HomescreenFormat_MIN = Toif144x144;
constexpr HomescreenFormat HomescreenFormat_MAX = Jpeg240x240;
constexpr int HomescreenFormat_ARRAYSIZE = HomescreenFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HomescreenFormat_descriptor();
template<typename T>
inline const std::string& HomescreenFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HomescreenFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HomescreenFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HomescreenFormat_descriptor(), enum_t_value);
}
inline bool HomescreenFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HomescreenFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HomescreenFormat>(
    HomescreenFormat_descriptor(), name, value);
}
// ===================================================================

class Initialize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.Initialize) */ {
 public:
  inline Initialize() : Initialize(nullptr) {}
  ~Initialize() override;
  explicit PROTOBUF_CONSTEXPR Initialize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Initialize(const Initialize& from);
  Initialize(Initialize&& from) noexcept
    : Initialize() {
    *this = ::std::move(from);
  }

  inline Initialize& operator=(const Initialize& from) {
    CopyFrom(from);
    return *this;
  }
  inline Initialize& operator=(Initialize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Initialize& default_instance() {
    return *internal_default_instance();
  }
  static inline const Initialize* internal_default_instance() {
    return reinterpret_cast<const Initialize*>(
               &_Initialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Initialize& a, Initialize& b) {
    a.Swap(&b);
  }
  inline void Swap(Initialize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Initialize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Initialize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Initialize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Initialize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Initialize& from) {
    Initialize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Initialize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.Initialize";
  }
  protected:
  explicit Initialize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kSkipPassphraseFieldNumber = 2,
    kDeriveCardanoFieldNumber = 3,
  };
  // optional bytes session_id = 1;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // optional bool _skip_passphrase = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has__skip_passphrase() const;
  private:
  bool _internal_has__skip_passphrase() const;
  public:
  PROTOBUF_DEPRECATED void clear__skip_passphrase();
  PROTOBUF_DEPRECATED bool _skip_passphrase() const;
  PROTOBUF_DEPRECATED void set__skip_passphrase(bool value);
  private:
  bool _internal__skip_passphrase() const;
  void _internal_set__skip_passphrase(bool value);
  public:

  // optional bool derive_cardano = 3;
  bool has_derive_cardano() const;
  private:
  bool _internal_has_derive_cardano() const;
  public:
  void clear_derive_cardano();
  bool derive_cardano() const;
  void set_derive_cardano(bool value);
  private:
  bool _internal_derive_cardano() const;
  void _internal_set_derive_cardano(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Initialize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    bool _skip_passphrase_;
    bool derive_cardano_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class GetFeatures final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.GetFeatures) */ {
 public:
  inline GetFeatures() : GetFeatures(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetFeatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFeatures(const GetFeatures& from);
  GetFeatures(GetFeatures&& from) noexcept
    : GetFeatures() {
    *this = ::std::move(from);
  }

  inline GetFeatures& operator=(const GetFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFeatures& operator=(GetFeatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFeatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFeatures* internal_default_instance() {
    return reinterpret_cast<const GetFeatures*>(
               &_GetFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetFeatures& a, GetFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFeatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFeatures>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetFeatures& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetFeatures& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.GetFeatures";
  }
  protected:
  explicit GetFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetFeatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class Features final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.Features) */ {
 public:
  inline Features() : Features(nullptr) {}
  ~Features() override;
  explicit PROTOBUF_CONSTEXPR Features(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Features(const Features& from);
  Features(Features&& from) noexcept
    : Features() {
    *this = ::std::move(from);
  }

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }
  inline Features& operator=(Features&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Features& default_instance() {
    return *internal_default_instance();
  }
  static inline const Features* internal_default_instance() {
    return reinterpret_cast<const Features*>(
               &_Features_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Features& a, Features& b) {
    a.Swap(&b);
  }
  inline void Swap(Features* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Features* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Features* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Features>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Features& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Features& from) {
    Features::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Features* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.Features";
  }
  protected:
  explicit Features(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Features_Capability Capability;
  static constexpr Capability Capability_Bitcoin =
    Features_Capability_Capability_Bitcoin;
  static constexpr Capability Capability_Bitcoin_like =
    Features_Capability_Capability_Bitcoin_like;
  static constexpr Capability Capability_Binance =
    Features_Capability_Capability_Binance;
  static constexpr Capability Capability_Cardano =
    Features_Capability_Capability_Cardano;
  static constexpr Capability Capability_Crypto =
    Features_Capability_Capability_Crypto;
  static constexpr Capability Capability_EOS =
    Features_Capability_Capability_EOS;
  static constexpr Capability Capability_Ethereum =
    Features_Capability_Capability_Ethereum;
  PROTOBUF_DEPRECATED_ENUM static constexpr Capability Capability_Lisk =
    Features_Capability_Capability_Lisk;
  static constexpr Capability Capability_Monero =
    Features_Capability_Capability_Monero;
  static constexpr Capability Capability_NEM =
    Features_Capability_Capability_NEM;
  static constexpr Capability Capability_Ripple =
    Features_Capability_Capability_Ripple;
  static constexpr Capability Capability_Stellar =
    Features_Capability_Capability_Stellar;
  static constexpr Capability Capability_Tezos =
    Features_Capability_Capability_Tezos;
  static constexpr Capability Capability_U2F =
    Features_Capability_Capability_U2F;
  static constexpr Capability Capability_Shamir =
    Features_Capability_Capability_Shamir;
  static constexpr Capability Capability_ShamirGroups =
    Features_Capability_Capability_ShamirGroups;
  static constexpr Capability Capability_PassphraseEntry =
    Features_Capability_Capability_PassphraseEntry;
  static inline bool Capability_IsValid(int value) {
    return Features_Capability_IsValid(value);
  }
  static constexpr Capability Capability_MIN =
    Features_Capability_Capability_MIN;
  static constexpr Capability Capability_MAX =
    Features_Capability_Capability_MAX;
  static constexpr int Capability_ARRAYSIZE =
    Features_Capability_Capability_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Capability_descriptor() {
    return Features_Capability_descriptor();
  }
  template<typename T>
  static inline const std::string& Capability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Capability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Capability_Name.");
    return Features_Capability_Name(enum_t_value);
  }
  static inline bool Capability_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Capability* value) {
    return Features_Capability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 30,
    kVendorFieldNumber = 1,
    kDeviceIdFieldNumber = 6,
    kLanguageFieldNumber = 9,
    kLabelFieldNumber = 10,
    kRevisionFieldNumber = 13,
    kBootloaderHashFieldNumber = 14,
    kModelFieldNumber = 21,
    kFwVendorFieldNumber = 25,
    kSessionIdFieldNumber = 35,
    kMajorVersionFieldNumber = 2,
    kMinorVersionFieldNumber = 3,
    kPatchVersionFieldNumber = 4,
    kBootloaderModeFieldNumber = 5,
    kPinProtectionFieldNumber = 7,
    kPassphraseProtectionFieldNumber = 8,
    kInitializedFieldNumber = 12,
    kImportedFieldNumber = 15,
    kUnlockedFieldNumber = 16,
    kPassphraseCachedFieldNumber = 17,
    kFirmwarePresentFieldNumber = 18,
    kFlagsFieldNumber = 20,
    kFwMajorFieldNumber = 22,
    kFwMinorFieldNumber = 23,
    kFwPatchFieldNumber = 24,
    kNeedsBackupFieldNumber = 19,
    kUnfinishedBackupFieldNumber = 27,
    kNoBackupFieldNumber = 28,
    kRecoveryModeFieldNumber = 29,
    kBackupTypeFieldNumber = 31,
    kSdCardPresentFieldNumber = 32,
    kSdProtectionFieldNumber = 33,
    kWipeCodeProtectionFieldNumber = 34,
    kPassphraseAlwaysOnDeviceFieldNumber = 36,
    kSafetyChecksFieldNumber = 37,
    kAutoLockDelayMsFieldNumber = 38,
    kDisplayRotationFieldNumber = 39,
    kExperimentalFeaturesFieldNumber = 40,
    kBusyFieldNumber = 41,
    kHidePassphraseFromHostFieldNumber = 43,
    kHomescreenFormatFieldNumber = 42,
  };
  // repeated .hw.trezor.messages.management.Features.Capability capabilities = 30;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  private:
  ::hw::trezor::messages::management::Features_Capability _internal_capabilities(int index) const;
  void _internal_add_capabilities(::hw::trezor::messages::management::Features_Capability value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_capabilities();
  public:
  ::hw::trezor::messages::management::Features_Capability capabilities(int index) const;
  void set_capabilities(int index, ::hw::trezor::messages::management::Features_Capability value);
  void add_capabilities(::hw::trezor::messages::management::Features_Capability value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_capabilities();

  // optional string vendor = 1;
  bool has_vendor() const;
  private:
  bool _internal_has_vendor() const;
  public:
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // optional string device_id = 6;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // optional string language = 9;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string label = 10;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional bytes revision = 13;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // optional bytes bootloader_hash = 14;
  bool has_bootloader_hash() const;
  private:
  bool _internal_has_bootloader_hash() const;
  public:
  void clear_bootloader_hash();
  const std::string& bootloader_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bootloader_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bootloader_hash();
  PROTOBUF_NODISCARD std::string* release_bootloader_hash();
  void set_allocated_bootloader_hash(std::string* bootloader_hash);
  private:
  const std::string& _internal_bootloader_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bootloader_hash(const std::string& value);
  std::string* _internal_mutable_bootloader_hash();
  public:

  // optional string model = 21;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional string fw_vendor = 25;
  bool has_fw_vendor() const;
  private:
  bool _internal_has_fw_vendor() const;
  public:
  void clear_fw_vendor();
  const std::string& fw_vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fw_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fw_vendor();
  PROTOBUF_NODISCARD std::string* release_fw_vendor();
  void set_allocated_fw_vendor(std::string* fw_vendor);
  private:
  const std::string& _internal_fw_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fw_vendor(const std::string& value);
  std::string* _internal_mutable_fw_vendor();
  public:

  // optional bytes session_id = 35;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // required uint32 major_version = 2;
  bool has_major_version() const;
  private:
  bool _internal_has_major_version() const;
  public:
  void clear_major_version();
  uint32_t major_version() const;
  void set_major_version(uint32_t value);
  private:
  uint32_t _internal_major_version() const;
  void _internal_set_major_version(uint32_t value);
  public:

  // required uint32 minor_version = 3;
  bool has_minor_version() const;
  private:
  bool _internal_has_minor_version() const;
  public:
  void clear_minor_version();
  uint32_t minor_version() const;
  void set_minor_version(uint32_t value);
  private:
  uint32_t _internal_minor_version() const;
  void _internal_set_minor_version(uint32_t value);
  public:

  // required uint32 patch_version = 4;
  bool has_patch_version() const;
  private:
  bool _internal_has_patch_version() const;
  public:
  void clear_patch_version();
  uint32_t patch_version() const;
  void set_patch_version(uint32_t value);
  private:
  uint32_t _internal_patch_version() const;
  void _internal_set_patch_version(uint32_t value);
  public:

  // optional bool bootloader_mode = 5;
  bool has_bootloader_mode() const;
  private:
  bool _internal_has_bootloader_mode() const;
  public:
  void clear_bootloader_mode();
  bool bootloader_mode() const;
  void set_bootloader_mode(bool value);
  private:
  bool _internal_bootloader_mode() const;
  void _internal_set_bootloader_mode(bool value);
  public:

  // optional bool pin_protection = 7;
  bool has_pin_protection() const;
  private:
  bool _internal_has_pin_protection() const;
  public:
  void clear_pin_protection();
  bool pin_protection() const;
  void set_pin_protection(bool value);
  private:
  bool _internal_pin_protection() const;
  void _internal_set_pin_protection(bool value);
  public:

  // optional bool passphrase_protection = 8;
  bool has_passphrase_protection() const;
  private:
  bool _internal_has_passphrase_protection() const;
  public:
  void clear_passphrase_protection();
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);
  private:
  bool _internal_passphrase_protection() const;
  void _internal_set_passphrase_protection(bool value);
  public:

  // optional bool initialized = 12;
  bool has_initialized() const;
  private:
  bool _internal_has_initialized() const;
  public:
  void clear_initialized();
  bool initialized() const;
  void set_initialized(bool value);
  private:
  bool _internal_initialized() const;
  void _internal_set_initialized(bool value);
  public:

  // optional bool imported = 15;
  bool has_imported() const;
  private:
  bool _internal_has_imported() const;
  public:
  void clear_imported();
  bool imported() const;
  void set_imported(bool value);
  private:
  bool _internal_imported() const;
  void _internal_set_imported(bool value);
  public:

  // optional bool unlocked = 16;
  bool has_unlocked() const;
  private:
  bool _internal_has_unlocked() const;
  public:
  void clear_unlocked();
  bool unlocked() const;
  void set_unlocked(bool value);
  private:
  bool _internal_unlocked() const;
  void _internal_set_unlocked(bool value);
  public:

  // optional bool _passphrase_cached = 17 [deprecated = true];
  PROTOBUF_DEPRECATED bool has__passphrase_cached() const;
  private:
  bool _internal_has__passphrase_cached() const;
  public:
  PROTOBUF_DEPRECATED void clear__passphrase_cached();
  PROTOBUF_DEPRECATED bool _passphrase_cached() const;
  PROTOBUF_DEPRECATED void set__passphrase_cached(bool value);
  private:
  bool _internal__passphrase_cached() const;
  void _internal_set__passphrase_cached(bool value);
  public:

  // optional bool firmware_present = 18;
  bool has_firmware_present() const;
  private:
  bool _internal_has_firmware_present() const;
  public:
  void clear_firmware_present();
  bool firmware_present() const;
  void set_firmware_present(bool value);
  private:
  bool _internal_firmware_present() const;
  void _internal_set_firmware_present(bool value);
  public:

  // optional uint32 flags = 20;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional uint32 fw_major = 22;
  bool has_fw_major() const;
  private:
  bool _internal_has_fw_major() const;
  public:
  void clear_fw_major();
  uint32_t fw_major() const;
  void set_fw_major(uint32_t value);
  private:
  uint32_t _internal_fw_major() const;
  void _internal_set_fw_major(uint32_t value);
  public:

  // optional uint32 fw_minor = 23;
  bool has_fw_minor() const;
  private:
  bool _internal_has_fw_minor() const;
  public:
  void clear_fw_minor();
  uint32_t fw_minor() const;
  void set_fw_minor(uint32_t value);
  private:
  uint32_t _internal_fw_minor() const;
  void _internal_set_fw_minor(uint32_t value);
  public:

  // optional uint32 fw_patch = 24;
  bool has_fw_patch() const;
  private:
  bool _internal_has_fw_patch() const;
  public:
  void clear_fw_patch();
  uint32_t fw_patch() const;
  void set_fw_patch(uint32_t value);
  private:
  uint32_t _internal_fw_patch() const;
  void _internal_set_fw_patch(uint32_t value);
  public:

  // optional bool needs_backup = 19;
  bool has_needs_backup() const;
  private:
  bool _internal_has_needs_backup() const;
  public:
  void clear_needs_backup();
  bool needs_backup() const;
  void set_needs_backup(bool value);
  private:
  bool _internal_needs_backup() const;
  void _internal_set_needs_backup(bool value);
  public:

  // optional bool unfinished_backup = 27;
  bool has_unfinished_backup() const;
  private:
  bool _internal_has_unfinished_backup() const;
  public:
  void clear_unfinished_backup();
  bool unfinished_backup() const;
  void set_unfinished_backup(bool value);
  private:
  bool _internal_unfinished_backup() const;
  void _internal_set_unfinished_backup(bool value);
  public:

  // optional bool no_backup = 28;
  bool has_no_backup() const;
  private:
  bool _internal_has_no_backup() const;
  public:
  void clear_no_backup();
  bool no_backup() const;
  void set_no_backup(bool value);
  private:
  bool _internal_no_backup() const;
  void _internal_set_no_backup(bool value);
  public:

  // optional bool recovery_mode = 29;
  bool has_recovery_mode() const;
  private:
  bool _internal_has_recovery_mode() const;
  public:
  void clear_recovery_mode();
  bool recovery_mode() const;
  void set_recovery_mode(bool value);
  private:
  bool _internal_recovery_mode() const;
  void _internal_set_recovery_mode(bool value);
  public:

  // optional .hw.trezor.messages.management.BackupType backup_type = 31;
  bool has_backup_type() const;
  private:
  bool _internal_has_backup_type() const;
  public:
  void clear_backup_type();
  ::hw::trezor::messages::management::BackupType backup_type() const;
  void set_backup_type(::hw::trezor::messages::management::BackupType value);
  private:
  ::hw::trezor::messages::management::BackupType _internal_backup_type() const;
  void _internal_set_backup_type(::hw::trezor::messages::management::BackupType value);
  public:

  // optional bool sd_card_present = 32;
  bool has_sd_card_present() const;
  private:
  bool _internal_has_sd_card_present() const;
  public:
  void clear_sd_card_present();
  bool sd_card_present() const;
  void set_sd_card_present(bool value);
  private:
  bool _internal_sd_card_present() const;
  void _internal_set_sd_card_present(bool value);
  public:

  // optional bool sd_protection = 33;
  bool has_sd_protection() const;
  private:
  bool _internal_has_sd_protection() const;
  public:
  void clear_sd_protection();
  bool sd_protection() const;
  void set_sd_protection(bool value);
  private:
  bool _internal_sd_protection() const;
  void _internal_set_sd_protection(bool value);
  public:

  // optional bool wipe_code_protection = 34;
  bool has_wipe_code_protection() const;
  private:
  bool _internal_has_wipe_code_protection() const;
  public:
  void clear_wipe_code_protection();
  bool wipe_code_protection() const;
  void set_wipe_code_protection(bool value);
  private:
  bool _internal_wipe_code_protection() const;
  void _internal_set_wipe_code_protection(bool value);
  public:

  // optional bool passphrase_always_on_device = 36;
  bool has_passphrase_always_on_device() const;
  private:
  bool _internal_has_passphrase_always_on_device() const;
  public:
  void clear_passphrase_always_on_device();
  bool passphrase_always_on_device() const;
  void set_passphrase_always_on_device(bool value);
  private:
  bool _internal_passphrase_always_on_device() const;
  void _internal_set_passphrase_always_on_device(bool value);
  public:

  // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;
  bool has_safety_checks() const;
  private:
  bool _internal_has_safety_checks() const;
  public:
  void clear_safety_checks();
  ::hw::trezor::messages::management::SafetyCheckLevel safety_checks() const;
  void set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value);
  private:
  ::hw::trezor::messages::management::SafetyCheckLevel _internal_safety_checks() const;
  void _internal_set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value);
  public:

  // optional uint32 auto_lock_delay_ms = 38;
  bool has_auto_lock_delay_ms() const;
  private:
  bool _internal_has_auto_lock_delay_ms() const;
  public:
  void clear_auto_lock_delay_ms();
  uint32_t auto_lock_delay_ms() const;
  void set_auto_lock_delay_ms(uint32_t value);
  private:
  uint32_t _internal_auto_lock_delay_ms() const;
  void _internal_set_auto_lock_delay_ms(uint32_t value);
  public:

  // optional uint32 display_rotation = 39;
  bool has_display_rotation() const;
  private:
  bool _internal_has_display_rotation() const;
  public:
  void clear_display_rotation();
  uint32_t display_rotation() const;
  void set_display_rotation(uint32_t value);
  private:
  uint32_t _internal_display_rotation() const;
  void _internal_set_display_rotation(uint32_t value);
  public:

  // optional bool experimental_features = 40;
  bool has_experimental_features() const;
  private:
  bool _internal_has_experimental_features() const;
  public:
  void clear_experimental_features();
  bool experimental_features() const;
  void set_experimental_features(bool value);
  private:
  bool _internal_experimental_features() const;
  void _internal_set_experimental_features(bool value);
  public:

  // optional bool busy = 41;
  bool has_busy() const;
  private:
  bool _internal_has_busy() const;
  public:
  void clear_busy();
  bool busy() const;
  void set_busy(bool value);
  private:
  bool _internal_busy() const;
  void _internal_set_busy(bool value);
  public:

  // optional bool hide_passphrase_from_host = 43;
  bool has_hide_passphrase_from_host() const;
  private:
  bool _internal_has_hide_passphrase_from_host() const;
  public:
  void clear_hide_passphrase_from_host();
  bool hide_passphrase_from_host() const;
  void set_hide_passphrase_from_host(bool value);
  private:
  bool _internal_hide_passphrase_from_host() const;
  void _internal_set_hide_passphrase_from_host(bool value);
  public:

  // optional .hw.trezor.messages.management.HomescreenFormat homescreen_format = 42;
  bool has_homescreen_format() const;
  private:
  bool _internal_has_homescreen_format() const;
  public:
  void clear_homescreen_format();
  ::hw::trezor::messages::management::HomescreenFormat homescreen_format() const;
  void set_homescreen_format(::hw::trezor::messages::management::HomescreenFormat value);
  private:
  ::hw::trezor::messages::management::HomescreenFormat _internal_homescreen_format() const;
  void _internal_set_homescreen_format(::hw::trezor::messages::management::HomescreenFormat value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Features)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> capabilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bootloader_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fw_vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    uint32_t major_version_;
    uint32_t minor_version_;
    uint32_t patch_version_;
    bool bootloader_mode_;
    bool pin_protection_;
    bool passphrase_protection_;
    bool initialized_;
    bool imported_;
    bool unlocked_;
    bool _passphrase_cached_;
    bool firmware_present_;
    uint32_t flags_;
    uint32_t fw_major_;
    uint32_t fw_minor_;
    uint32_t fw_patch_;
    bool needs_backup_;
    bool unfinished_backup_;
    bool no_backup_;
    bool recovery_mode_;
    int backup_type_;
    bool sd_card_present_;
    bool sd_protection_;
    bool wipe_code_protection_;
    bool passphrase_always_on_device_;
    int safety_checks_;
    uint32_t auto_lock_delay_ms_;
    uint32_t display_rotation_;
    bool experimental_features_;
    bool busy_;
    bool hide_passphrase_from_host_;
    int homescreen_format_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class LockDevice final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.LockDevice) */ {
 public:
  inline LockDevice() : LockDevice(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LockDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockDevice(const LockDevice& from);
  LockDevice(LockDevice&& from) noexcept
    : LockDevice() {
    *this = ::std::move(from);
  }

  inline LockDevice& operator=(const LockDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockDevice& operator=(LockDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockDevice* internal_default_instance() {
    return reinterpret_cast<const LockDevice*>(
               &_LockDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LockDevice& a, LockDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(LockDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LockDevice& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LockDevice& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.LockDevice";
  }
  protected:
  explicit LockDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.LockDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class SetBusy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.SetBusy) */ {
 public:
  inline SetBusy() : SetBusy(nullptr) {}
  ~SetBusy() override;
  explicit PROTOBUF_CONSTEXPR SetBusy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetBusy(const SetBusy& from);
  SetBusy(SetBusy&& from) noexcept
    : SetBusy() {
    *this = ::std::move(from);
  }

  inline SetBusy& operator=(const SetBusy& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetBusy& operator=(SetBusy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetBusy& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetBusy* internal_default_instance() {
    return reinterpret_cast<const SetBusy*>(
               &_SetBusy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetBusy& a, SetBusy& b) {
    a.Swap(&b);
  }
  inline void Swap(SetBusy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetBusy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetBusy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetBusy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetBusy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetBusy& from) {
    SetBusy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetBusy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.SetBusy";
  }
  protected:
  explicit SetBusy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpiryMsFieldNumber = 1,
  };
  // optional uint32 expiry_ms = 1;
  bool has_expiry_ms() const;
  private:
  bool _internal_has_expiry_ms() const;
  public:
  void clear_expiry_ms();
  uint32_t expiry_ms() const;
  void set_expiry_ms(uint32_t value);
  private:
  uint32_t _internal_expiry_ms() const;
  void _internal_set_expiry_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.SetBusy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t expiry_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class EndSession final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.EndSession) */ {
 public:
  inline EndSession() : EndSession(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EndSession(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndSession(const EndSession& from);
  EndSession(EndSession&& from) noexcept
    : EndSession() {
    *this = ::std::move(from);
  }

  inline EndSession& operator=(const EndSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndSession& operator=(EndSession&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndSession& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndSession* internal_default_instance() {
    return reinterpret_cast<const EndSession*>(
               &_EndSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EndSession& a, EndSession& b) {
    a.Swap(&b);
  }
  inline void Swap(EndSession* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndSession>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EndSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EndSession& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.EndSession";
  }
  protected:
  explicit EndSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.EndSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class ApplySettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.ApplySettings) */ {
 public:
  inline ApplySettings() : ApplySettings(nullptr) {}
  ~ApplySettings() override;
  explicit PROTOBUF_CONSTEXPR ApplySettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplySettings(const ApplySettings& from);
  ApplySettings(ApplySettings&& from) noexcept
    : ApplySettings() {
    *this = ::std::move(from);
  }

  inline ApplySettings& operator=(const ApplySettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplySettings& operator=(ApplySettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplySettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplySettings* internal_default_instance() {
    return reinterpret_cast<const ApplySettings*>(
               &_ApplySettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ApplySettings& a, ApplySettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplySettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplySettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplySettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplySettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplySettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplySettings& from) {
    ApplySettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplySettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.ApplySettings";
  }
  protected:
  explicit ApplySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kLabelFieldNumber = 2,
    kHomescreenFieldNumber = 4,
    kPassphraseSourceFieldNumber = 5,
    kAutoLockDelayMsFieldNumber = 6,
    kDisplayRotationFieldNumber = 7,
    kUsePassphraseFieldNumber = 3,
    kPassphraseAlwaysOnDeviceFieldNumber = 8,
    kExperimentalFeaturesFieldNumber = 10,
    kHidePassphraseFromHostFieldNumber = 11,
    kSafetyChecksFieldNumber = 9,
  };
  // optional string language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional bytes homescreen = 4;
  bool has_homescreen() const;
  private:
  bool _internal_has_homescreen() const;
  public:
  void clear_homescreen();
  const std::string& homescreen() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_homescreen(ArgT0&& arg0, ArgT... args);
  std::string* mutable_homescreen();
  PROTOBUF_NODISCARD std::string* release_homescreen();
  void set_allocated_homescreen(std::string* homescreen);
  private:
  const std::string& _internal_homescreen() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_homescreen(const std::string& value);
  std::string* _internal_mutable_homescreen();
  public:

  // optional uint32 _passphrase_source = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has__passphrase_source() const;
  private:
  bool _internal_has__passphrase_source() const;
  public:
  PROTOBUF_DEPRECATED void clear__passphrase_source();
  PROTOBUF_DEPRECATED uint32_t _passphrase_source() const;
  PROTOBUF_DEPRECATED void set__passphrase_source(uint32_t value);
  private:
  uint32_t _internal__passphrase_source() const;
  void _internal_set__passphrase_source(uint32_t value);
  public:

  // optional uint32 auto_lock_delay_ms = 6;
  bool has_auto_lock_delay_ms() const;
  private:
  bool _internal_has_auto_lock_delay_ms() const;
  public:
  void clear_auto_lock_delay_ms();
  uint32_t auto_lock_delay_ms() const;
  void set_auto_lock_delay_ms(uint32_t value);
  private:
  uint32_t _internal_auto_lock_delay_ms() const;
  void _internal_set_auto_lock_delay_ms(uint32_t value);
  public:

  // optional uint32 display_rotation = 7;
  bool has_display_rotation() const;
  private:
  bool _internal_has_display_rotation() const;
  public:
  void clear_display_rotation();
  uint32_t display_rotation() const;
  void set_display_rotation(uint32_t value);
  private:
  uint32_t _internal_display_rotation() const;
  void _internal_set_display_rotation(uint32_t value);
  public:

  // optional bool use_passphrase = 3;
  bool has_use_passphrase() const;
  private:
  bool _internal_has_use_passphrase() const;
  public:
  void clear_use_passphrase();
  bool use_passphrase() const;
  void set_use_passphrase(bool value);
  private:
  bool _internal_use_passphrase() const;
  void _internal_set_use_passphrase(bool value);
  public:

  // optional bool passphrase_always_on_device = 8;
  bool has_passphrase_always_on_device() const;
  private:
  bool _internal_has_passphrase_always_on_device() const;
  public:
  void clear_passphrase_always_on_device();
  bool passphrase_always_on_device() const;
  void set_passphrase_always_on_device(bool value);
  private:
  bool _internal_passphrase_always_on_device() const;
  void _internal_set_passphrase_always_on_device(bool value);
  public:

  // optional bool experimental_features = 10;
  bool has_experimental_features() const;
  private:
  bool _internal_has_experimental_features() const;
  public:
  void clear_experimental_features();
  bool experimental_features() const;
  void set_experimental_features(bool value);
  private:
  bool _internal_experimental_features() const;
  void _internal_set_experimental_features(bool value);
  public:

  // optional bool hide_passphrase_from_host = 11;
  bool has_hide_passphrase_from_host() const;
  private:
  bool _internal_has_hide_passphrase_from_host() const;
  public:
  void clear_hide_passphrase_from_host();
  bool hide_passphrase_from_host() const;
  void set_hide_passphrase_from_host(bool value);
  private:
  bool _internal_hide_passphrase_from_host() const;
  void _internal_set_hide_passphrase_from_host(bool value);
  public:

  // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;
  bool has_safety_checks() const;
  private:
  bool _internal_has_safety_checks() const;
  public:
  void clear_safety_checks();
  ::hw::trezor::messages::management::SafetyCheckLevel safety_checks() const;
  void set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value);
  private:
  ::hw::trezor::messages::management::SafetyCheckLevel _internal_safety_checks() const;
  void _internal_set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ApplySettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homescreen_;
    uint32_t _passphrase_source_;
    uint32_t auto_lock_delay_ms_;
    uint32_t display_rotation_;
    bool use_passphrase_;
    bool passphrase_always_on_device_;
    bool experimental_features_;
    bool hide_passphrase_from_host_;
    int safety_checks_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class ApplyFlags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.ApplyFlags) */ {
 public:
  inline ApplyFlags() : ApplyFlags(nullptr) {}
  ~ApplyFlags() override;
  explicit PROTOBUF_CONSTEXPR ApplyFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyFlags(const ApplyFlags& from);
  ApplyFlags(ApplyFlags&& from) noexcept
    : ApplyFlags() {
    *this = ::std::move(from);
  }

  inline ApplyFlags& operator=(const ApplyFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyFlags& operator=(ApplyFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyFlags* internal_default_instance() {
    return reinterpret_cast<const ApplyFlags*>(
               &_ApplyFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ApplyFlags& a, ApplyFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyFlags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyFlags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApplyFlags& from) {
    ApplyFlags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyFlags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.ApplyFlags";
  }
  protected:
  explicit ApplyFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagsFieldNumber = 1,
  };
  // required uint32 flags = 1;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ApplyFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class ChangePin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.ChangePin) */ {
 public:
  inline ChangePin() : ChangePin(nullptr) {}
  ~ChangePin() override;
  explicit PROTOBUF_CONSTEXPR ChangePin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangePin(const ChangePin& from);
  ChangePin(ChangePin&& from) noexcept
    : ChangePin() {
    *this = ::std::move(from);
  }

  inline ChangePin& operator=(const ChangePin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePin& operator=(ChangePin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePin& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePin* internal_default_instance() {
    return reinterpret_cast<const ChangePin*>(
               &_ChangePin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChangePin& a, ChangePin& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangePin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangePin& from) {
    ChangePin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.ChangePin";
  }
  protected:
  explicit ChangePin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoveFieldNumber = 1,
  };
  // optional bool remove = 1;
  bool has_remove() const;
  private:
  bool _internal_has_remove() const;
  public:
  void clear_remove();
  bool remove() const;
  void set_remove(bool value);
  private:
  bool _internal_remove() const;
  void _internal_set_remove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ChangePin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool remove_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class ChangeWipeCode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.ChangeWipeCode) */ {
 public:
  inline ChangeWipeCode() : ChangeWipeCode(nullptr) {}
  ~ChangeWipeCode() override;
  explicit PROTOBUF_CONSTEXPR ChangeWipeCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeWipeCode(const ChangeWipeCode& from);
  ChangeWipeCode(ChangeWipeCode&& from) noexcept
    : ChangeWipeCode() {
    *this = ::std::move(from);
  }

  inline ChangeWipeCode& operator=(const ChangeWipeCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeWipeCode& operator=(ChangeWipeCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeWipeCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeWipeCode* internal_default_instance() {
    return reinterpret_cast<const ChangeWipeCode*>(
               &_ChangeWipeCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ChangeWipeCode& a, ChangeWipeCode& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeWipeCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeWipeCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeWipeCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeWipeCode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeWipeCode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeWipeCode& from) {
    ChangeWipeCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeWipeCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.ChangeWipeCode";
  }
  protected:
  explicit ChangeWipeCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoveFieldNumber = 1,
  };
  // optional bool remove = 1;
  bool has_remove() const;
  private:
  bool _internal_has_remove() const;
  public:
  void clear_remove();
  bool remove() const;
  void set_remove(bool value);
  private:
  bool _internal_remove() const;
  void _internal_set_remove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ChangeWipeCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool remove_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class SdProtect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.SdProtect) */ {
 public:
  inline SdProtect() : SdProtect(nullptr) {}
  ~SdProtect() override;
  explicit PROTOBUF_CONSTEXPR SdProtect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SdProtect(const SdProtect& from);
  SdProtect(SdProtect&& from) noexcept
    : SdProtect() {
    *this = ::std::move(from);
  }

  inline SdProtect& operator=(const SdProtect& from) {
    CopyFrom(from);
    return *this;
  }
  inline SdProtect& operator=(SdProtect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SdProtect& default_instance() {
    return *internal_default_instance();
  }
  static inline const SdProtect* internal_default_instance() {
    return reinterpret_cast<const SdProtect*>(
               &_SdProtect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SdProtect& a, SdProtect& b) {
    a.Swap(&b);
  }
  inline void Swap(SdProtect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SdProtect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SdProtect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SdProtect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SdProtect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SdProtect& from) {
    SdProtect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SdProtect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.SdProtect";
  }
  protected:
  explicit SdProtect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SdProtect_SdProtectOperationType SdProtectOperationType;
  static constexpr SdProtectOperationType DISABLE =
    SdProtect_SdProtectOperationType_DISABLE;
  static constexpr SdProtectOperationType ENABLE =
    SdProtect_SdProtectOperationType_ENABLE;
  static constexpr SdProtectOperationType REFRESH =
    SdProtect_SdProtectOperationType_REFRESH;
  static inline bool SdProtectOperationType_IsValid(int value) {
    return SdProtect_SdProtectOperationType_IsValid(value);
  }
  static constexpr SdProtectOperationType SdProtectOperationType_MIN =
    SdProtect_SdProtectOperationType_SdProtectOperationType_MIN;
  static constexpr SdProtectOperationType SdProtectOperationType_MAX =
    SdProtect_SdProtectOperationType_SdProtectOperationType_MAX;
  static constexpr int SdProtectOperationType_ARRAYSIZE =
    SdProtect_SdProtectOperationType_SdProtectOperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SdProtectOperationType_descriptor() {
    return SdProtect_SdProtectOperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& SdProtectOperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SdProtectOperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SdProtectOperationType_Name.");
    return SdProtect_SdProtectOperationType_Name(enum_t_value);
  }
  static inline bool SdProtectOperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SdProtectOperationType* value) {
    return SdProtect_SdProtectOperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOperationFieldNumber = 1,
  };
  // required .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  ::hw::trezor::messages::management::SdProtect_SdProtectOperationType operation() const;
  void set_operation(::hw::trezor::messages::management::SdProtect_SdProtectOperationType value);
  private:
  ::hw::trezor::messages::management::SdProtect_SdProtectOperationType _internal_operation() const;
  void _internal_set_operation(::hw::trezor::messages::management::SdProtect_SdProtectOperationType value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.SdProtect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int operation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping& from) {
    Ping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kButtonProtectionFieldNumber = 2,
  };
  // optional string message = 1 [default = ""];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional bool button_protection = 2;
  bool has_button_protection() const;
  private:
  bool _internal_has_button_protection() const;
  public:
  void clear_button_protection();
  bool button_protection() const;
  void set_button_protection(bool value);
  private:
  bool _internal_button_protection() const;
  void _internal_set_button_protection(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool button_protection_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class Cancel final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.Cancel) */ {
 public:
  inline Cancel() : Cancel(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Cancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cancel(const Cancel& from);
  Cancel(Cancel&& from) noexcept
    : Cancel() {
    *this = ::std::move(from);
  }

  inline Cancel& operator=(const Cancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cancel& operator=(Cancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cancel* internal_default_instance() {
    return reinterpret_cast<const Cancel*>(
               &_Cancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Cancel& a, Cancel& b) {
    a.Swap(&b);
  }
  inline void Swap(Cancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Cancel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Cancel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.Cancel";
  }
  protected:
  explicit Cancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Cancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class GetEntropy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.GetEntropy) */ {
 public:
  inline GetEntropy() : GetEntropy(nullptr) {}
  ~GetEntropy() override;
  explicit PROTOBUF_CONSTEXPR GetEntropy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEntropy(const GetEntropy& from);
  GetEntropy(GetEntropy&& from) noexcept
    : GetEntropy() {
    *this = ::std::move(from);
  }

  inline GetEntropy& operator=(const GetEntropy& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEntropy& operator=(GetEntropy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEntropy& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEntropy* internal_default_instance() {
    return reinterpret_cast<const GetEntropy*>(
               &_GetEntropy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetEntropy& a, GetEntropy& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEntropy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEntropy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEntropy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEntropy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEntropy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEntropy& from) {
    GetEntropy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEntropy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.GetEntropy";
  }
  protected:
  explicit GetEntropy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // required uint32 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetEntropy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class Entropy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.Entropy) */ {
 public:
  inline Entropy() : Entropy(nullptr) {}
  ~Entropy() override;
  explicit PROTOBUF_CONSTEXPR Entropy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entropy(const Entropy& from);
  Entropy(Entropy&& from) noexcept
    : Entropy() {
    *this = ::std::move(from);
  }

  inline Entropy& operator=(const Entropy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entropy& operator=(Entropy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entropy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entropy* internal_default_instance() {
    return reinterpret_cast<const Entropy*>(
               &_Entropy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Entropy& a, Entropy& b) {
    a.Swap(&b);
  }
  inline void Swap(Entropy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entropy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entropy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entropy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entropy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Entropy& from) {
    Entropy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entropy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.Entropy";
  }
  protected:
  explicit Entropy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntropyFieldNumber = 1,
  };
  // required bytes entropy = 1;
  bool has_entropy() const;
  private:
  bool _internal_has_entropy() const;
  public:
  void clear_entropy();
  const std::string& entropy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entropy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entropy();
  PROTOBUF_NODISCARD std::string* release_entropy();
  void set_allocated_entropy(std::string* entropy);
  private:
  const std::string& _internal_entropy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entropy(const std::string& value);
  std::string* _internal_mutable_entropy();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Entropy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entropy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class GetFirmwareHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.GetFirmwareHash) */ {
 public:
  inline GetFirmwareHash() : GetFirmwareHash(nullptr) {}
  ~GetFirmwareHash() override;
  explicit PROTOBUF_CONSTEXPR GetFirmwareHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFirmwareHash(const GetFirmwareHash& from);
  GetFirmwareHash(GetFirmwareHash&& from) noexcept
    : GetFirmwareHash() {
    *this = ::std::move(from);
  }

  inline GetFirmwareHash& operator=(const GetFirmwareHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFirmwareHash& operator=(GetFirmwareHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFirmwareHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFirmwareHash* internal_default_instance() {
    return reinterpret_cast<const GetFirmwareHash*>(
               &_GetFirmwareHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetFirmwareHash& a, GetFirmwareHash& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFirmwareHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFirmwareHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFirmwareHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFirmwareHash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFirmwareHash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFirmwareHash& from) {
    GetFirmwareHash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFirmwareHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.GetFirmwareHash";
  }
  protected:
  explicit GetFirmwareHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChallengeFieldNumber = 1,
  };
  // optional bytes challenge = 1;
  bool has_challenge() const;
  private:
  bool _internal_has_challenge() const;
  public:
  void clear_challenge();
  const std::string& challenge() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_challenge(ArgT0&& arg0, ArgT... args);
  std::string* mutable_challenge();
  PROTOBUF_NODISCARD std::string* release_challenge();
  void set_allocated_challenge(std::string* challenge);
  private:
  const std::string& _internal_challenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_challenge(const std::string& value);
  std::string* _internal_mutable_challenge();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetFirmwareHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr challenge_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class FirmwareHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.FirmwareHash) */ {
 public:
  inline FirmwareHash() : FirmwareHash(nullptr) {}
  ~FirmwareHash() override;
  explicit PROTOBUF_CONSTEXPR FirmwareHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FirmwareHash(const FirmwareHash& from);
  FirmwareHash(FirmwareHash&& from) noexcept
    : FirmwareHash() {
    *this = ::std::move(from);
  }

  inline FirmwareHash& operator=(const FirmwareHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirmwareHash& operator=(FirmwareHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FirmwareHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const FirmwareHash* internal_default_instance() {
    return reinterpret_cast<const FirmwareHash*>(
               &_FirmwareHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FirmwareHash& a, FirmwareHash& b) {
    a.Swap(&b);
  }
  inline void Swap(FirmwareHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FirmwareHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FirmwareHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FirmwareHash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FirmwareHash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FirmwareHash& from) {
    FirmwareHash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirmwareHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.FirmwareHash";
  }
  protected:
  explicit FirmwareHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // required bytes hash = 1;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.FirmwareHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class WipeDevice final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.WipeDevice) */ {
 public:
  inline WipeDevice() : WipeDevice(nullptr) {}
  explicit PROTOBUF_CONSTEXPR WipeDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WipeDevice(const WipeDevice& from);
  WipeDevice(WipeDevice&& from) noexcept
    : WipeDevice() {
    *this = ::std::move(from);
  }

  inline WipeDevice& operator=(const WipeDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline WipeDevice& operator=(WipeDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WipeDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const WipeDevice* internal_default_instance() {
    return reinterpret_cast<const WipeDevice*>(
               &_WipeDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WipeDevice& a, WipeDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(WipeDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WipeDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WipeDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WipeDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const WipeDevice& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const WipeDevice& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.WipeDevice";
  }
  protected:
  explicit WipeDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.WipeDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class LoadDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.LoadDevice) */ {
 public:
  inline LoadDevice() : LoadDevice(nullptr) {}
  ~LoadDevice() override;
  explicit PROTOBUF_CONSTEXPR LoadDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadDevice(const LoadDevice& from);
  LoadDevice(LoadDevice&& from) noexcept
    : LoadDevice() {
    *this = ::std::move(from);
  }

  inline LoadDevice& operator=(const LoadDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadDevice& operator=(LoadDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadDevice* internal_default_instance() {
    return reinterpret_cast<const LoadDevice*>(
               &_LoadDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LoadDevice& a, LoadDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadDevice& from) {
    LoadDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.LoadDevice";
  }
  protected:
  explicit LoadDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMnemonicsFieldNumber = 1,
    kPinFieldNumber = 3,
    kLanguageFieldNumber = 5,
    kLabelFieldNumber = 6,
    kPassphraseProtectionFieldNumber = 4,
    kSkipChecksumFieldNumber = 7,
    kNeedsBackupFieldNumber = 9,
    kNoBackupFieldNumber = 10,
    kU2FCounterFieldNumber = 8,
  };
  // repeated string mnemonics = 1;
  int mnemonics_size() const;
  private:
  int _internal_mnemonics_size() const;
  public:
  void clear_mnemonics();
  const std::string& mnemonics(int index) const;
  std::string* mutable_mnemonics(int index);
  void set_mnemonics(int index, const std::string& value);
  void set_mnemonics(int index, std::string&& value);
  void set_mnemonics(int index, const char* value);
  void set_mnemonics(int index, const char* value, size_t size);
  std::string* add_mnemonics();
  void add_mnemonics(const std::string& value);
  void add_mnemonics(std::string&& value);
  void add_mnemonics(const char* value);
  void add_mnemonics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mnemonics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mnemonics();
  private:
  const std::string& _internal_mnemonics(int index) const;
  std::string* _internal_add_mnemonics();
  public:

  // optional string pin = 3;
  bool has_pin() const;
  private:
  bool _internal_has_pin() const;
  public:
  void clear_pin();
  const std::string& pin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pin();
  PROTOBUF_NODISCARD std::string* release_pin();
  void set_allocated_pin(std::string* pin);
  private:
  const std::string& _internal_pin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pin(const std::string& value);
  std::string* _internal_mutable_pin();
  public:

  // optional string language = 5 [default = "en-US"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string label = 6;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional bool passphrase_protection = 4;
  bool has_passphrase_protection() const;
  private:
  bool _internal_has_passphrase_protection() const;
  public:
  void clear_passphrase_protection();
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);
  private:
  bool _internal_passphrase_protection() const;
  void _internal_set_passphrase_protection(bool value);
  public:

  // optional bool skip_checksum = 7;
  bool has_skip_checksum() const;
  private:
  bool _internal_has_skip_checksum() const;
  public:
  void clear_skip_checksum();
  bool skip_checksum() const;
  void set_skip_checksum(bool value);
  private:
  bool _internal_skip_checksum() const;
  void _internal_set_skip_checksum(bool value);
  public:

  // optional bool needs_backup = 9;
  bool has_needs_backup() const;
  private:
  bool _internal_has_needs_backup() const;
  public:
  void clear_needs_backup();
  bool needs_backup() const;
  void set_needs_backup(bool value);
  private:
  bool _internal_needs_backup() const;
  void _internal_set_needs_backup(bool value);
  public:

  // optional bool no_backup = 10;
  bool has_no_backup() const;
  private:
  bool _internal_has_no_backup() const;
  public:
  void clear_no_backup();
  bool no_backup() const;
  void set_no_backup(bool value);
  private:
  bool _internal_no_backup() const;
  void _internal_set_no_backup(bool value);
  public:

  // optional uint32 u2f_counter = 8;
  bool has_u2f_counter() const;
  private:
  bool _internal_has_u2f_counter() const;
  public:
  void clear_u2f_counter();
  uint32_t u2f_counter() const;
  void set_u2f_counter(uint32_t value);
  private:
  uint32_t _internal_u2f_counter() const;
  void _internal_set_u2f_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.LoadDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mnemonics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pin_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    bool passphrase_protection_;
    bool skip_checksum_;
    bool needs_backup_;
    bool no_backup_;
    uint32_t u2f_counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class ResetDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.ResetDevice) */ {
 public:
  inline ResetDevice() : ResetDevice(nullptr) {}
  ~ResetDevice() override;
  explicit PROTOBUF_CONSTEXPR ResetDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetDevice(const ResetDevice& from);
  ResetDevice(ResetDevice&& from) noexcept
    : ResetDevice() {
    *this = ::std::move(from);
  }

  inline ResetDevice& operator=(const ResetDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetDevice& operator=(ResetDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetDevice* internal_default_instance() {
    return reinterpret_cast<const ResetDevice*>(
               &_ResetDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResetDevice& a, ResetDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetDevice& from) {
    ResetDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.ResetDevice";
  }
  protected:
  explicit ResetDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 5,
    kLabelFieldNumber = 6,
    kDisplayRandomFieldNumber = 1,
    kPassphraseProtectionFieldNumber = 3,
    kPinProtectionFieldNumber = 4,
    kSkipBackupFieldNumber = 8,
    kU2FCounterFieldNumber = 7,
    kNoBackupFieldNumber = 9,
    kBackupTypeFieldNumber = 10,
    kStrengthFieldNumber = 2,
  };
  // optional string language = 5 [default = "en-US"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string label = 6;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional bool display_random = 1;
  bool has_display_random() const;
  private:
  bool _internal_has_display_random() const;
  public:
  void clear_display_random();
  bool display_random() const;
  void set_display_random(bool value);
  private:
  bool _internal_display_random() const;
  void _internal_set_display_random(bool value);
  public:

  // optional bool passphrase_protection = 3;
  bool has_passphrase_protection() const;
  private:
  bool _internal_has_passphrase_protection() const;
  public:
  void clear_passphrase_protection();
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);
  private:
  bool _internal_passphrase_protection() const;
  void _internal_set_passphrase_protection(bool value);
  public:

  // optional bool pin_protection = 4;
  bool has_pin_protection() const;
  private:
  bool _internal_has_pin_protection() const;
  public:
  void clear_pin_protection();
  bool pin_protection() const;
  void set_pin_protection(bool value);
  private:
  bool _internal_pin_protection() const;
  void _internal_set_pin_protection(bool value);
  public:

  // optional bool skip_backup = 8;
  bool has_skip_backup() const;
  private:
  bool _internal_has_skip_backup() const;
  public:
  void clear_skip_backup();
  bool skip_backup() const;
  void set_skip_backup(bool value);
  private:
  bool _internal_skip_backup() const;
  void _internal_set_skip_backup(bool value);
  public:

  // optional uint32 u2f_counter = 7;
  bool has_u2f_counter() const;
  private:
  bool _internal_has_u2f_counter() const;
  public:
  void clear_u2f_counter();
  uint32_t u2f_counter() const;
  void set_u2f_counter(uint32_t value);
  private:
  uint32_t _internal_u2f_counter() const;
  void _internal_set_u2f_counter(uint32_t value);
  public:

  // optional bool no_backup = 9;
  bool has_no_backup() const;
  private:
  bool _internal_has_no_backup() const;
  public:
  void clear_no_backup();
  bool no_backup() const;
  void set_no_backup(bool value);
  private:
  bool _internal_no_backup() const;
  void _internal_set_no_backup(bool value);
  public:

  // optional .hw.trezor.messages.management.BackupType backup_type = 10 [default = Bip39];
  bool has_backup_type() const;
  private:
  bool _internal_has_backup_type() const;
  public:
  void clear_backup_type();
  ::hw::trezor::messages::management::BackupType backup_type() const;
  void set_backup_type(::hw::trezor::messages::management::BackupType value);
  private:
  ::hw::trezor::messages::management::BackupType _internal_backup_type() const;
  void _internal_set_backup_type(::hw::trezor::messages::management::BackupType value);
  public:

  // optional uint32 strength = 2 [default = 256];
  bool has_strength() const;
  private:
  bool _internal_has_strength() const;
  public:
  void clear_strength();
  uint32_t strength() const;
  void set_strength(uint32_t value);
  private:
  uint32_t _internal_strength() const;
  void _internal_set_strength(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ResetDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    bool display_random_;
    bool passphrase_protection_;
    bool pin_protection_;
    bool skip_backup_;
    uint32_t u2f_counter_;
    bool no_backup_;
    int backup_type_;
    uint32_t strength_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class BackupDevice final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.BackupDevice) */ {
 public:
  inline BackupDevice() : BackupDevice(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BackupDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackupDevice(const BackupDevice& from);
  BackupDevice(BackupDevice&& from) noexcept
    : BackupDevice() {
    *this = ::std::move(from);
  }

  inline BackupDevice& operator=(const BackupDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupDevice& operator=(BackupDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupDevice* internal_default_instance() {
    return reinterpret_cast<const BackupDevice*>(
               &_BackupDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BackupDevice& a, BackupDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(BackupDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackupDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackupDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BackupDevice& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BackupDevice& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.BackupDevice";
  }
  protected:
  explicit BackupDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.BackupDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class EntropyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.EntropyRequest) */ {
 public:
  inline EntropyRequest() : EntropyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EntropyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntropyRequest(const EntropyRequest& from);
  EntropyRequest(EntropyRequest&& from) noexcept
    : EntropyRequest() {
    *this = ::std::move(from);
  }

  inline EntropyRequest& operator=(const EntropyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntropyRequest& operator=(EntropyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntropyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntropyRequest* internal_default_instance() {
    return reinterpret_cast<const EntropyRequest*>(
               &_EntropyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EntropyRequest& a, EntropyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EntropyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntropyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntropyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntropyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EntropyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EntropyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.EntropyRequest";
  }
  protected:
  explicit EntropyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.EntropyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class EntropyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.EntropyAck) */ {
 public:
  inline EntropyAck() : EntropyAck(nullptr) {}
  ~EntropyAck() override;
  explicit PROTOBUF_CONSTEXPR EntropyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntropyAck(const EntropyAck& from);
  EntropyAck(EntropyAck&& from) noexcept
    : EntropyAck() {
    *this = ::std::move(from);
  }

  inline EntropyAck& operator=(const EntropyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntropyAck& operator=(EntropyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntropyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntropyAck* internal_default_instance() {
    return reinterpret_cast<const EntropyAck*>(
               &_EntropyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EntropyAck& a, EntropyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EntropyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntropyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntropyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntropyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntropyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntropyAck& from) {
    EntropyAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntropyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.EntropyAck";
  }
  protected:
  explicit EntropyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntropyFieldNumber = 1,
  };
  // required bytes entropy = 1;
  bool has_entropy() const;
  private:
  bool _internal_has_entropy() const;
  public:
  void clear_entropy();
  const std::string& entropy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entropy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entropy();
  PROTOBUF_NODISCARD std::string* release_entropy();
  void set_allocated_entropy(std::string* entropy);
  private:
  const std::string& _internal_entropy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entropy(const std::string& value);
  std::string* _internal_mutable_entropy();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.EntropyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entropy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class RecoveryDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.RecoveryDevice) */ {
 public:
  inline RecoveryDevice() : RecoveryDevice(nullptr) {}
  ~RecoveryDevice() override;
  explicit PROTOBUF_CONSTEXPR RecoveryDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoveryDevice(const RecoveryDevice& from);
  RecoveryDevice(RecoveryDevice&& from) noexcept
    : RecoveryDevice() {
    *this = ::std::move(from);
  }

  inline RecoveryDevice& operator=(const RecoveryDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoveryDevice& operator=(RecoveryDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoveryDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoveryDevice* internal_default_instance() {
    return reinterpret_cast<const RecoveryDevice*>(
               &_RecoveryDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RecoveryDevice& a, RecoveryDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoveryDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoveryDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoveryDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoveryDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecoveryDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecoveryDevice& from) {
    RecoveryDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoveryDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.RecoveryDevice";
  }
  protected:
  explicit RecoveryDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecoveryDevice_RecoveryDeviceType RecoveryDeviceType;
  static constexpr RecoveryDeviceType RecoveryDeviceType_ScrambledWords =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ScrambledWords;
  static constexpr RecoveryDeviceType RecoveryDeviceType_Matrix =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_Matrix;
  static inline bool RecoveryDeviceType_IsValid(int value) {
    return RecoveryDevice_RecoveryDeviceType_IsValid(value);
  }
  static constexpr RecoveryDeviceType RecoveryDeviceType_MIN =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MIN;
  static constexpr RecoveryDeviceType RecoveryDeviceType_MAX =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MAX;
  static constexpr int RecoveryDeviceType_ARRAYSIZE =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RecoveryDeviceType_descriptor() {
    return RecoveryDevice_RecoveryDeviceType_descriptor();
  }
  template<typename T>
  static inline const std::string& RecoveryDeviceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecoveryDeviceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecoveryDeviceType_Name.");
    return RecoveryDevice_RecoveryDeviceType_Name(enum_t_value);
  }
  static inline bool RecoveryDeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecoveryDeviceType* value) {
    return RecoveryDevice_RecoveryDeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 4,
    kLabelFieldNumber = 5,
    kWordCountFieldNumber = 1,
    kPassphraseProtectionFieldNumber = 2,
    kPinProtectionFieldNumber = 3,
    kEnforceWordlistFieldNumber = 6,
    kDryRunFieldNumber = 10,
    kTypeFieldNumber = 8,
    kU2FCounterFieldNumber = 9,
  };
  // optional string language = 4;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string label = 5;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional uint32 word_count = 1;
  bool has_word_count() const;
  private:
  bool _internal_has_word_count() const;
  public:
  void clear_word_count();
  uint32_t word_count() const;
  void set_word_count(uint32_t value);
  private:
  uint32_t _internal_word_count() const;
  void _internal_set_word_count(uint32_t value);
  public:

  // optional bool passphrase_protection = 2;
  bool has_passphrase_protection() const;
  private:
  bool _internal_has_passphrase_protection() const;
  public:
  void clear_passphrase_protection();
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);
  private:
  bool _internal_passphrase_protection() const;
  void _internal_set_passphrase_protection(bool value);
  public:

  // optional bool pin_protection = 3;
  bool has_pin_protection() const;
  private:
  bool _internal_has_pin_protection() const;
  public:
  void clear_pin_protection();
  bool pin_protection() const;
  void set_pin_protection(bool value);
  private:
  bool _internal_pin_protection() const;
  void _internal_set_pin_protection(bool value);
  public:

  // optional bool enforce_wordlist = 6;
  bool has_enforce_wordlist() const;
  private:
  bool _internal_has_enforce_wordlist() const;
  public:
  void clear_enforce_wordlist();
  bool enforce_wordlist() const;
  void set_enforce_wordlist(bool value);
  private:
  bool _internal_enforce_wordlist() const;
  void _internal_set_enforce_wordlist(bool value);
  public:

  // optional bool dry_run = 10;
  bool has_dry_run() const;
  private:
  bool _internal_has_dry_run() const;
  public:
  void clear_dry_run();
  bool dry_run() const;
  void set_dry_run(bool value);
  private:
  bool _internal_dry_run() const;
  void _internal_set_dry_run(bool value);
  public:

  // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType type() const;
  void set_type(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType value);
  private:
  ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType _internal_type() const;
  void _internal_set_type(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType value);
  public:

  // optional uint32 u2f_counter = 9;
  bool has_u2f_counter() const;
  private:
  bool _internal_has_u2f_counter() const;
  public:
  void clear_u2f_counter();
  uint32_t u2f_counter() const;
  void set_u2f_counter(uint32_t value);
  private:
  uint32_t _internal_u2f_counter() const;
  void _internal_set_u2f_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.RecoveryDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    uint32_t word_count_;
    bool passphrase_protection_;
    bool pin_protection_;
    bool enforce_wordlist_;
    bool dry_run_;
    int type_;
    uint32_t u2f_counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class WordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.WordRequest) */ {
 public:
  inline WordRequest() : WordRequest(nullptr) {}
  ~WordRequest() override;
  explicit PROTOBUF_CONSTEXPR WordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WordRequest(const WordRequest& from);
  WordRequest(WordRequest&& from) noexcept
    : WordRequest() {
    *this = ::std::move(from);
  }

  inline WordRequest& operator=(const WordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WordRequest& operator=(WordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WordRequest* internal_default_instance() {
    return reinterpret_cast<const WordRequest*>(
               &_WordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WordRequest& a, WordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WordRequest& from) {
    WordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.WordRequest";
  }
  protected:
  explicit WordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WordRequest_WordRequestType WordRequestType;
  static constexpr WordRequestType WordRequestType_Plain =
    WordRequest_WordRequestType_WordRequestType_Plain;
  static constexpr WordRequestType WordRequestType_Matrix9 =
    WordRequest_WordRequestType_WordRequestType_Matrix9;
  static constexpr WordRequestType WordRequestType_Matrix6 =
    WordRequest_WordRequestType_WordRequestType_Matrix6;
  static inline bool WordRequestType_IsValid(int value) {
    return WordRequest_WordRequestType_IsValid(value);
  }
  static constexpr WordRequestType WordRequestType_MIN =
    WordRequest_WordRequestType_WordRequestType_MIN;
  static constexpr WordRequestType WordRequestType_MAX =
    WordRequest_WordRequestType_WordRequestType_MAX;
  static constexpr int WordRequestType_ARRAYSIZE =
    WordRequest_WordRequestType_WordRequestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WordRequestType_descriptor() {
    return WordRequest_WordRequestType_descriptor();
  }
  template<typename T>
  static inline const std::string& WordRequestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WordRequestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WordRequestType_Name.");
    return WordRequest_WordRequestType_Name(enum_t_value);
  }
  static inline bool WordRequestType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WordRequestType* value) {
    return WordRequest_WordRequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::hw::trezor::messages::management::WordRequest_WordRequestType type() const;
  void set_type(::hw::trezor::messages::management::WordRequest_WordRequestType value);
  private:
  ::hw::trezor::messages::management::WordRequest_WordRequestType _internal_type() const;
  void _internal_set_type(::hw::trezor::messages::management::WordRequest_WordRequestType value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.WordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class WordAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.WordAck) */ {
 public:
  inline WordAck() : WordAck(nullptr) {}
  ~WordAck() override;
  explicit PROTOBUF_CONSTEXPR WordAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WordAck(const WordAck& from);
  WordAck(WordAck&& from) noexcept
    : WordAck() {
    *this = ::std::move(from);
  }

  inline WordAck& operator=(const WordAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline WordAck& operator=(WordAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WordAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const WordAck* internal_default_instance() {
    return reinterpret_cast<const WordAck*>(
               &_WordAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WordAck& a, WordAck& b) {
    a.Swap(&b);
  }
  inline void Swap(WordAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WordAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WordAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WordAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WordAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WordAck& from) {
    WordAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WordAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.WordAck";
  }
  protected:
  explicit WordAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 1,
  };
  // required string word = 1;
  bool has_word() const;
  private:
  bool _internal_has_word() const;
  public:
  void clear_word();
  const std::string& word() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_word(ArgT0&& arg0, ArgT... args);
  std::string* mutable_word();
  PROTOBUF_NODISCARD std::string* release_word();
  void set_allocated_word(std::string* word);
  private:
  const std::string& _internal_word() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_word(const std::string& value);
  std::string* _internal_mutable_word();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.WordAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class SetU2FCounter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.SetU2FCounter) */ {
 public:
  inline SetU2FCounter() : SetU2FCounter(nullptr) {}
  ~SetU2FCounter() override;
  explicit PROTOBUF_CONSTEXPR SetU2FCounter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetU2FCounter(const SetU2FCounter& from);
  SetU2FCounter(SetU2FCounter&& from) noexcept
    : SetU2FCounter() {
    *this = ::std::move(from);
  }

  inline SetU2FCounter& operator=(const SetU2FCounter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetU2FCounter& operator=(SetU2FCounter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetU2FCounter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetU2FCounter* internal_default_instance() {
    return reinterpret_cast<const SetU2FCounter*>(
               &_SetU2FCounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetU2FCounter& a, SetU2FCounter& b) {
    a.Swap(&b);
  }
  inline void Swap(SetU2FCounter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetU2FCounter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetU2FCounter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetU2FCounter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetU2FCounter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetU2FCounter& from) {
    SetU2FCounter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetU2FCounter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.SetU2FCounter";
  }
  protected:
  explicit SetU2FCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU2FCounterFieldNumber = 1,
  };
  // required uint32 u2f_counter = 1;
  bool has_u2f_counter() const;
  private:
  bool _internal_has_u2f_counter() const;
  public:
  void clear_u2f_counter();
  uint32_t u2f_counter() const;
  void set_u2f_counter(uint32_t value);
  private:
  uint32_t _internal_u2f_counter() const;
  void _internal_set_u2f_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.SetU2FCounter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t u2f_counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class GetNextU2FCounter final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.GetNextU2FCounter) */ {
 public:
  inline GetNextU2FCounter() : GetNextU2FCounter(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetNextU2FCounter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNextU2FCounter(const GetNextU2FCounter& from);
  GetNextU2FCounter(GetNextU2FCounter&& from) noexcept
    : GetNextU2FCounter() {
    *this = ::std::move(from);
  }

  inline GetNextU2FCounter& operator=(const GetNextU2FCounter& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNextU2FCounter& operator=(GetNextU2FCounter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNextU2FCounter& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNextU2FCounter* internal_default_instance() {
    return reinterpret_cast<const GetNextU2FCounter*>(
               &_GetNextU2FCounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetNextU2FCounter& a, GetNextU2FCounter& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNextU2FCounter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNextU2FCounter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNextU2FCounter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNextU2FCounter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetNextU2FCounter& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetNextU2FCounter& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.GetNextU2FCounter";
  }
  protected:
  explicit GetNextU2FCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetNextU2FCounter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class NextU2FCounter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.NextU2FCounter) */ {
 public:
  inline NextU2FCounter() : NextU2FCounter(nullptr) {}
  ~NextU2FCounter() override;
  explicit PROTOBUF_CONSTEXPR NextU2FCounter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextU2FCounter(const NextU2FCounter& from);
  NextU2FCounter(NextU2FCounter&& from) noexcept
    : NextU2FCounter() {
    *this = ::std::move(from);
  }

  inline NextU2FCounter& operator=(const NextU2FCounter& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextU2FCounter& operator=(NextU2FCounter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextU2FCounter& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextU2FCounter* internal_default_instance() {
    return reinterpret_cast<const NextU2FCounter*>(
               &_NextU2FCounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(NextU2FCounter& a, NextU2FCounter& b) {
    a.Swap(&b);
  }
  inline void Swap(NextU2FCounter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextU2FCounter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextU2FCounter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextU2FCounter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextU2FCounter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextU2FCounter& from) {
    NextU2FCounter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextU2FCounter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.NextU2FCounter";
  }
  protected:
  explicit NextU2FCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kU2FCounterFieldNumber = 1,
  };
  // required uint32 u2f_counter = 1;
  bool has_u2f_counter() const;
  private:
  bool _internal_has_u2f_counter() const;
  public:
  void clear_u2f_counter();
  uint32_t u2f_counter() const;
  void set_u2f_counter(uint32_t value);
  private:
  uint32_t _internal_u2f_counter() const;
  void _internal_set_u2f_counter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.NextU2FCounter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t u2f_counter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class DoPreauthorized final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.DoPreauthorized) */ {
 public:
  inline DoPreauthorized() : DoPreauthorized(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DoPreauthorized(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoPreauthorized(const DoPreauthorized& from);
  DoPreauthorized(DoPreauthorized&& from) noexcept
    : DoPreauthorized() {
    *this = ::std::move(from);
  }

  inline DoPreauthorized& operator=(const DoPreauthorized& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoPreauthorized& operator=(DoPreauthorized&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoPreauthorized& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoPreauthorized* internal_default_instance() {
    return reinterpret_cast<const DoPreauthorized*>(
               &_DoPreauthorized_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DoPreauthorized& a, DoPreauthorized& b) {
    a.Swap(&b);
  }
  inline void Swap(DoPreauthorized* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoPreauthorized* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoPreauthorized* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoPreauthorized>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DoPreauthorized& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DoPreauthorized& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.DoPreauthorized";
  }
  protected:
  explicit DoPreauthorized(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.DoPreauthorized)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class PreauthorizedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.PreauthorizedRequest) */ {
 public:
  inline PreauthorizedRequest() : PreauthorizedRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PreauthorizedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreauthorizedRequest(const PreauthorizedRequest& from);
  PreauthorizedRequest(PreauthorizedRequest&& from) noexcept
    : PreauthorizedRequest() {
    *this = ::std::move(from);
  }

  inline PreauthorizedRequest& operator=(const PreauthorizedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreauthorizedRequest& operator=(PreauthorizedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreauthorizedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreauthorizedRequest* internal_default_instance() {
    return reinterpret_cast<const PreauthorizedRequest*>(
               &_PreauthorizedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(PreauthorizedRequest& a, PreauthorizedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PreauthorizedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreauthorizedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreauthorizedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreauthorizedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PreauthorizedRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PreauthorizedRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.PreauthorizedRequest";
  }
  protected:
  explicit PreauthorizedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.PreauthorizedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class CancelAuthorization final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.CancelAuthorization) */ {
 public:
  inline CancelAuthorization() : CancelAuthorization(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CancelAuthorization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelAuthorization(const CancelAuthorization& from);
  CancelAuthorization(CancelAuthorization&& from) noexcept
    : CancelAuthorization() {
    *this = ::std::move(from);
  }

  inline CancelAuthorization& operator=(const CancelAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelAuthorization& operator=(CancelAuthorization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelAuthorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelAuthorization* internal_default_instance() {
    return reinterpret_cast<const CancelAuthorization*>(
               &_CancelAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CancelAuthorization& a, CancelAuthorization& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelAuthorization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelAuthorization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelAuthorization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelAuthorization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelAuthorization& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelAuthorization& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.CancelAuthorization";
  }
  protected:
  explicit CancelAuthorization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.CancelAuthorization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class RebootToBootloader final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.RebootToBootloader) */ {
 public:
  inline RebootToBootloader() : RebootToBootloader(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RebootToBootloader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RebootToBootloader(const RebootToBootloader& from);
  RebootToBootloader(RebootToBootloader&& from) noexcept
    : RebootToBootloader() {
    *this = ::std::move(from);
  }

  inline RebootToBootloader& operator=(const RebootToBootloader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RebootToBootloader& operator=(RebootToBootloader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RebootToBootloader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RebootToBootloader* internal_default_instance() {
    return reinterpret_cast<const RebootToBootloader*>(
               &_RebootToBootloader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RebootToBootloader& a, RebootToBootloader& b) {
    a.Swap(&b);
  }
  inline void Swap(RebootToBootloader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RebootToBootloader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RebootToBootloader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RebootToBootloader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RebootToBootloader& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RebootToBootloader& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.RebootToBootloader";
  }
  protected:
  explicit RebootToBootloader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.RebootToBootloader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class GetNonce final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.GetNonce) */ {
 public:
  inline GetNonce() : GetNonce(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetNonce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNonce(const GetNonce& from);
  GetNonce(GetNonce&& from) noexcept
    : GetNonce() {
    *this = ::std::move(from);
  }

  inline GetNonce& operator=(const GetNonce& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNonce& operator=(GetNonce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNonce& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNonce* internal_default_instance() {
    return reinterpret_cast<const GetNonce*>(
               &_GetNonce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetNonce& a, GetNonce& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNonce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNonce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNonce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNonce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetNonce& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetNonce& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.GetNonce";
  }
  protected:
  explicit GetNonce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetNonce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class Nonce final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.Nonce) */ {
 public:
  inline Nonce() : Nonce(nullptr) {}
  ~Nonce() override;
  explicit PROTOBUF_CONSTEXPR Nonce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Nonce(const Nonce& from);
  Nonce(Nonce&& from) noexcept
    : Nonce() {
    *this = ::std::move(from);
  }

  inline Nonce& operator=(const Nonce& from) {
    CopyFrom(from);
    return *this;
  }
  inline Nonce& operator=(Nonce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Nonce& default_instance() {
    return *internal_default_instance();
  }
  static inline const Nonce* internal_default_instance() {
    return reinterpret_cast<const Nonce*>(
               &_Nonce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Nonce& a, Nonce& b) {
    a.Swap(&b);
  }
  inline void Swap(Nonce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Nonce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Nonce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Nonce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Nonce& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Nonce& from) {
    Nonce::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nonce* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.Nonce";
  }
  protected:
  explicit Nonce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
  };
  // required bytes nonce = 1;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Nonce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class UnlockPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.UnlockPath) */ {
 public:
  inline UnlockPath() : UnlockPath(nullptr) {}
  ~UnlockPath() override;
  explicit PROTOBUF_CONSTEXPR UnlockPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockPath(const UnlockPath& from);
  UnlockPath(UnlockPath&& from) noexcept
    : UnlockPath() {
    *this = ::std::move(from);
  }

  inline UnlockPath& operator=(const UnlockPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockPath& operator=(UnlockPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockPath* internal_default_instance() {
    return reinterpret_cast<const UnlockPath*>(
               &_UnlockPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UnlockPath& a, UnlockPath& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockPath& from) {
    UnlockPath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.UnlockPath";
  }
  protected:
  explicit UnlockPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 1,
    kMacFieldNumber = 2,
  };
  // repeated uint32 address_n = 1;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // optional bytes mac = 2;
  bool has_mac() const;
  private:
  bool _internal_has_mac() const;
  public:
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.UnlockPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// -------------------------------------------------------------------

class UnlockedPathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.management.UnlockedPathRequest) */ {
 public:
  inline UnlockedPathRequest() : UnlockedPathRequest(nullptr) {}
  ~UnlockedPathRequest() override;
  explicit PROTOBUF_CONSTEXPR UnlockedPathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockedPathRequest(const UnlockedPathRequest& from);
  UnlockedPathRequest(UnlockedPathRequest&& from) noexcept
    : UnlockedPathRequest() {
    *this = ::std::move(from);
  }

  inline UnlockedPathRequest& operator=(const UnlockedPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockedPathRequest& operator=(UnlockedPathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockedPathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockedPathRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockedPathRequest*>(
               &_UnlockedPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UnlockedPathRequest& a, UnlockedPathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockedPathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockedPathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockedPathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockedPathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockedPathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockedPathRequest& from) {
    UnlockedPathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockedPathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.management.UnlockedPathRequest";
  }
  protected:
  explicit UnlockedPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 1,
  };
  // optional bytes mac = 1;
  bool has_mac() const;
  private:
  bool _internal_has_mac() const;
  public:
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.UnlockedPathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmanagement_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Initialize

// optional bytes session_id = 1;
inline bool Initialize::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Initialize::has_session_id() const {
  return _internal_has_session_id();
}
inline void Initialize::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Initialize::session_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Initialize.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Initialize::set_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.session_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Initialize.session_id)
}
inline std::string* Initialize::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Initialize.session_id)
  return _s;
}
inline const std::string& Initialize::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void Initialize::_internal_set_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Initialize::_internal_mutable_session_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Initialize::release_session_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Initialize.session_id)
  if (!_internal_has_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Initialize::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Initialize.session_id)
}

// optional bool _skip_passphrase = 2 [deprecated = true];
inline bool Initialize::_internal_has__skip_passphrase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Initialize::has__skip_passphrase() const {
  return _internal_has__skip_passphrase();
}
inline void Initialize::clear__skip_passphrase() {
  _impl_._skip_passphrase_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Initialize::_internal__skip_passphrase() const {
  return _impl_._skip_passphrase_;
}
inline bool Initialize::_skip_passphrase() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Initialize._skip_passphrase)
  return _internal__skip_passphrase();
}
inline void Initialize::_internal_set__skip_passphrase(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_._skip_passphrase_ = value;
}
inline void Initialize::set__skip_passphrase(bool value) {
  _internal_set__skip_passphrase(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Initialize._skip_passphrase)
}

// optional bool derive_cardano = 3;
inline bool Initialize::_internal_has_derive_cardano() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Initialize::has_derive_cardano() const {
  return _internal_has_derive_cardano();
}
inline void Initialize::clear_derive_cardano() {
  _impl_.derive_cardano_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Initialize::_internal_derive_cardano() const {
  return _impl_.derive_cardano_;
}
inline bool Initialize::derive_cardano() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Initialize.derive_cardano)
  return _internal_derive_cardano();
}
inline void Initialize::_internal_set_derive_cardano(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.derive_cardano_ = value;
}
inline void Initialize::set_derive_cardano(bool value) {
  _internal_set_derive_cardano(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Initialize.derive_cardano)
}

// -------------------------------------------------------------------

// GetFeatures

// -------------------------------------------------------------------

// Features

// optional string vendor = 1;
inline bool Features::_internal_has_vendor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Features::has_vendor() const {
  return _internal_has_vendor();
}
inline void Features::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Features::vendor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_vendor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.vendor)
}
inline std::string* Features::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.vendor)
  return _s;
}
inline const std::string& Features::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void Features::_internal_set_vendor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_vendor() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_vendor() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.vendor)
  if (!_internal_has_vendor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vendor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.vendor)
}

// required uint32 major_version = 2;
inline bool Features::_internal_has_major_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Features::has_major_version() const {
  return _internal_has_major_version();
}
inline void Features::clear_major_version() {
  _impl_.major_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t Features::_internal_major_version() const {
  return _impl_.major_version_;
}
inline uint32_t Features::major_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.major_version)
  return _internal_major_version();
}
inline void Features::_internal_set_major_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.major_version_ = value;
}
inline void Features::set_major_version(uint32_t value) {
  _internal_set_major_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.major_version)
}

// required uint32 minor_version = 3;
inline bool Features::_internal_has_minor_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Features::has_minor_version() const {
  return _internal_has_minor_version();
}
inline void Features::clear_minor_version() {
  _impl_.minor_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t Features::_internal_minor_version() const {
  return _impl_.minor_version_;
}
inline uint32_t Features::minor_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.minor_version)
  return _internal_minor_version();
}
inline void Features::_internal_set_minor_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.minor_version_ = value;
}
inline void Features::set_minor_version(uint32_t value) {
  _internal_set_minor_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.minor_version)
}

// required uint32 patch_version = 4;
inline bool Features::_internal_has_patch_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Features::has_patch_version() const {
  return _internal_has_patch_version();
}
inline void Features::clear_patch_version() {
  _impl_.patch_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t Features::_internal_patch_version() const {
  return _impl_.patch_version_;
}
inline uint32_t Features::patch_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.patch_version)
  return _internal_patch_version();
}
inline void Features::_internal_set_patch_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.patch_version_ = value;
}
inline void Features::set_patch_version(uint32_t value) {
  _internal_set_patch_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.patch_version)
}

// optional bool bootloader_mode = 5;
inline bool Features::_internal_has_bootloader_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Features::has_bootloader_mode() const {
  return _internal_has_bootloader_mode();
}
inline void Features::clear_bootloader_mode() {
  _impl_.bootloader_mode_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Features::_internal_bootloader_mode() const {
  return _impl_.bootloader_mode_;
}
inline bool Features::bootloader_mode() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.bootloader_mode)
  return _internal_bootloader_mode();
}
inline void Features::_internal_set_bootloader_mode(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.bootloader_mode_ = value;
}
inline void Features::set_bootloader_mode(bool value) {
  _internal_set_bootloader_mode(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.bootloader_mode)
}

// optional string device_id = 6;
inline bool Features::_internal_has_device_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Features::has_device_id() const {
  return _internal_has_device_id();
}
inline void Features::clear_device_id() {
  _impl_.device_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Features::device_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_device_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.device_id)
}
inline std::string* Features::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.device_id)
  return _s;
}
inline const std::string& Features::_internal_device_id() const {
  return _impl_.device_id_.Get();
}
inline void Features::_internal_set_device_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_device_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_device_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.device_id)
  if (!_internal_has_device_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_id_.IsDefault()) {
    _impl_.device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.device_id)
}

// optional bool pin_protection = 7;
inline bool Features::_internal_has_pin_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Features::has_pin_protection() const {
  return _internal_has_pin_protection();
}
inline void Features::clear_pin_protection() {
  _impl_.pin_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Features::_internal_pin_protection() const {
  return _impl_.pin_protection_;
}
inline bool Features::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.pin_protection)
  return _internal_pin_protection();
}
inline void Features::_internal_set_pin_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.pin_protection_ = value;
}
inline void Features::set_pin_protection(bool value) {
  _internal_set_pin_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.pin_protection)
}

// optional bool passphrase_protection = 8;
inline bool Features::_internal_has_passphrase_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Features::has_passphrase_protection() const {
  return _internal_has_passphrase_protection();
}
inline void Features::clear_passphrase_protection() {
  _impl_.passphrase_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Features::_internal_passphrase_protection() const {
  return _impl_.passphrase_protection_;
}
inline bool Features::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.passphrase_protection)
  return _internal_passphrase_protection();
}
inline void Features::_internal_set_passphrase_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.passphrase_protection_ = value;
}
inline void Features::set_passphrase_protection(bool value) {
  _internal_set_passphrase_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.passphrase_protection)
}

// optional string language = 9;
inline bool Features::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Features::has_language() const {
  return _internal_has_language();
}
inline void Features::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Features::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.language)
}
inline std::string* Features::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.language)
  return _s;
}
inline const std::string& Features::_internal_language() const {
  return _impl_.language_.Get();
}
inline void Features::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_language() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.language)
}

// optional string label = 10;
inline bool Features::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Features::has_label() const {
  return _internal_has_label();
}
inline void Features::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Features::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.label)
}
inline std::string* Features::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.label)
  return _s;
}
inline const std::string& Features::_internal_label() const {
  return _impl_.label_.Get();
}
inline void Features::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_label() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.label)
}

// optional bool initialized = 12;
inline bool Features::_internal_has_initialized() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Features::has_initialized() const {
  return _internal_has_initialized();
}
inline void Features::clear_initialized() {
  _impl_.initialized_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool Features::_internal_initialized() const {
  return _impl_.initialized_;
}
inline bool Features::initialized() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.initialized)
  return _internal_initialized();
}
inline void Features::_internal_set_initialized(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.initialized_ = value;
}
inline void Features::set_initialized(bool value) {
  _internal_set_initialized(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.initialized)
}

// optional bytes revision = 13;
inline bool Features::_internal_has_revision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Features::has_revision() const {
  return _internal_has_revision();
}
inline void Features::clear_revision() {
  _impl_.revision_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Features::revision() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_revision(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.revision_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.revision)
}
inline std::string* Features::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.revision)
  return _s;
}
inline const std::string& Features::_internal_revision() const {
  return _impl_.revision_.Get();
}
inline void Features::_internal_set_revision(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.revision_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_revision() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.revision_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_revision() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.revision)
  if (!_internal_has_revision()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.revision_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.revision_.IsDefault()) {
    _impl_.revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.revision_.SetAllocated(revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.revision_.IsDefault()) {
    _impl_.revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.revision)
}

// optional bytes bootloader_hash = 14;
inline bool Features::_internal_has_bootloader_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Features::has_bootloader_hash() const {
  return _internal_has_bootloader_hash();
}
inline void Features::clear_bootloader_hash() {
  _impl_.bootloader_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Features::bootloader_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.bootloader_hash)
  return _internal_bootloader_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_bootloader_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.bootloader_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.bootloader_hash)
}
inline std::string* Features::mutable_bootloader_hash() {
  std::string* _s = _internal_mutable_bootloader_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.bootloader_hash)
  return _s;
}
inline const std::string& Features::_internal_bootloader_hash() const {
  return _impl_.bootloader_hash_.Get();
}
inline void Features::_internal_set_bootloader_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.bootloader_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_bootloader_hash() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.bootloader_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_bootloader_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.bootloader_hash)
  if (!_internal_has_bootloader_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.bootloader_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bootloader_hash_.IsDefault()) {
    _impl_.bootloader_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_bootloader_hash(std::string* bootloader_hash) {
  if (bootloader_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.bootloader_hash_.SetAllocated(bootloader_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bootloader_hash_.IsDefault()) {
    _impl_.bootloader_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.bootloader_hash)
}

// optional bool imported = 15;
inline bool Features::_internal_has_imported() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Features::has_imported() const {
  return _internal_has_imported();
}
inline void Features::clear_imported() {
  _impl_.imported_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool Features::_internal_imported() const {
  return _impl_.imported_;
}
inline bool Features::imported() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.imported)
  return _internal_imported();
}
inline void Features::_internal_set_imported(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.imported_ = value;
}
inline void Features::set_imported(bool value) {
  _internal_set_imported(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.imported)
}

// optional bool unlocked = 16;
inline bool Features::_internal_has_unlocked() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Features::has_unlocked() const {
  return _internal_has_unlocked();
}
inline void Features::clear_unlocked() {
  _impl_.unlocked_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool Features::_internal_unlocked() const {
  return _impl_.unlocked_;
}
inline bool Features::unlocked() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.unlocked)
  return _internal_unlocked();
}
inline void Features::_internal_set_unlocked(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.unlocked_ = value;
}
inline void Features::set_unlocked(bool value) {
  _internal_set_unlocked(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.unlocked)
}

// optional bool _passphrase_cached = 17 [deprecated = true];
inline bool Features::_internal_has__passphrase_cached() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Features::has__passphrase_cached() const {
  return _internal_has__passphrase_cached();
}
inline void Features::clear__passphrase_cached() {
  _impl_._passphrase_cached_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool Features::_internal__passphrase_cached() const {
  return _impl_._passphrase_cached_;
}
inline bool Features::_passphrase_cached() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features._passphrase_cached)
  return _internal__passphrase_cached();
}
inline void Features::_internal_set__passphrase_cached(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_._passphrase_cached_ = value;
}
inline void Features::set__passphrase_cached(bool value) {
  _internal_set__passphrase_cached(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features._passphrase_cached)
}

// optional bool firmware_present = 18;
inline bool Features::_internal_has_firmware_present() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Features::has_firmware_present() const {
  return _internal_has_firmware_present();
}
inline void Features::clear_firmware_present() {
  _impl_.firmware_present_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool Features::_internal_firmware_present() const {
  return _impl_.firmware_present_;
}
inline bool Features::firmware_present() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.firmware_present)
  return _internal_firmware_present();
}
inline void Features::_internal_set_firmware_present(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.firmware_present_ = value;
}
inline void Features::set_firmware_present(bool value) {
  _internal_set_firmware_present(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.firmware_present)
}

// optional bool needs_backup = 19;
inline bool Features::_internal_has_needs_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Features::has_needs_backup() const {
  return _internal_has_needs_backup();
}
inline void Features::clear_needs_backup() {
  _impl_.needs_backup_ = false;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline bool Features::_internal_needs_backup() const {
  return _impl_.needs_backup_;
}
inline bool Features::needs_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.needs_backup)
  return _internal_needs_backup();
}
inline void Features::_internal_set_needs_backup(bool value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.needs_backup_ = value;
}
inline void Features::set_needs_backup(bool value) {
  _internal_set_needs_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.needs_backup)
}

// optional uint32 flags = 20;
inline bool Features::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Features::has_flags() const {
  return _internal_has_flags();
}
inline void Features::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t Features::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t Features::flags() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.flags)
  return _internal_flags();
}
inline void Features::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.flags_ = value;
}
inline void Features::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.flags)
}

// optional string model = 21;
inline bool Features::_internal_has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Features::has_model() const {
  return _internal_has_model();
}
inline void Features::clear_model() {
  _impl_.model_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Features::model() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_model(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.model)
}
inline std::string* Features::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.model)
  return _s;
}
inline const std::string& Features::_internal_model() const {
  return _impl_.model_.Get();
}
inline void Features::_internal_set_model(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_model() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_model() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.model)
}

// optional uint32 fw_major = 22;
inline bool Features::_internal_has_fw_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Features::has_fw_major() const {
  return _internal_has_fw_major();
}
inline void Features::clear_fw_major() {
  _impl_.fw_major_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t Features::_internal_fw_major() const {
  return _impl_.fw_major_;
}
inline uint32_t Features::fw_major() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_major)
  return _internal_fw_major();
}
inline void Features::_internal_set_fw_major(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.fw_major_ = value;
}
inline void Features::set_fw_major(uint32_t value) {
  _internal_set_fw_major(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_major)
}

// optional uint32 fw_minor = 23;
inline bool Features::_internal_has_fw_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Features::has_fw_minor() const {
  return _internal_has_fw_minor();
}
inline void Features::clear_fw_minor() {
  _impl_.fw_minor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t Features::_internal_fw_minor() const {
  return _impl_.fw_minor_;
}
inline uint32_t Features::fw_minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_minor)
  return _internal_fw_minor();
}
inline void Features::_internal_set_fw_minor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.fw_minor_ = value;
}
inline void Features::set_fw_minor(uint32_t value) {
  _internal_set_fw_minor(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_minor)
}

// optional uint32 fw_patch = 24;
inline bool Features::_internal_has_fw_patch() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Features::has_fw_patch() const {
  return _internal_has_fw_patch();
}
inline void Features::clear_fw_patch() {
  _impl_.fw_patch_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t Features::_internal_fw_patch() const {
  return _impl_.fw_patch_;
}
inline uint32_t Features::fw_patch() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_patch)
  return _internal_fw_patch();
}
inline void Features::_internal_set_fw_patch(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.fw_patch_ = value;
}
inline void Features::set_fw_patch(uint32_t value) {
  _internal_set_fw_patch(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_patch)
}

// optional string fw_vendor = 25;
inline bool Features::_internal_has_fw_vendor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Features::has_fw_vendor() const {
  return _internal_has_fw_vendor();
}
inline void Features::clear_fw_vendor() {
  _impl_.fw_vendor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Features::fw_vendor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_vendor)
  return _internal_fw_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_fw_vendor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.fw_vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_vendor)
}
inline std::string* Features::mutable_fw_vendor() {
  std::string* _s = _internal_mutable_fw_vendor();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.fw_vendor)
  return _s;
}
inline const std::string& Features::_internal_fw_vendor() const {
  return _impl_.fw_vendor_.Get();
}
inline void Features::_internal_set_fw_vendor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fw_vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_fw_vendor() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.fw_vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_fw_vendor() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.fw_vendor)
  if (!_internal_has_fw_vendor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.fw_vendor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fw_vendor_.IsDefault()) {
    _impl_.fw_vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_fw_vendor(std::string* fw_vendor) {
  if (fw_vendor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.fw_vendor_.SetAllocated(fw_vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fw_vendor_.IsDefault()) {
    _impl_.fw_vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.fw_vendor)
}

// optional bool unfinished_backup = 27;
inline bool Features::_internal_has_unfinished_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Features::has_unfinished_backup() const {
  return _internal_has_unfinished_backup();
}
inline void Features::clear_unfinished_backup() {
  _impl_.unfinished_backup_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool Features::_internal_unfinished_backup() const {
  return _impl_.unfinished_backup_;
}
inline bool Features::unfinished_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.unfinished_backup)
  return _internal_unfinished_backup();
}
inline void Features::_internal_set_unfinished_backup(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.unfinished_backup_ = value;
}
inline void Features::set_unfinished_backup(bool value) {
  _internal_set_unfinished_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.unfinished_backup)
}

// optional bool no_backup = 28;
inline bool Features::_internal_has_no_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Features::has_no_backup() const {
  return _internal_has_no_backup();
}
inline void Features::clear_no_backup() {
  _impl_.no_backup_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool Features::_internal_no_backup() const {
  return _impl_.no_backup_;
}
inline bool Features::no_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.no_backup)
  return _internal_no_backup();
}
inline void Features::_internal_set_no_backup(bool value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.no_backup_ = value;
}
inline void Features::set_no_backup(bool value) {
  _internal_set_no_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.no_backup)
}

// optional bool recovery_mode = 29;
inline bool Features::_internal_has_recovery_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Features::has_recovery_mode() const {
  return _internal_has_recovery_mode();
}
inline void Features::clear_recovery_mode() {
  _impl_.recovery_mode_ = false;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool Features::_internal_recovery_mode() const {
  return _impl_.recovery_mode_;
}
inline bool Features::recovery_mode() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.recovery_mode)
  return _internal_recovery_mode();
}
inline void Features::_internal_set_recovery_mode(bool value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.recovery_mode_ = value;
}
inline void Features::set_recovery_mode(bool value) {
  _internal_set_recovery_mode(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.recovery_mode)
}

// repeated .hw.trezor.messages.management.Features.Capability capabilities = 30;
inline int Features::_internal_capabilities_size() const {
  return _impl_.capabilities_.size();
}
inline int Features::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void Features::clear_capabilities() {
  _impl_.capabilities_.Clear();
}
inline ::hw::trezor::messages::management::Features_Capability Features::_internal_capabilities(int index) const {
  return static_cast< ::hw::trezor::messages::management::Features_Capability >(_impl_.capabilities_.Get(index));
}
inline ::hw::trezor::messages::management::Features_Capability Features::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.capabilities)
  return _internal_capabilities(index);
}
inline void Features::set_capabilities(int index, ::hw::trezor::messages::management::Features_Capability value) {
  assert(::hw::trezor::messages::management::Features_Capability_IsValid(value));
  _impl_.capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.capabilities)
}
inline void Features::_internal_add_capabilities(::hw::trezor::messages::management::Features_Capability value) {
  assert(::hw::trezor::messages::management::Features_Capability_IsValid(value));
  _impl_.capabilities_.Add(value);
}
inline void Features::add_capabilities(::hw::trezor::messages::management::Features_Capability value) {
  _internal_add_capabilities(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.management.Features.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Features::capabilities() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.management.Features.capabilities)
  return _impl_.capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Features::_internal_mutable_capabilities() {
  return &_impl_.capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Features::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.management.Features.capabilities)
  return _internal_mutable_capabilities();
}

// optional .hw.trezor.messages.management.BackupType backup_type = 31;
inline bool Features::_internal_has_backup_type() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Features::has_backup_type() const {
  return _internal_has_backup_type();
}
inline void Features::clear_backup_type() {
  _impl_.backup_type_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::hw::trezor::messages::management::BackupType Features::_internal_backup_type() const {
  return static_cast< ::hw::trezor::messages::management::BackupType >(_impl_.backup_type_);
}
inline ::hw::trezor::messages::management::BackupType Features::backup_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.backup_type)
  return _internal_backup_type();
}
inline void Features::_internal_set_backup_type(::hw::trezor::messages::management::BackupType value) {
  assert(::hw::trezor::messages::management::BackupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.backup_type_ = value;
}
inline void Features::set_backup_type(::hw::trezor::messages::management::BackupType value) {
  _internal_set_backup_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.backup_type)
}

// optional bool sd_card_present = 32;
inline bool Features::_internal_has_sd_card_present() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Features::has_sd_card_present() const {
  return _internal_has_sd_card_present();
}
inline void Features::clear_sd_card_present() {
  _impl_.sd_card_present_ = false;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline bool Features::_internal_sd_card_present() const {
  return _impl_.sd_card_present_;
}
inline bool Features::sd_card_present() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.sd_card_present)
  return _internal_sd_card_present();
}
inline void Features::_internal_set_sd_card_present(bool value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.sd_card_present_ = value;
}
inline void Features::set_sd_card_present(bool value) {
  _internal_set_sd_card_present(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.sd_card_present)
}

// optional bool sd_protection = 33;
inline bool Features::_internal_has_sd_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Features::has_sd_protection() const {
  return _internal_has_sd_protection();
}
inline void Features::clear_sd_protection() {
  _impl_.sd_protection_ = false;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline bool Features::_internal_sd_protection() const {
  return _impl_.sd_protection_;
}
inline bool Features::sd_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.sd_protection)
  return _internal_sd_protection();
}
inline void Features::_internal_set_sd_protection(bool value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.sd_protection_ = value;
}
inline void Features::set_sd_protection(bool value) {
  _internal_set_sd_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.sd_protection)
}

// optional bool wipe_code_protection = 34;
inline bool Features::_internal_has_wipe_code_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool Features::has_wipe_code_protection() const {
  return _internal_has_wipe_code_protection();
}
inline void Features::clear_wipe_code_protection() {
  _impl_.wipe_code_protection_ = false;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline bool Features::_internal_wipe_code_protection() const {
  return _impl_.wipe_code_protection_;
}
inline bool Features::wipe_code_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.wipe_code_protection)
  return _internal_wipe_code_protection();
}
inline void Features::_internal_set_wipe_code_protection(bool value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.wipe_code_protection_ = value;
}
inline void Features::set_wipe_code_protection(bool value) {
  _internal_set_wipe_code_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.wipe_code_protection)
}

// optional bytes session_id = 35;
inline bool Features::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Features::has_session_id() const {
  return _internal_has_session_id();
}
inline void Features::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& Features::session_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.session_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.session_id)
}
inline std::string* Features::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.session_id)
  return _s;
}
inline const std::string& Features::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void Features::_internal_set_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_session_id() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_session_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Features.session_id)
  if (!_internal_has_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Features::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.session_id)
}

// optional bool passphrase_always_on_device = 36;
inline bool Features::_internal_has_passphrase_always_on_device() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool Features::has_passphrase_always_on_device() const {
  return _internal_has_passphrase_always_on_device();
}
inline void Features::clear_passphrase_always_on_device() {
  _impl_.passphrase_always_on_device_ = false;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool Features::_internal_passphrase_always_on_device() const {
  return _impl_.passphrase_always_on_device_;
}
inline bool Features::passphrase_always_on_device() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.passphrase_always_on_device)
  return _internal_passphrase_always_on_device();
}
inline void Features::_internal_set_passphrase_always_on_device(bool value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.passphrase_always_on_device_ = value;
}
inline void Features::set_passphrase_always_on_device(bool value) {
  _internal_set_passphrase_always_on_device(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.passphrase_always_on_device)
}

// optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;
inline bool Features::_internal_has_safety_checks() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool Features::has_safety_checks() const {
  return _internal_has_safety_checks();
}
inline void Features::clear_safety_checks() {
  _impl_.safety_checks_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline ::hw::trezor::messages::management::SafetyCheckLevel Features::_internal_safety_checks() const {
  return static_cast< ::hw::trezor::messages::management::SafetyCheckLevel >(_impl_.safety_checks_);
}
inline ::hw::trezor::messages::management::SafetyCheckLevel Features::safety_checks() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.safety_checks)
  return _internal_safety_checks();
}
inline void Features::_internal_set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value) {
  assert(::hw::trezor::messages::management::SafetyCheckLevel_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.safety_checks_ = value;
}
inline void Features::set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value) {
  _internal_set_safety_checks(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.safety_checks)
}

// optional uint32 auto_lock_delay_ms = 38;
inline bool Features::_internal_has_auto_lock_delay_ms() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool Features::has_auto_lock_delay_ms() const {
  return _internal_has_auto_lock_delay_ms();
}
inline void Features::clear_auto_lock_delay_ms() {
  _impl_.auto_lock_delay_ms_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t Features::_internal_auto_lock_delay_ms() const {
  return _impl_.auto_lock_delay_ms_;
}
inline uint32_t Features::auto_lock_delay_ms() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.auto_lock_delay_ms)
  return _internal_auto_lock_delay_ms();
}
inline void Features::_internal_set_auto_lock_delay_ms(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.auto_lock_delay_ms_ = value;
}
inline void Features::set_auto_lock_delay_ms(uint32_t value) {
  _internal_set_auto_lock_delay_ms(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.auto_lock_delay_ms)
}

// optional uint32 display_rotation = 39;
inline bool Features::_internal_has_display_rotation() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool Features::has_display_rotation() const {
  return _internal_has_display_rotation();
}
inline void Features::clear_display_rotation() {
  _impl_.display_rotation_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline uint32_t Features::_internal_display_rotation() const {
  return _impl_.display_rotation_;
}
inline uint32_t Features::display_rotation() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.display_rotation)
  return _internal_display_rotation();
}
inline void Features::_internal_set_display_rotation(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.display_rotation_ = value;
}
inline void Features::set_display_rotation(uint32_t value) {
  _internal_set_display_rotation(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.display_rotation)
}

// optional bool experimental_features = 40;
inline bool Features::_internal_has_experimental_features() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool Features::has_experimental_features() const {
  return _internal_has_experimental_features();
}
inline void Features::clear_experimental_features() {
  _impl_.experimental_features_ = false;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline bool Features::_internal_experimental_features() const {
  return _impl_.experimental_features_;
}
inline bool Features::experimental_features() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.experimental_features)
  return _internal_experimental_features();
}
inline void Features::_internal_set_experimental_features(bool value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.experimental_features_ = value;
}
inline void Features::set_experimental_features(bool value) {
  _internal_set_experimental_features(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.experimental_features)
}

// optional bool busy = 41;
inline bool Features::_internal_has_busy() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool Features::has_busy() const {
  return _internal_has_busy();
}
inline void Features::clear_busy() {
  _impl_.busy_ = false;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline bool Features::_internal_busy() const {
  return _impl_.busy_;
}
inline bool Features::busy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.busy)
  return _internal_busy();
}
inline void Features::_internal_set_busy(bool value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.busy_ = value;
}
inline void Features::set_busy(bool value) {
  _internal_set_busy(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.busy)
}

// optional .hw.trezor.messages.management.HomescreenFormat homescreen_format = 42;
inline bool Features::_internal_has_homescreen_format() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool Features::has_homescreen_format() const {
  return _internal_has_homescreen_format();
}
inline void Features::clear_homescreen_format() {
  _impl_.homescreen_format_ = 1;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline ::hw::trezor::messages::management::HomescreenFormat Features::_internal_homescreen_format() const {
  return static_cast< ::hw::trezor::messages::management::HomescreenFormat >(_impl_.homescreen_format_);
}
inline ::hw::trezor::messages::management::HomescreenFormat Features::homescreen_format() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.homescreen_format)
  return _internal_homescreen_format();
}
inline void Features::_internal_set_homescreen_format(::hw::trezor::messages::management::HomescreenFormat value) {
  assert(::hw::trezor::messages::management::HomescreenFormat_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.homescreen_format_ = value;
}
inline void Features::set_homescreen_format(::hw::trezor::messages::management::HomescreenFormat value) {
  _internal_set_homescreen_format(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.homescreen_format)
}

// optional bool hide_passphrase_from_host = 43;
inline bool Features::_internal_has_hide_passphrase_from_host() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool Features::has_hide_passphrase_from_host() const {
  return _internal_has_hide_passphrase_from_host();
}
inline void Features::clear_hide_passphrase_from_host() {
  _impl_.hide_passphrase_from_host_ = false;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline bool Features::_internal_hide_passphrase_from_host() const {
  return _impl_.hide_passphrase_from_host_;
}
inline bool Features::hide_passphrase_from_host() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.hide_passphrase_from_host)
  return _internal_hide_passphrase_from_host();
}
inline void Features::_internal_set_hide_passphrase_from_host(bool value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.hide_passphrase_from_host_ = value;
}
inline void Features::set_hide_passphrase_from_host(bool value) {
  _internal_set_hide_passphrase_from_host(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.hide_passphrase_from_host)
}

// -------------------------------------------------------------------

// LockDevice

// -------------------------------------------------------------------

// SetBusy

// optional uint32 expiry_ms = 1;
inline bool SetBusy::_internal_has_expiry_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetBusy::has_expiry_ms() const {
  return _internal_has_expiry_ms();
}
inline void SetBusy::clear_expiry_ms() {
  _impl_.expiry_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SetBusy::_internal_expiry_ms() const {
  return _impl_.expiry_ms_;
}
inline uint32_t SetBusy::expiry_ms() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.SetBusy.expiry_ms)
  return _internal_expiry_ms();
}
inline void SetBusy::_internal_set_expiry_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.expiry_ms_ = value;
}
inline void SetBusy::set_expiry_ms(uint32_t value) {
  _internal_set_expiry_ms(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.SetBusy.expiry_ms)
}

// -------------------------------------------------------------------

// EndSession

// -------------------------------------------------------------------

// ApplySettings

// optional string language = 1;
inline bool ApplySettings::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplySettings::has_language() const {
  return _internal_has_language();
}
inline void ApplySettings::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApplySettings::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplySettings::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.language)
}
inline std::string* ApplySettings::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ApplySettings.language)
  return _s;
}
inline const std::string& ApplySettings::_internal_language() const {
  return _impl_.language_.Get();
}
inline void ApplySettings::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplySettings::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplySettings::release_language() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.ApplySettings.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApplySettings::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ApplySettings.language)
}

// optional string label = 2;
inline bool ApplySettings::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplySettings::has_label() const {
  return _internal_has_label();
}
inline void ApplySettings::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ApplySettings::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplySettings::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.label)
}
inline std::string* ApplySettings::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ApplySettings.label)
  return _s;
}
inline const std::string& ApplySettings::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ApplySettings::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplySettings::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplySettings::release_label() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.ApplySettings.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApplySettings::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ApplySettings.label)
}

// optional bool use_passphrase = 3;
inline bool ApplySettings::_internal_has_use_passphrase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ApplySettings::has_use_passphrase() const {
  return _internal_has_use_passphrase();
}
inline void ApplySettings::clear_use_passphrase() {
  _impl_.use_passphrase_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ApplySettings::_internal_use_passphrase() const {
  return _impl_.use_passphrase_;
}
inline bool ApplySettings::use_passphrase() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.use_passphrase)
  return _internal_use_passphrase();
}
inline void ApplySettings::_internal_set_use_passphrase(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.use_passphrase_ = value;
}
inline void ApplySettings::set_use_passphrase(bool value) {
  _internal_set_use_passphrase(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.use_passphrase)
}

// optional bytes homescreen = 4;
inline bool ApplySettings::_internal_has_homescreen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApplySettings::has_homescreen() const {
  return _internal_has_homescreen();
}
inline void ApplySettings::clear_homescreen() {
  _impl_.homescreen_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ApplySettings::homescreen() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.homescreen)
  return _internal_homescreen();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApplySettings::set_homescreen(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.homescreen_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.homescreen)
}
inline std::string* ApplySettings::mutable_homescreen() {
  std::string* _s = _internal_mutable_homescreen();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ApplySettings.homescreen)
  return _s;
}
inline const std::string& ApplySettings::_internal_homescreen() const {
  return _impl_.homescreen_.Get();
}
inline void ApplySettings::_internal_set_homescreen(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.homescreen_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplySettings::_internal_mutable_homescreen() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.homescreen_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplySettings::release_homescreen() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.ApplySettings.homescreen)
  if (!_internal_has_homescreen()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.homescreen_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homescreen_.IsDefault()) {
    _impl_.homescreen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApplySettings::set_allocated_homescreen(std::string* homescreen) {
  if (homescreen != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.homescreen_.SetAllocated(homescreen, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homescreen_.IsDefault()) {
    _impl_.homescreen_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ApplySettings.homescreen)
}

// optional uint32 _passphrase_source = 5 [deprecated = true];
inline bool ApplySettings::_internal_has__passphrase_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApplySettings::has__passphrase_source() const {
  return _internal_has__passphrase_source();
}
inline void ApplySettings::clear__passphrase_source() {
  _impl_._passphrase_source_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ApplySettings::_internal__passphrase_source() const {
  return _impl_._passphrase_source_;
}
inline uint32_t ApplySettings::_passphrase_source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings._passphrase_source)
  return _internal__passphrase_source();
}
inline void ApplySettings::_internal_set__passphrase_source(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_._passphrase_source_ = value;
}
inline void ApplySettings::set__passphrase_source(uint32_t value) {
  _internal_set__passphrase_source(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings._passphrase_source)
}

// optional uint32 auto_lock_delay_ms = 6;
inline bool ApplySettings::_internal_has_auto_lock_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApplySettings::has_auto_lock_delay_ms() const {
  return _internal_has_auto_lock_delay_ms();
}
inline void ApplySettings::clear_auto_lock_delay_ms() {
  _impl_.auto_lock_delay_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ApplySettings::_internal_auto_lock_delay_ms() const {
  return _impl_.auto_lock_delay_ms_;
}
inline uint32_t ApplySettings::auto_lock_delay_ms() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.auto_lock_delay_ms)
  return _internal_auto_lock_delay_ms();
}
inline void ApplySettings::_internal_set_auto_lock_delay_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.auto_lock_delay_ms_ = value;
}
inline void ApplySettings::set_auto_lock_delay_ms(uint32_t value) {
  _internal_set_auto_lock_delay_ms(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.auto_lock_delay_ms)
}

// optional uint32 display_rotation = 7;
inline bool ApplySettings::_internal_has_display_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ApplySettings::has_display_rotation() const {
  return _internal_has_display_rotation();
}
inline void ApplySettings::clear_display_rotation() {
  _impl_.display_rotation_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ApplySettings::_internal_display_rotation() const {
  return _impl_.display_rotation_;
}
inline uint32_t ApplySettings::display_rotation() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.display_rotation)
  return _internal_display_rotation();
}
inline void ApplySettings::_internal_set_display_rotation(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.display_rotation_ = value;
}
inline void ApplySettings::set_display_rotation(uint32_t value) {
  _internal_set_display_rotation(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.display_rotation)
}

// optional bool passphrase_always_on_device = 8;
inline bool ApplySettings::_internal_has_passphrase_always_on_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ApplySettings::has_passphrase_always_on_device() const {
  return _internal_has_passphrase_always_on_device();
}
inline void ApplySettings::clear_passphrase_always_on_device() {
  _impl_.passphrase_always_on_device_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ApplySettings::_internal_passphrase_always_on_device() const {
  return _impl_.passphrase_always_on_device_;
}
inline bool ApplySettings::passphrase_always_on_device() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.passphrase_always_on_device)
  return _internal_passphrase_always_on_device();
}
inline void ApplySettings::_internal_set_passphrase_always_on_device(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.passphrase_always_on_device_ = value;
}
inline void ApplySettings::set_passphrase_always_on_device(bool value) {
  _internal_set_passphrase_always_on_device(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.passphrase_always_on_device)
}

// optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;
inline bool ApplySettings::_internal_has_safety_checks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ApplySettings::has_safety_checks() const {
  return _internal_has_safety_checks();
}
inline void ApplySettings::clear_safety_checks() {
  _impl_.safety_checks_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::hw::trezor::messages::management::SafetyCheckLevel ApplySettings::_internal_safety_checks() const {
  return static_cast< ::hw::trezor::messages::management::SafetyCheckLevel >(_impl_.safety_checks_);
}
inline ::hw::trezor::messages::management::SafetyCheckLevel ApplySettings::safety_checks() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.safety_checks)
  return _internal_safety_checks();
}
inline void ApplySettings::_internal_set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value) {
  assert(::hw::trezor::messages::management::SafetyCheckLevel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.safety_checks_ = value;
}
inline void ApplySettings::set_safety_checks(::hw::trezor::messages::management::SafetyCheckLevel value) {
  _internal_set_safety_checks(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.safety_checks)
}

// optional bool experimental_features = 10;
inline bool ApplySettings::_internal_has_experimental_features() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ApplySettings::has_experimental_features() const {
  return _internal_has_experimental_features();
}
inline void ApplySettings::clear_experimental_features() {
  _impl_.experimental_features_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ApplySettings::_internal_experimental_features() const {
  return _impl_.experimental_features_;
}
inline bool ApplySettings::experimental_features() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.experimental_features)
  return _internal_experimental_features();
}
inline void ApplySettings::_internal_set_experimental_features(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.experimental_features_ = value;
}
inline void ApplySettings::set_experimental_features(bool value) {
  _internal_set_experimental_features(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.experimental_features)
}

// optional bool hide_passphrase_from_host = 11;
inline bool ApplySettings::_internal_has_hide_passphrase_from_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ApplySettings::has_hide_passphrase_from_host() const {
  return _internal_has_hide_passphrase_from_host();
}
inline void ApplySettings::clear_hide_passphrase_from_host() {
  _impl_.hide_passphrase_from_host_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ApplySettings::_internal_hide_passphrase_from_host() const {
  return _impl_.hide_passphrase_from_host_;
}
inline bool ApplySettings::hide_passphrase_from_host() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.hide_passphrase_from_host)
  return _internal_hide_passphrase_from_host();
}
inline void ApplySettings::_internal_set_hide_passphrase_from_host(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.hide_passphrase_from_host_ = value;
}
inline void ApplySettings::set_hide_passphrase_from_host(bool value) {
  _internal_set_hide_passphrase_from_host(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.hide_passphrase_from_host)
}

// -------------------------------------------------------------------

// ApplyFlags

// required uint32 flags = 1;
inline bool ApplyFlags::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplyFlags::has_flags() const {
  return _internal_has_flags();
}
inline void ApplyFlags::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ApplyFlags::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t ApplyFlags::flags() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplyFlags.flags)
  return _internal_flags();
}
inline void ApplyFlags::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.flags_ = value;
}
inline void ApplyFlags::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplyFlags.flags)
}

// -------------------------------------------------------------------

// ChangePin

// optional bool remove = 1;
inline bool ChangePin::_internal_has_remove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangePin::has_remove() const {
  return _internal_has_remove();
}
inline void ChangePin::clear_remove() {
  _impl_.remove_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ChangePin::_internal_remove() const {
  return _impl_.remove_;
}
inline bool ChangePin::remove() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ChangePin.remove)
  return _internal_remove();
}
inline void ChangePin::_internal_set_remove(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remove_ = value;
}
inline void ChangePin::set_remove(bool value) {
  _internal_set_remove(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ChangePin.remove)
}

// -------------------------------------------------------------------

// ChangeWipeCode

// optional bool remove = 1;
inline bool ChangeWipeCode::_internal_has_remove() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeWipeCode::has_remove() const {
  return _internal_has_remove();
}
inline void ChangeWipeCode::clear_remove() {
  _impl_.remove_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ChangeWipeCode::_internal_remove() const {
  return _impl_.remove_;
}
inline bool ChangeWipeCode::remove() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ChangeWipeCode.remove)
  return _internal_remove();
}
inline void ChangeWipeCode::_internal_set_remove(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remove_ = value;
}
inline void ChangeWipeCode::set_remove(bool value) {
  _internal_set_remove(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ChangeWipeCode.remove)
}

// -------------------------------------------------------------------

// SdProtect

// required .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;
inline bool SdProtect::_internal_has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SdProtect::has_operation() const {
  return _internal_has_operation();
}
inline void SdProtect::clear_operation() {
  _impl_.operation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::hw::trezor::messages::management::SdProtect_SdProtectOperationType SdProtect::_internal_operation() const {
  return static_cast< ::hw::trezor::messages::management::SdProtect_SdProtectOperationType >(_impl_.operation_);
}
inline ::hw::trezor::messages::management::SdProtect_SdProtectOperationType SdProtect::operation() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.SdProtect.operation)
  return _internal_operation();
}
inline void SdProtect::_internal_set_operation(::hw::trezor::messages::management::SdProtect_SdProtectOperationType value) {
  assert(::hw::trezor::messages::management::SdProtect_SdProtectOperationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.operation_ = value;
}
inline void SdProtect::set_operation(::hw::trezor::messages::management::SdProtect_SdProtectOperationType value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.SdProtect.operation)
}

// -------------------------------------------------------------------

// Ping

// optional string message = 1 [default = ""];
inline bool Ping::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ping::has_message() const {
  return _internal_has_message();
}
inline void Ping::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Ping::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Ping.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Ping.message)
}
inline std::string* Ping::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Ping.message)
  return _s;
}
inline const std::string& Ping::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Ping::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Ping::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Ping.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Ping::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Ping.message)
}

// optional bool button_protection = 2;
inline bool Ping::_internal_has_button_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ping::has_button_protection() const {
  return _internal_has_button_protection();
}
inline void Ping::clear_button_protection() {
  _impl_.button_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Ping::_internal_button_protection() const {
  return _impl_.button_protection_;
}
inline bool Ping::button_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Ping.button_protection)
  return _internal_button_protection();
}
inline void Ping::_internal_set_button_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.button_protection_ = value;
}
inline void Ping::set_button_protection(bool value) {
  _internal_set_button_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Ping.button_protection)
}

// -------------------------------------------------------------------

// Cancel

// -------------------------------------------------------------------

// GetEntropy

// required uint32 size = 1;
inline bool GetEntropy::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetEntropy::has_size() const {
  return _internal_has_size();
}
inline void GetEntropy::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GetEntropy::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t GetEntropy::size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.GetEntropy.size)
  return _internal_size();
}
inline void GetEntropy::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void GetEntropy::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.GetEntropy.size)
}

// -------------------------------------------------------------------

// Entropy

// required bytes entropy = 1;
inline bool Entropy::_internal_has_entropy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Entropy::has_entropy() const {
  return _internal_has_entropy();
}
inline void Entropy::clear_entropy() {
  _impl_.entropy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Entropy::entropy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Entropy.entropy)
  return _internal_entropy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Entropy::set_entropy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.entropy_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Entropy.entropy)
}
inline std::string* Entropy::mutable_entropy() {
  std::string* _s = _internal_mutable_entropy();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Entropy.entropy)
  return _s;
}
inline const std::string& Entropy::_internal_entropy() const {
  return _impl_.entropy_.Get();
}
inline void Entropy::_internal_set_entropy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entropy_.Set(value, GetArenaForAllocation());
}
inline std::string* Entropy::_internal_mutable_entropy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entropy_.Mutable(GetArenaForAllocation());
}
inline std::string* Entropy::release_entropy() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Entropy.entropy)
  if (!_internal_has_entropy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.entropy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entropy_.IsDefault()) {
    _impl_.entropy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Entropy::set_allocated_entropy(std::string* entropy) {
  if (entropy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entropy_.SetAllocated(entropy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entropy_.IsDefault()) {
    _impl_.entropy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Entropy.entropy)
}

// -------------------------------------------------------------------

// GetFirmwareHash

// optional bytes challenge = 1;
inline bool GetFirmwareHash::_internal_has_challenge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetFirmwareHash::has_challenge() const {
  return _internal_has_challenge();
}
inline void GetFirmwareHash::clear_challenge() {
  _impl_.challenge_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetFirmwareHash::challenge() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.GetFirmwareHash.challenge)
  return _internal_challenge();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFirmwareHash::set_challenge(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.challenge_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.GetFirmwareHash.challenge)
}
inline std::string* GetFirmwareHash::mutable_challenge() {
  std::string* _s = _internal_mutable_challenge();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.GetFirmwareHash.challenge)
  return _s;
}
inline const std::string& GetFirmwareHash::_internal_challenge() const {
  return _impl_.challenge_.Get();
}
inline void GetFirmwareHash::_internal_set_challenge(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.challenge_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFirmwareHash::_internal_mutable_challenge() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.challenge_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFirmwareHash::release_challenge() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.GetFirmwareHash.challenge)
  if (!_internal_has_challenge()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.challenge_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.challenge_.IsDefault()) {
    _impl_.challenge_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetFirmwareHash::set_allocated_challenge(std::string* challenge) {
  if (challenge != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.challenge_.SetAllocated(challenge, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.challenge_.IsDefault()) {
    _impl_.challenge_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.GetFirmwareHash.challenge)
}

// -------------------------------------------------------------------

// FirmwareHash

// required bytes hash = 1;
inline bool FirmwareHash::_internal_has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FirmwareHash::has_hash() const {
  return _internal_has_hash();
}
inline void FirmwareHash::clear_hash() {
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FirmwareHash::hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.FirmwareHash.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FirmwareHash::set_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.FirmwareHash.hash)
}
inline std::string* FirmwareHash::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.FirmwareHash.hash)
  return _s;
}
inline const std::string& FirmwareHash::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void FirmwareHash::_internal_set_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* FirmwareHash::_internal_mutable_hash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* FirmwareHash::release_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.FirmwareHash.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FirmwareHash::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.FirmwareHash.hash)
}

// -------------------------------------------------------------------

// WipeDevice

// -------------------------------------------------------------------

// LoadDevice

// repeated string mnemonics = 1;
inline int LoadDevice::_internal_mnemonics_size() const {
  return _impl_.mnemonics_.size();
}
inline int LoadDevice::mnemonics_size() const {
  return _internal_mnemonics_size();
}
inline void LoadDevice::clear_mnemonics() {
  _impl_.mnemonics_.Clear();
}
inline std::string* LoadDevice::add_mnemonics() {
  std::string* _s = _internal_add_mnemonics();
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.management.LoadDevice.mnemonics)
  return _s;
}
inline const std::string& LoadDevice::_internal_mnemonics(int index) const {
  return _impl_.mnemonics_.Get(index);
}
inline const std::string& LoadDevice::mnemonics(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.mnemonics)
  return _internal_mnemonics(index);
}
inline std::string* LoadDevice::mutable_mnemonics(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.mnemonics)
  return _impl_.mnemonics_.Mutable(index);
}
inline void LoadDevice::set_mnemonics(int index, const std::string& value) {
  _impl_.mnemonics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline void LoadDevice::set_mnemonics(int index, std::string&& value) {
  _impl_.mnemonics_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline void LoadDevice::set_mnemonics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mnemonics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline void LoadDevice::set_mnemonics(int index, const char* value, size_t size) {
  _impl_.mnemonics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline std::string* LoadDevice::_internal_add_mnemonics() {
  return _impl_.mnemonics_.Add();
}
inline void LoadDevice::add_mnemonics(const std::string& value) {
  _impl_.mnemonics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline void LoadDevice::add_mnemonics(std::string&& value) {
  _impl_.mnemonics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline void LoadDevice::add_mnemonics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mnemonics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline void LoadDevice::add_mnemonics(const char* value, size_t size) {
  _impl_.mnemonics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.management.LoadDevice.mnemonics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoadDevice::mnemonics() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.management.LoadDevice.mnemonics)
  return _impl_.mnemonics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoadDevice::mutable_mnemonics() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.management.LoadDevice.mnemonics)
  return &_impl_.mnemonics_;
}

// optional string pin = 3;
inline bool LoadDevice::_internal_has_pin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoadDevice::has_pin() const {
  return _internal_has_pin();
}
inline void LoadDevice::clear_pin() {
  _impl_.pin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoadDevice::pin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.pin)
  return _internal_pin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadDevice::set_pin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.pin)
}
inline std::string* LoadDevice::mutable_pin() {
  std::string* _s = _internal_mutable_pin();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.pin)
  return _s;
}
inline const std::string& LoadDevice::_internal_pin() const {
  return _impl_.pin_.Get();
}
inline void LoadDevice::_internal_set_pin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pin_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadDevice::_internal_mutable_pin() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pin_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadDevice::release_pin() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.LoadDevice.pin)
  if (!_internal_has_pin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pin_.IsDefault()) {
    _impl_.pin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadDevice::set_allocated_pin(std::string* pin) {
  if (pin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pin_.SetAllocated(pin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pin_.IsDefault()) {
    _impl_.pin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.pin)
}

// optional bool passphrase_protection = 4;
inline bool LoadDevice::_internal_has_passphrase_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoadDevice::has_passphrase_protection() const {
  return _internal_has_passphrase_protection();
}
inline void LoadDevice::clear_passphrase_protection() {
  _impl_.passphrase_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool LoadDevice::_internal_passphrase_protection() const {
  return _impl_.passphrase_protection_;
}
inline bool LoadDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.passphrase_protection)
  return _internal_passphrase_protection();
}
inline void LoadDevice::_internal_set_passphrase_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.passphrase_protection_ = value;
}
inline void LoadDevice::set_passphrase_protection(bool value) {
  _internal_set_passphrase_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.passphrase_protection)
}

// optional string language = 5 [default = "en-US"];
inline bool LoadDevice::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoadDevice::has_language() const {
  return _internal_has_language();
}
inline void LoadDevice::clear_language() {
  _impl_.language_.ClearToDefault(::hw::trezor::messages::management::LoadDevice::Impl_::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoadDevice::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.language)
  if (_impl_.language_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_language_.get();
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadDevice::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.language)
}
inline std::string* LoadDevice::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.language)
  return _s;
}
inline const std::string& LoadDevice::_internal_language() const {
  return _impl_.language_.Get();
}
inline void LoadDevice::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadDevice::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.language_.Mutable(::hw::trezor::messages::management::LoadDevice::Impl_::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
}
inline std::string* LoadDevice::release_language() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.LoadDevice.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.language_.Release();
  return p;
}
inline void LoadDevice::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.language)
}

// optional string label = 6;
inline bool LoadDevice::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoadDevice::has_label() const {
  return _internal_has_label();
}
inline void LoadDevice::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoadDevice::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadDevice::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.label)
}
inline std::string* LoadDevice::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.label)
  return _s;
}
inline const std::string& LoadDevice::_internal_label() const {
  return _impl_.label_.Get();
}
inline void LoadDevice::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadDevice::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadDevice::release_label() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.LoadDevice.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadDevice::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.label)
}

// optional bool skip_checksum = 7;
inline bool LoadDevice::_internal_has_skip_checksum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoadDevice::has_skip_checksum() const {
  return _internal_has_skip_checksum();
}
inline void LoadDevice::clear_skip_checksum() {
  _impl_.skip_checksum_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool LoadDevice::_internal_skip_checksum() const {
  return _impl_.skip_checksum_;
}
inline bool LoadDevice::skip_checksum() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.skip_checksum)
  return _internal_skip_checksum();
}
inline void LoadDevice::_internal_set_skip_checksum(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.skip_checksum_ = value;
}
inline void LoadDevice::set_skip_checksum(bool value) {
  _internal_set_skip_checksum(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.skip_checksum)
}

// optional uint32 u2f_counter = 8;
inline bool LoadDevice::_internal_has_u2f_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LoadDevice::has_u2f_counter() const {
  return _internal_has_u2f_counter();
}
inline void LoadDevice::clear_u2f_counter() {
  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t LoadDevice::_internal_u2f_counter() const {
  return _impl_.u2f_counter_;
}
inline uint32_t LoadDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.u2f_counter)
  return _internal_u2f_counter();
}
inline void LoadDevice::_internal_set_u2f_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.u2f_counter_ = value;
}
inline void LoadDevice::set_u2f_counter(uint32_t value) {
  _internal_set_u2f_counter(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.u2f_counter)
}

// optional bool needs_backup = 9;
inline bool LoadDevice::_internal_has_needs_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoadDevice::has_needs_backup() const {
  return _internal_has_needs_backup();
}
inline void LoadDevice::clear_needs_backup() {
  _impl_.needs_backup_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool LoadDevice::_internal_needs_backup() const {
  return _impl_.needs_backup_;
}
inline bool LoadDevice::needs_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.needs_backup)
  return _internal_needs_backup();
}
inline void LoadDevice::_internal_set_needs_backup(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.needs_backup_ = value;
}
inline void LoadDevice::set_needs_backup(bool value) {
  _internal_set_needs_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.needs_backup)
}

// optional bool no_backup = 10;
inline bool LoadDevice::_internal_has_no_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LoadDevice::has_no_backup() const {
  return _internal_has_no_backup();
}
inline void LoadDevice::clear_no_backup() {
  _impl_.no_backup_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool LoadDevice::_internal_no_backup() const {
  return _impl_.no_backup_;
}
inline bool LoadDevice::no_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.no_backup)
  return _internal_no_backup();
}
inline void LoadDevice::_internal_set_no_backup(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.no_backup_ = value;
}
inline void LoadDevice::set_no_backup(bool value) {
  _internal_set_no_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.no_backup)
}

// -------------------------------------------------------------------

// ResetDevice

// optional bool display_random = 1;
inline bool ResetDevice::_internal_has_display_random() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResetDevice::has_display_random() const {
  return _internal_has_display_random();
}
inline void ResetDevice::clear_display_random() {
  _impl_.display_random_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ResetDevice::_internal_display_random() const {
  return _impl_.display_random_;
}
inline bool ResetDevice::display_random() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.display_random)
  return _internal_display_random();
}
inline void ResetDevice::_internal_set_display_random(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.display_random_ = value;
}
inline void ResetDevice::set_display_random(bool value) {
  _internal_set_display_random(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.display_random)
}

// optional uint32 strength = 2 [default = 256];
inline bool ResetDevice::_internal_has_strength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ResetDevice::has_strength() const {
  return _internal_has_strength();
}
inline void ResetDevice::clear_strength() {
  _impl_.strength_ = 256u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t ResetDevice::_internal_strength() const {
  return _impl_.strength_;
}
inline uint32_t ResetDevice::strength() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.strength)
  return _internal_strength();
}
inline void ResetDevice::_internal_set_strength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.strength_ = value;
}
inline void ResetDevice::set_strength(uint32_t value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.strength)
}

// optional bool passphrase_protection = 3;
inline bool ResetDevice::_internal_has_passphrase_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResetDevice::has_passphrase_protection() const {
  return _internal_has_passphrase_protection();
}
inline void ResetDevice::clear_passphrase_protection() {
  _impl_.passphrase_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ResetDevice::_internal_passphrase_protection() const {
  return _impl_.passphrase_protection_;
}
inline bool ResetDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.passphrase_protection)
  return _internal_passphrase_protection();
}
inline void ResetDevice::_internal_set_passphrase_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.passphrase_protection_ = value;
}
inline void ResetDevice::set_passphrase_protection(bool value) {
  _internal_set_passphrase_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.passphrase_protection)
}

// optional bool pin_protection = 4;
inline bool ResetDevice::_internal_has_pin_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResetDevice::has_pin_protection() const {
  return _internal_has_pin_protection();
}
inline void ResetDevice::clear_pin_protection() {
  _impl_.pin_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ResetDevice::_internal_pin_protection() const {
  return _impl_.pin_protection_;
}
inline bool ResetDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.pin_protection)
  return _internal_pin_protection();
}
inline void ResetDevice::_internal_set_pin_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pin_protection_ = value;
}
inline void ResetDevice::set_pin_protection(bool value) {
  _internal_set_pin_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.pin_protection)
}

// optional string language = 5 [default = "en-US"];
inline bool ResetDevice::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResetDevice::has_language() const {
  return _internal_has_language();
}
inline void ResetDevice::clear_language() {
  _impl_.language_.ClearToDefault(::hw::trezor::messages::management::ResetDevice::Impl_::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResetDevice::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.language)
  if (_impl_.language_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_language_.get();
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetDevice::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.language)
}
inline std::string* ResetDevice::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ResetDevice.language)
  return _s;
}
inline const std::string& ResetDevice::_internal_language() const {
  return _impl_.language_.Get();
}
inline void ResetDevice::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetDevice::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.language_.Mutable(::hw::trezor::messages::management::ResetDevice::Impl_::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
}
inline std::string* ResetDevice::release_language() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.ResetDevice.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.language_.Release();
  return p;
}
inline void ResetDevice::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ResetDevice.language)
}

// optional string label = 6;
inline bool ResetDevice::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResetDevice::has_label() const {
  return _internal_has_label();
}
inline void ResetDevice::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResetDevice::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetDevice::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.label)
}
inline std::string* ResetDevice::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ResetDevice.label)
  return _s;
}
inline const std::string& ResetDevice::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ResetDevice::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetDevice::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetDevice::release_label() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.ResetDevice.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResetDevice::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ResetDevice.label)
}

// optional uint32 u2f_counter = 7;
inline bool ResetDevice::_internal_has_u2f_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ResetDevice::has_u2f_counter() const {
  return _internal_has_u2f_counter();
}
inline void ResetDevice::clear_u2f_counter() {
  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ResetDevice::_internal_u2f_counter() const {
  return _impl_.u2f_counter_;
}
inline uint32_t ResetDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.u2f_counter)
  return _internal_u2f_counter();
}
inline void ResetDevice::_internal_set_u2f_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.u2f_counter_ = value;
}
inline void ResetDevice::set_u2f_counter(uint32_t value) {
  _internal_set_u2f_counter(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.u2f_counter)
}

// optional bool skip_backup = 8;
inline bool ResetDevice::_internal_has_skip_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ResetDevice::has_skip_backup() const {
  return _internal_has_skip_backup();
}
inline void ResetDevice::clear_skip_backup() {
  _impl_.skip_backup_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ResetDevice::_internal_skip_backup() const {
  return _impl_.skip_backup_;
}
inline bool ResetDevice::skip_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.skip_backup)
  return _internal_skip_backup();
}
inline void ResetDevice::_internal_set_skip_backup(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.skip_backup_ = value;
}
inline void ResetDevice::set_skip_backup(bool value) {
  _internal_set_skip_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.skip_backup)
}

// optional bool no_backup = 9;
inline bool ResetDevice::_internal_has_no_backup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ResetDevice::has_no_backup() const {
  return _internal_has_no_backup();
}
inline void ResetDevice::clear_no_backup() {
  _impl_.no_backup_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ResetDevice::_internal_no_backup() const {
  return _impl_.no_backup_;
}
inline bool ResetDevice::no_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.no_backup)
  return _internal_no_backup();
}
inline void ResetDevice::_internal_set_no_backup(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.no_backup_ = value;
}
inline void ResetDevice::set_no_backup(bool value) {
  _internal_set_no_backup(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.no_backup)
}

// optional .hw.trezor.messages.management.BackupType backup_type = 10 [default = Bip39];
inline bool ResetDevice::_internal_has_backup_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ResetDevice::has_backup_type() const {
  return _internal_has_backup_type();
}
inline void ResetDevice::clear_backup_type() {
  _impl_.backup_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::hw::trezor::messages::management::BackupType ResetDevice::_internal_backup_type() const {
  return static_cast< ::hw::trezor::messages::management::BackupType >(_impl_.backup_type_);
}
inline ::hw::trezor::messages::management::BackupType ResetDevice::backup_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.backup_type)
  return _internal_backup_type();
}
inline void ResetDevice::_internal_set_backup_type(::hw::trezor::messages::management::BackupType value) {
  assert(::hw::trezor::messages::management::BackupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.backup_type_ = value;
}
inline void ResetDevice::set_backup_type(::hw::trezor::messages::management::BackupType value) {
  _internal_set_backup_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.backup_type)
}

// -------------------------------------------------------------------

// BackupDevice

// -------------------------------------------------------------------

// EntropyRequest

// -------------------------------------------------------------------

// EntropyAck

// required bytes entropy = 1;
inline bool EntropyAck::_internal_has_entropy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EntropyAck::has_entropy() const {
  return _internal_has_entropy();
}
inline void EntropyAck::clear_entropy() {
  _impl_.entropy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntropyAck::entropy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.EntropyAck.entropy)
  return _internal_entropy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntropyAck::set_entropy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.entropy_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.EntropyAck.entropy)
}
inline std::string* EntropyAck::mutable_entropy() {
  std::string* _s = _internal_mutable_entropy();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.EntropyAck.entropy)
  return _s;
}
inline const std::string& EntropyAck::_internal_entropy() const {
  return _impl_.entropy_.Get();
}
inline void EntropyAck::_internal_set_entropy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.entropy_.Set(value, GetArenaForAllocation());
}
inline std::string* EntropyAck::_internal_mutable_entropy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.entropy_.Mutable(GetArenaForAllocation());
}
inline std::string* EntropyAck::release_entropy() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.EntropyAck.entropy)
  if (!_internal_has_entropy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.entropy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entropy_.IsDefault()) {
    _impl_.entropy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EntropyAck::set_allocated_entropy(std::string* entropy) {
  if (entropy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.entropy_.SetAllocated(entropy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entropy_.IsDefault()) {
    _impl_.entropy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.EntropyAck.entropy)
}

// -------------------------------------------------------------------

// RecoveryDevice

// optional uint32 word_count = 1;
inline bool RecoveryDevice::_internal_has_word_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RecoveryDevice::has_word_count() const {
  return _internal_has_word_count();
}
inline void RecoveryDevice::clear_word_count() {
  _impl_.word_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RecoveryDevice::_internal_word_count() const {
  return _impl_.word_count_;
}
inline uint32_t RecoveryDevice::word_count() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.word_count)
  return _internal_word_count();
}
inline void RecoveryDevice::_internal_set_word_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.word_count_ = value;
}
inline void RecoveryDevice::set_word_count(uint32_t value) {
  _internal_set_word_count(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.word_count)
}

// optional bool passphrase_protection = 2;
inline bool RecoveryDevice::_internal_has_passphrase_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RecoveryDevice::has_passphrase_protection() const {
  return _internal_has_passphrase_protection();
}
inline void RecoveryDevice::clear_passphrase_protection() {
  _impl_.passphrase_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RecoveryDevice::_internal_passphrase_protection() const {
  return _impl_.passphrase_protection_;
}
inline bool RecoveryDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.passphrase_protection)
  return _internal_passphrase_protection();
}
inline void RecoveryDevice::_internal_set_passphrase_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.passphrase_protection_ = value;
}
inline void RecoveryDevice::set_passphrase_protection(bool value) {
  _internal_set_passphrase_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.passphrase_protection)
}

// optional bool pin_protection = 3;
inline bool RecoveryDevice::_internal_has_pin_protection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RecoveryDevice::has_pin_protection() const {
  return _internal_has_pin_protection();
}
inline void RecoveryDevice::clear_pin_protection() {
  _impl_.pin_protection_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RecoveryDevice::_internal_pin_protection() const {
  return _impl_.pin_protection_;
}
inline bool RecoveryDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.pin_protection)
  return _internal_pin_protection();
}
inline void RecoveryDevice::_internal_set_pin_protection(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pin_protection_ = value;
}
inline void RecoveryDevice::set_pin_protection(bool value) {
  _internal_set_pin_protection(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.pin_protection)
}

// optional string language = 4;
inline bool RecoveryDevice::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecoveryDevice::has_language() const {
  return _internal_has_language();
}
inline void RecoveryDevice::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecoveryDevice::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecoveryDevice::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.language)
}
inline std::string* RecoveryDevice::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.RecoveryDevice.language)
  return _s;
}
inline const std::string& RecoveryDevice::_internal_language() const {
  return _impl_.language_.Get();
}
inline void RecoveryDevice::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* RecoveryDevice::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* RecoveryDevice::release_language() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.RecoveryDevice.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RecoveryDevice::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.RecoveryDevice.language)
}

// optional string label = 5;
inline bool RecoveryDevice::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RecoveryDevice::has_label() const {
  return _internal_has_label();
}
inline void RecoveryDevice::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecoveryDevice::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecoveryDevice::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.label)
}
inline std::string* RecoveryDevice::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.RecoveryDevice.label)
  return _s;
}
inline const std::string& RecoveryDevice::_internal_label() const {
  return _impl_.label_.Get();
}
inline void RecoveryDevice::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* RecoveryDevice::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* RecoveryDevice::release_label() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.RecoveryDevice.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RecoveryDevice::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.RecoveryDevice.label)
}

// optional bool enforce_wordlist = 6;
inline bool RecoveryDevice::_internal_has_enforce_wordlist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RecoveryDevice::has_enforce_wordlist() const {
  return _internal_has_enforce_wordlist();
}
inline void RecoveryDevice::clear_enforce_wordlist() {
  _impl_.enforce_wordlist_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool RecoveryDevice::_internal_enforce_wordlist() const {
  return _impl_.enforce_wordlist_;
}
inline bool RecoveryDevice::enforce_wordlist() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.enforce_wordlist)
  return _internal_enforce_wordlist();
}
inline void RecoveryDevice::_internal_set_enforce_wordlist(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.enforce_wordlist_ = value;
}
inline void RecoveryDevice::set_enforce_wordlist(bool value) {
  _internal_set_enforce_wordlist(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.enforce_wordlist)
}

// optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
inline bool RecoveryDevice::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RecoveryDevice::has_type() const {
  return _internal_has_type();
}
inline void RecoveryDevice::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType RecoveryDevice::_internal_type() const {
  return static_cast< ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType >(_impl_.type_);
}
inline ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType RecoveryDevice::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.type)
  return _internal_type();
}
inline void RecoveryDevice::_internal_set_type(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType value) {
  assert(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.type_ = value;
}
inline void RecoveryDevice::set_type(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.type)
}

// optional uint32 u2f_counter = 9;
inline bool RecoveryDevice::_internal_has_u2f_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RecoveryDevice::has_u2f_counter() const {
  return _internal_has_u2f_counter();
}
inline void RecoveryDevice::clear_u2f_counter() {
  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t RecoveryDevice::_internal_u2f_counter() const {
  return _impl_.u2f_counter_;
}
inline uint32_t RecoveryDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.u2f_counter)
  return _internal_u2f_counter();
}
inline void RecoveryDevice::_internal_set_u2f_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.u2f_counter_ = value;
}
inline void RecoveryDevice::set_u2f_counter(uint32_t value) {
  _internal_set_u2f_counter(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.u2f_counter)
}

// optional bool dry_run = 10;
inline bool RecoveryDevice::_internal_has_dry_run() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RecoveryDevice::has_dry_run() const {
  return _internal_has_dry_run();
}
inline void RecoveryDevice::clear_dry_run() {
  _impl_.dry_run_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool RecoveryDevice::_internal_dry_run() const {
  return _impl_.dry_run_;
}
inline bool RecoveryDevice::dry_run() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.dry_run)
  return _internal_dry_run();
}
inline void RecoveryDevice::_internal_set_dry_run(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.dry_run_ = value;
}
inline void RecoveryDevice::set_dry_run(bool value) {
  _internal_set_dry_run(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.dry_run)
}

// -------------------------------------------------------------------

// WordRequest

// required .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
inline bool WordRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WordRequest::has_type() const {
  return _internal_has_type();
}
inline void WordRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::hw::trezor::messages::management::WordRequest_WordRequestType WordRequest::_internal_type() const {
  return static_cast< ::hw::trezor::messages::management::WordRequest_WordRequestType >(_impl_.type_);
}
inline ::hw::trezor::messages::management::WordRequest_WordRequestType WordRequest::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.WordRequest.type)
  return _internal_type();
}
inline void WordRequest::_internal_set_type(::hw::trezor::messages::management::WordRequest_WordRequestType value) {
  assert(::hw::trezor::messages::management::WordRequest_WordRequestType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void WordRequest::set_type(::hw::trezor::messages::management::WordRequest_WordRequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.WordRequest.type)
}

// -------------------------------------------------------------------

// WordAck

// required string word = 1;
inline bool WordAck::_internal_has_word() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WordAck::has_word() const {
  return _internal_has_word();
}
inline void WordAck::clear_word() {
  _impl_.word_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WordAck::word() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.WordAck.word)
  return _internal_word();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WordAck::set_word(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.word_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.WordAck.word)
}
inline std::string* WordAck::mutable_word() {
  std::string* _s = _internal_mutable_word();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.WordAck.word)
  return _s;
}
inline const std::string& WordAck::_internal_word() const {
  return _impl_.word_.Get();
}
inline void WordAck::_internal_set_word(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.word_.Set(value, GetArenaForAllocation());
}
inline std::string* WordAck::_internal_mutable_word() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.word_.Mutable(GetArenaForAllocation());
}
inline std::string* WordAck::release_word() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.WordAck.word)
  if (!_internal_has_word()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.word_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.word_.IsDefault()) {
    _impl_.word_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void WordAck::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.word_.SetAllocated(word, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.word_.IsDefault()) {
    _impl_.word_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.WordAck.word)
}

// -------------------------------------------------------------------

// SetU2FCounter

// required uint32 u2f_counter = 1;
inline bool SetU2FCounter::_internal_has_u2f_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetU2FCounter::has_u2f_counter() const {
  return _internal_has_u2f_counter();
}
inline void SetU2FCounter::clear_u2f_counter() {
  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SetU2FCounter::_internal_u2f_counter() const {
  return _impl_.u2f_counter_;
}
inline uint32_t SetU2FCounter::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.SetU2FCounter.u2f_counter)
  return _internal_u2f_counter();
}
inline void SetU2FCounter::_internal_set_u2f_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u2f_counter_ = value;
}
inline void SetU2FCounter::set_u2f_counter(uint32_t value) {
  _internal_set_u2f_counter(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.SetU2FCounter.u2f_counter)
}

// -------------------------------------------------------------------

// GetNextU2FCounter

// -------------------------------------------------------------------

// NextU2FCounter

// required uint32 u2f_counter = 1;
inline bool NextU2FCounter::_internal_has_u2f_counter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NextU2FCounter::has_u2f_counter() const {
  return _internal_has_u2f_counter();
}
inline void NextU2FCounter::clear_u2f_counter() {
  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t NextU2FCounter::_internal_u2f_counter() const {
  return _impl_.u2f_counter_;
}
inline uint32_t NextU2FCounter::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.NextU2FCounter.u2f_counter)
  return _internal_u2f_counter();
}
inline void NextU2FCounter::_internal_set_u2f_counter(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.u2f_counter_ = value;
}
inline void NextU2FCounter::set_u2f_counter(uint32_t value) {
  _internal_set_u2f_counter(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.NextU2FCounter.u2f_counter)
}

// -------------------------------------------------------------------

// DoPreauthorized

// -------------------------------------------------------------------

// PreauthorizedRequest

// -------------------------------------------------------------------

// CancelAuthorization

// -------------------------------------------------------------------

// RebootToBootloader

// -------------------------------------------------------------------

// GetNonce

// -------------------------------------------------------------------

// Nonce

// required bytes nonce = 1;
inline bool Nonce::_internal_has_nonce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Nonce::has_nonce() const {
  return _internal_has_nonce();
}
inline void Nonce::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Nonce::nonce() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Nonce.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Nonce::set_nonce(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.nonce_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Nonce.nonce)
}
inline std::string* Nonce::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Nonce.nonce)
  return _s;
}
inline const std::string& Nonce::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void Nonce::_internal_set_nonce(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* Nonce::_internal_mutable_nonce() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* Nonce::release_nonce() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.Nonce.nonce)
  if (!_internal_has_nonce()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.nonce_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Nonce::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Nonce.nonce)
}

// -------------------------------------------------------------------

// UnlockPath

// repeated uint32 address_n = 1;
inline int UnlockPath::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int UnlockPath::address_n_size() const {
  return _internal_address_n_size();
}
inline void UnlockPath::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t UnlockPath::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t UnlockPath::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.UnlockPath.address_n)
  return _internal_address_n(index);
}
inline void UnlockPath::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.UnlockPath.address_n)
}
inline void UnlockPath::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void UnlockPath::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.management.UnlockPath.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UnlockPath::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UnlockPath::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.management.UnlockPath.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UnlockPath::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UnlockPath::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.management.UnlockPath.address_n)
  return _internal_mutable_address_n();
}

// optional bytes mac = 2;
inline bool UnlockPath::_internal_has_mac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnlockPath::has_mac() const {
  return _internal_has_mac();
}
inline void UnlockPath::clear_mac() {
  _impl_.mac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnlockPath::mac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.UnlockPath.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlockPath::set_mac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.UnlockPath.mac)
}
inline std::string* UnlockPath::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.UnlockPath.mac)
  return _s;
}
inline const std::string& UnlockPath::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void UnlockPath::_internal_set_mac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* UnlockPath::_internal_mutable_mac() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* UnlockPath::release_mac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.UnlockPath.mac)
  if (!_internal_has_mac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnlockPath::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.UnlockPath.mac)
}

// -------------------------------------------------------------------

// UnlockedPathRequest

// optional bytes mac = 1;
inline bool UnlockedPathRequest::_internal_has_mac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnlockedPathRequest::has_mac() const {
  return _internal_has_mac();
}
inline void UnlockedPathRequest::clear_mac() {
  _impl_.mac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnlockedPathRequest::mac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.UnlockedPathRequest.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlockedPathRequest::set_mac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.UnlockedPathRequest.mac)
}
inline std::string* UnlockedPathRequest::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.UnlockedPathRequest.mac)
  return _s;
}
inline const std::string& UnlockedPathRequest::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void UnlockedPathRequest::_internal_set_mac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* UnlockedPathRequest::_internal_mutable_mac() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* UnlockedPathRequest::release_mac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.management.UnlockedPathRequest.mac)
  if (!_internal_has_mac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnlockedPathRequest::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.UnlockedPathRequest.mac)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace management
}  // namespace messages
}  // namespace trezor
}  // namespace hw

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hw::trezor::messages::management::Features_Capability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::Features_Capability>() {
  return ::hw::trezor::messages::management::Features_Capability_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::SdProtect_SdProtectOperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::SdProtect_SdProtectOperationType>() {
  return ::hw::trezor::messages::management::SdProtect_SdProtectOperationType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType>() {
  return ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::WordRequest_WordRequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::WordRequest_WordRequestType>() {
  return ::hw::trezor::messages::management::WordRequest_WordRequestType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::BackupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::BackupType>() {
  return ::hw::trezor::messages::management::BackupType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::SafetyCheckLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::SafetyCheckLevel>() {
  return ::hw::trezor::messages::management::SafetyCheckLevel_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::HomescreenFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::HomescreenFormat>() {
  return ::hw::trezor::messages::management::HomescreenFormat_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2dmanagement_2eproto
