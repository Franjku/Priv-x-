// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-monero.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2dmonero_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2dmonero_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2dmonero_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2dmonero_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2dmonero_2eproto;
namespace hw {
namespace trezor {
namespace messages {
namespace monero {
class DebugMoneroDiagAck;
struct DebugMoneroDiagAckDefaultTypeInternal;
extern DebugMoneroDiagAckDefaultTypeInternal _DebugMoneroDiagAck_default_instance_;
class DebugMoneroDiagRequest;
struct DebugMoneroDiagRequestDefaultTypeInternal;
extern DebugMoneroDiagRequestDefaultTypeInternal _DebugMoneroDiagRequest_default_instance_;
class MoneroAddress;
struct MoneroAddressDefaultTypeInternal;
extern MoneroAddressDefaultTypeInternal _MoneroAddress_default_instance_;
class MoneroGetAddress;
struct MoneroGetAddressDefaultTypeInternal;
extern MoneroGetAddressDefaultTypeInternal _MoneroGetAddress_default_instance_;
class MoneroGetTxKeyAck;
struct MoneroGetTxKeyAckDefaultTypeInternal;
extern MoneroGetTxKeyAckDefaultTypeInternal _MoneroGetTxKeyAck_default_instance_;
class MoneroGetTxKeyRequest;
struct MoneroGetTxKeyRequestDefaultTypeInternal;
extern MoneroGetTxKeyRequestDefaultTypeInternal _MoneroGetTxKeyRequest_default_instance_;
class MoneroGetWatchKey;
struct MoneroGetWatchKeyDefaultTypeInternal;
extern MoneroGetWatchKeyDefaultTypeInternal _MoneroGetWatchKey_default_instance_;
class MoneroKeyImageExportInitAck;
struct MoneroKeyImageExportInitAckDefaultTypeInternal;
extern MoneroKeyImageExportInitAckDefaultTypeInternal _MoneroKeyImageExportInitAck_default_instance_;
class MoneroKeyImageExportInitRequest;
struct MoneroKeyImageExportInitRequestDefaultTypeInternal;
extern MoneroKeyImageExportInitRequestDefaultTypeInternal _MoneroKeyImageExportInitRequest_default_instance_;
class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList;
struct MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal;
extern MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesListDefaultTypeInternal _MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList_default_instance_;
class MoneroKeyImageSyncFinalAck;
struct MoneroKeyImageSyncFinalAckDefaultTypeInternal;
extern MoneroKeyImageSyncFinalAckDefaultTypeInternal _MoneroKeyImageSyncFinalAck_default_instance_;
class MoneroKeyImageSyncFinalRequest;
struct MoneroKeyImageSyncFinalRequestDefaultTypeInternal;
extern MoneroKeyImageSyncFinalRequestDefaultTypeInternal _MoneroKeyImageSyncFinalRequest_default_instance_;
class MoneroKeyImageSyncStepAck;
struct MoneroKeyImageSyncStepAckDefaultTypeInternal;
extern MoneroKeyImageSyncStepAckDefaultTypeInternal _MoneroKeyImageSyncStepAck_default_instance_;
class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage;
struct MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal;
extern MoneroKeyImageSyncStepAck_MoneroExportedKeyImageDefaultTypeInternal _MoneroKeyImageSyncStepAck_MoneroExportedKeyImage_default_instance_;
class MoneroKeyImageSyncStepRequest;
struct MoneroKeyImageSyncStepRequestDefaultTypeInternal;
extern MoneroKeyImageSyncStepRequestDefaultTypeInternal _MoneroKeyImageSyncStepRequest_default_instance_;
class MoneroKeyImageSyncStepRequest_MoneroTransferDetails;
struct MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal;
extern MoneroKeyImageSyncStepRequest_MoneroTransferDetailsDefaultTypeInternal _MoneroKeyImageSyncStepRequest_MoneroTransferDetails_default_instance_;
class MoneroLiveRefreshFinalAck;
struct MoneroLiveRefreshFinalAckDefaultTypeInternal;
extern MoneroLiveRefreshFinalAckDefaultTypeInternal _MoneroLiveRefreshFinalAck_default_instance_;
class MoneroLiveRefreshFinalRequest;
struct MoneroLiveRefreshFinalRequestDefaultTypeInternal;
extern MoneroLiveRefreshFinalRequestDefaultTypeInternal _MoneroLiveRefreshFinalRequest_default_instance_;
class MoneroLiveRefreshStartAck;
struct MoneroLiveRefreshStartAckDefaultTypeInternal;
extern MoneroLiveRefreshStartAckDefaultTypeInternal _MoneroLiveRefreshStartAck_default_instance_;
class MoneroLiveRefreshStartRequest;
struct MoneroLiveRefreshStartRequestDefaultTypeInternal;
extern MoneroLiveRefreshStartRequestDefaultTypeInternal _MoneroLiveRefreshStartRequest_default_instance_;
class MoneroLiveRefreshStepAck;
struct MoneroLiveRefreshStepAckDefaultTypeInternal;
extern MoneroLiveRefreshStepAckDefaultTypeInternal _MoneroLiveRefreshStepAck_default_instance_;
class MoneroLiveRefreshStepRequest;
struct MoneroLiveRefreshStepRequestDefaultTypeInternal;
extern MoneroLiveRefreshStepRequestDefaultTypeInternal _MoneroLiveRefreshStepRequest_default_instance_;
class MoneroTransactionAllInputsSetAck;
struct MoneroTransactionAllInputsSetAckDefaultTypeInternal;
extern MoneroTransactionAllInputsSetAckDefaultTypeInternal _MoneroTransactionAllInputsSetAck_default_instance_;
class MoneroTransactionAllInputsSetRequest;
struct MoneroTransactionAllInputsSetRequestDefaultTypeInternal;
extern MoneroTransactionAllInputsSetRequestDefaultTypeInternal _MoneroTransactionAllInputsSetRequest_default_instance_;
class MoneroTransactionAllOutSetAck;
struct MoneroTransactionAllOutSetAckDefaultTypeInternal;
extern MoneroTransactionAllOutSetAckDefaultTypeInternal _MoneroTransactionAllOutSetAck_default_instance_;
class MoneroTransactionAllOutSetAck_MoneroRingCtSig;
struct MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal;
extern MoneroTransactionAllOutSetAck_MoneroRingCtSigDefaultTypeInternal _MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_;
class MoneroTransactionAllOutSetRequest;
struct MoneroTransactionAllOutSetRequestDefaultTypeInternal;
extern MoneroTransactionAllOutSetRequestDefaultTypeInternal _MoneroTransactionAllOutSetRequest_default_instance_;
class MoneroTransactionDestinationEntry;
struct MoneroTransactionDestinationEntryDefaultTypeInternal;
extern MoneroTransactionDestinationEntryDefaultTypeInternal _MoneroTransactionDestinationEntry_default_instance_;
class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress;
struct MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal;
extern MoneroTransactionDestinationEntry_MoneroAccountPublicAddressDefaultTypeInternal _MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_;
class MoneroTransactionFinalAck;
struct MoneroTransactionFinalAckDefaultTypeInternal;
extern MoneroTransactionFinalAckDefaultTypeInternal _MoneroTransactionFinalAck_default_instance_;
class MoneroTransactionFinalRequest;
struct MoneroTransactionFinalRequestDefaultTypeInternal;
extern MoneroTransactionFinalRequestDefaultTypeInternal _MoneroTransactionFinalRequest_default_instance_;
class MoneroTransactionInitAck;
struct MoneroTransactionInitAckDefaultTypeInternal;
extern MoneroTransactionInitAckDefaultTypeInternal _MoneroTransactionInitAck_default_instance_;
class MoneroTransactionInitRequest;
struct MoneroTransactionInitRequestDefaultTypeInternal;
extern MoneroTransactionInitRequestDefaultTypeInternal _MoneroTransactionInitRequest_default_instance_;
class MoneroTransactionInitRequest_MoneroTransactionData;
struct MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal;
extern MoneroTransactionInitRequest_MoneroTransactionDataDefaultTypeInternal _MoneroTransactionInitRequest_MoneroTransactionData_default_instance_;
class MoneroTransactionInputViniAck;
struct MoneroTransactionInputViniAckDefaultTypeInternal;
extern MoneroTransactionInputViniAckDefaultTypeInternal _MoneroTransactionInputViniAck_default_instance_;
class MoneroTransactionInputViniRequest;
struct MoneroTransactionInputViniRequestDefaultTypeInternal;
extern MoneroTransactionInputViniRequestDefaultTypeInternal _MoneroTransactionInputViniRequest_default_instance_;
class MoneroTransactionRsigData;
struct MoneroTransactionRsigDataDefaultTypeInternal;
extern MoneroTransactionRsigDataDefaultTypeInternal _MoneroTransactionRsigData_default_instance_;
class MoneroTransactionSetInputAck;
struct MoneroTransactionSetInputAckDefaultTypeInternal;
extern MoneroTransactionSetInputAckDefaultTypeInternal _MoneroTransactionSetInputAck_default_instance_;
class MoneroTransactionSetInputRequest;
struct MoneroTransactionSetInputRequestDefaultTypeInternal;
extern MoneroTransactionSetInputRequestDefaultTypeInternal _MoneroTransactionSetInputRequest_default_instance_;
class MoneroTransactionSetOutputAck;
struct MoneroTransactionSetOutputAckDefaultTypeInternal;
extern MoneroTransactionSetOutputAckDefaultTypeInternal _MoneroTransactionSetOutputAck_default_instance_;
class MoneroTransactionSetOutputRequest;
struct MoneroTransactionSetOutputRequestDefaultTypeInternal;
extern MoneroTransactionSetOutputRequestDefaultTypeInternal _MoneroTransactionSetOutputRequest_default_instance_;
class MoneroTransactionSignInputAck;
struct MoneroTransactionSignInputAckDefaultTypeInternal;
extern MoneroTransactionSignInputAckDefaultTypeInternal _MoneroTransactionSignInputAck_default_instance_;
class MoneroTransactionSignInputRequest;
struct MoneroTransactionSignInputRequestDefaultTypeInternal;
extern MoneroTransactionSignInputRequestDefaultTypeInternal _MoneroTransactionSignInputRequest_default_instance_;
class MoneroTransactionSourceEntry;
struct MoneroTransactionSourceEntryDefaultTypeInternal;
extern MoneroTransactionSourceEntryDefaultTypeInternal _MoneroTransactionSourceEntry_default_instance_;
class MoneroTransactionSourceEntry_MoneroMultisigKLRki;
struct MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal;
extern MoneroTransactionSourceEntry_MoneroMultisigKLRkiDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_;
class MoneroTransactionSourceEntry_MoneroOutputEntry;
struct MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal;
extern MoneroTransactionSourceEntry_MoneroOutputEntryDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroOutputEntry_default_instance_;
class MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic;
struct MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal;
extern MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublicDefaultTypeInternal _MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_;
class MoneroWatchKey;
struct MoneroWatchKeyDefaultTypeInternal;
extern MoneroWatchKeyDefaultTypeInternal _MoneroWatchKey_default_instance_;
}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw
PROTOBUF_NAMESPACE_OPEN
template<> ::hw::trezor::messages::monero::DebugMoneroDiagAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::DebugMoneroDiagAck>(Arena*);
template<> ::hw::trezor::messages::monero::DebugMoneroDiagRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::DebugMoneroDiagRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroAddress>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetAddress>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetTxKeyAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetTxKeyAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetTxKeyRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetTxKeyRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroGetWatchKey* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroGetWatchKey>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageExportInitAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageExportInitAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncFinalAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshFinalAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshFinalRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStartAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStartAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStartRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStepAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStepAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroLiveRefreshStepRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllInputsSetAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllInputsSetRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionFinalAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionFinalAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionFinalRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInitAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInitRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInputViniAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInputViniAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInputViniRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionRsigData* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetInputAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetInputAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetInputRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetOutputAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetOutputAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSignInputAck* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSignInputAck>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSignInputRequest>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(Arena*);
template<> ::hw::trezor::messages::monero::MoneroWatchKey* Arena::CreateMaybeMessage<::hw::trezor::messages::monero::MoneroWatchKey>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hw {
namespace trezor {
namespace messages {
namespace monero {

enum MoneroNetworkType : int {
  MAINNET = 0,
  TESTNET = 1,
  STAGENET = 2,
  FAKECHAIN = 3
};
bool MoneroNetworkType_IsValid(int value);
constexpr MoneroNetworkType MoneroNetworkType_MIN = MAINNET;
constexpr MoneroNetworkType MoneroNetworkType_MAX = FAKECHAIN;
constexpr int MoneroNetworkType_ARRAYSIZE = MoneroNetworkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoneroNetworkType_descriptor();
template<typename T>
inline const std::string& MoneroNetworkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoneroNetworkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoneroNetworkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoneroNetworkType_descriptor(), enum_t_value);
}
inline bool MoneroNetworkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoneroNetworkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoneroNetworkType>(
    MoneroNetworkType_descriptor(), name, value);
}
// ===================================================================

class MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic) */ {
 public:
  inline MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic() : MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(nullptr) {}
  ~MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from);
  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&& from) noexcept
    : MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& operator=(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& operator=(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic*>(
               &_MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& a, MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& from) {
    MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic";
  }
  protected:
  explicit MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 1,
    kCommitmentFieldNumber = 2,
  };
  // required bytes dest = 1;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const std::string& dest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest();
  PROTOBUF_NODISCARD std::string* release_dest();
  void set_allocated_dest(std::string* dest);
  private:
  const std::string& _internal_dest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest(const std::string& value);
  std::string* _internal_mutable_dest();
  public:

  // required bytes commitment = 2;
  bool has_commitment() const;
  private:
  bool _internal_has_commitment() const;
  public:
  void clear_commitment();
  const std::string& commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commitment();
  PROTOBUF_NODISCARD std::string* release_commitment();
  void set_allocated_commitment(std::string* commitment);
  private:
  const std::string& _internal_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commitment(const std::string& value);
  std::string* _internal_mutable_commitment();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commitment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroOutputEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry) */ {
 public:
  inline MoneroTransactionSourceEntry_MoneroOutputEntry() : MoneroTransactionSourceEntry_MoneroOutputEntry(nullptr) {}
  ~MoneroTransactionSourceEntry_MoneroOutputEntry() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroOutputEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSourceEntry_MoneroOutputEntry(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);
  MoneroTransactionSourceEntry_MoneroOutputEntry(MoneroTransactionSourceEntry_MoneroOutputEntry&& from) noexcept
    : MoneroTransactionSourceEntry_MoneroOutputEntry() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry_MoneroOutputEntry& operator=(const MoneroTransactionSourceEntry_MoneroOutputEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSourceEntry_MoneroOutputEntry& operator=(MoneroTransactionSourceEntry_MoneroOutputEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSourceEntry_MoneroOutputEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSourceEntry_MoneroOutputEntry* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry_MoneroOutputEntry*>(
               &_MoneroTransactionSourceEntry_MoneroOutputEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MoneroTransactionSourceEntry_MoneroOutputEntry& a, MoneroTransactionSourceEntry_MoneroOutputEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSourceEntry_MoneroOutputEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSourceEntry_MoneroOutputEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry_MoneroOutputEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSourceEntry_MoneroOutputEntry& from) {
    MoneroTransactionSourceEntry_MoneroOutputEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry_MoneroOutputEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry";
  }
  protected:
  explicit MoneroTransactionSourceEntry_MoneroOutputEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic MoneroRctKeyPublic;

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kIdxFieldNumber = 1,
  };
  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& key() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* release_key();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* mutable_key();
  void set_allocated_key(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& _internal_key() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key);
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* unsafe_arena_release_key();

  // optional uint64 idx = 1;
  bool has_idx() const;
  private:
  bool _internal_has_idx() const;
  public:
  void clear_idx();
  uint64_t idx() const;
  void set_idx(uint64_t value);
  private:
  uint64_t _internal_idx() const;
  void _internal_set_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key_;
    uint64_t idx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroMultisigKLRki final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki) */ {
 public:
  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki() : MoneroTransactionSourceEntry_MoneroMultisigKLRki(nullptr) {}
  ~MoneroTransactionSourceEntry_MoneroMultisigKLRki() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry_MoneroMultisigKLRki(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSourceEntry_MoneroMultisigKLRki(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);
  MoneroTransactionSourceEntry_MoneroMultisigKLRki(MoneroTransactionSourceEntry_MoneroMultisigKLRki&& from) noexcept
    : MoneroTransactionSourceEntry_MoneroMultisigKLRki() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki& operator=(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki& operator=(MoneroTransactionSourceEntry_MoneroMultisigKLRki&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSourceEntry_MoneroMultisigKLRki& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSourceEntry_MoneroMultisigKLRki* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry_MoneroMultisigKLRki*>(
               &_MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MoneroTransactionSourceEntry_MoneroMultisigKLRki& a, MoneroTransactionSourceEntry_MoneroMultisigKLRki& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry_MoneroMultisigKLRki* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry_MoneroMultisigKLRki>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from) {
    MoneroTransactionSourceEntry_MoneroMultisigKLRki::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki";
  }
  protected:
  explicit MoneroTransactionSourceEntry_MoneroMultisigKLRki(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKFieldNumber = 1,
    kLFieldNumber = 2,
    kRFieldNumber = 3,
    kKiFieldNumber = 4,
  };
  // optional bytes K = 1;
  bool has_k() const;
  private:
  bool _internal_has_k() const;
  public:
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_NODISCARD std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // optional bytes L = 2;
  bool has_l() const;
  private:
  bool _internal_has_l() const;
  public:
  void clear_l();
  const std::string& l() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_l(ArgT0&& arg0, ArgT... args);
  std::string* mutable_l();
  PROTOBUF_NODISCARD std::string* release_l();
  void set_allocated_l(std::string* l);
  private:
  const std::string& _internal_l() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_l(const std::string& value);
  std::string* _internal_mutable_l();
  public:

  // optional bytes R = 3;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  const std::string& r() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_r(ArgT0&& arg0, ArgT... args);
  std::string* mutable_r();
  PROTOBUF_NODISCARD std::string* release_r();
  void set_allocated_r(std::string* r);
  private:
  const std::string& _internal_r() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_r(const std::string& value);
  std::string* _internal_mutable_r();
  public:

  // optional bytes ki = 4;
  bool has_ki() const;
  private:
  bool _internal_has_ki() const;
  public:
  void clear_ki();
  const std::string& ki() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ki(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ki();
  PROTOBUF_NODISCARD std::string* release_ki();
  void set_allocated_ki(std::string* ki);
  private:
  const std::string& _internal_ki() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ki(const std::string& value);
  std::string* _internal_mutable_ki();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr l_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr r_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ki_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSourceEntry) */ {
 public:
  inline MoneroTransactionSourceEntry() : MoneroTransactionSourceEntry(nullptr) {}
  ~MoneroTransactionSourceEntry() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSourceEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSourceEntry(const MoneroTransactionSourceEntry& from);
  MoneroTransactionSourceEntry(MoneroTransactionSourceEntry&& from) noexcept
    : MoneroTransactionSourceEntry() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSourceEntry& operator=(const MoneroTransactionSourceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSourceEntry& operator=(MoneroTransactionSourceEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSourceEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSourceEntry* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSourceEntry*>(
               &_MoneroTransactionSourceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MoneroTransactionSourceEntry& a, MoneroTransactionSourceEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSourceEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSourceEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSourceEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSourceEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSourceEntry& from) {
    MoneroTransactionSourceEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSourceEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSourceEntry";
  }
  protected:
  explicit MoneroTransactionSourceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionSourceEntry_MoneroOutputEntry MoneroOutputEntry;
  typedef MoneroTransactionSourceEntry_MoneroMultisigKLRki MoneroMultisigKLRki;

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 1,
    kRealOutAdditionalTxKeysFieldNumber = 4,
    kRealOutTxKeyFieldNumber = 3,
    kMaskFieldNumber = 8,
    kMultisigKLRkiFieldNumber = 9,
    kRealOutputFieldNumber = 2,
    kRealOutputInTxIndexFieldNumber = 5,
    kAmountFieldNumber = 6,
    kRctFieldNumber = 7,
    kSubaddrMinorFieldNumber = 10,
  };
  // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >*
      mutable_outputs();
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& _internal_outputs(int index) const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* _internal_add_outputs();
  public:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& outputs(int index) const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >&
      outputs() const;

  // repeated bytes real_out_additional_tx_keys = 4;
  int real_out_additional_tx_keys_size() const;
  private:
  int _internal_real_out_additional_tx_keys_size() const;
  public:
  void clear_real_out_additional_tx_keys();
  const std::string& real_out_additional_tx_keys(int index) const;
  std::string* mutable_real_out_additional_tx_keys(int index);
  void set_real_out_additional_tx_keys(int index, const std::string& value);
  void set_real_out_additional_tx_keys(int index, std::string&& value);
  void set_real_out_additional_tx_keys(int index, const char* value);
  void set_real_out_additional_tx_keys(int index, const void* value, size_t size);
  std::string* add_real_out_additional_tx_keys();
  void add_real_out_additional_tx_keys(const std::string& value);
  void add_real_out_additional_tx_keys(std::string&& value);
  void add_real_out_additional_tx_keys(const char* value);
  void add_real_out_additional_tx_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& real_out_additional_tx_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_real_out_additional_tx_keys();
  private:
  const std::string& _internal_real_out_additional_tx_keys(int index) const;
  std::string* _internal_add_real_out_additional_tx_keys();
  public:

  // optional bytes real_out_tx_key = 3;
  bool has_real_out_tx_key() const;
  private:
  bool _internal_has_real_out_tx_key() const;
  public:
  void clear_real_out_tx_key();
  const std::string& real_out_tx_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_real_out_tx_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_real_out_tx_key();
  PROTOBUF_NODISCARD std::string* release_real_out_tx_key();
  void set_allocated_real_out_tx_key(std::string* real_out_tx_key);
  private:
  const std::string& _internal_real_out_tx_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_out_tx_key(const std::string& value);
  std::string* _internal_mutable_real_out_tx_key();
  public:

  // optional bytes mask = 8;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
  bool has_multisig_klrki() const;
  private:
  bool _internal_has_multisig_klrki() const;
  public:
  void clear_multisig_klrki();
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& multisig_klrki() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* release_multisig_klrki();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* mutable_multisig_klrki();
  void set_allocated_multisig_klrki(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& _internal_multisig_klrki() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* _internal_mutable_multisig_klrki();
  public:
  void unsafe_arena_set_allocated_multisig_klrki(
      ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki);
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* unsafe_arena_release_multisig_klrki();

  // optional uint64 real_output = 2;
  bool has_real_output() const;
  private:
  bool _internal_has_real_output() const;
  public:
  void clear_real_output();
  uint64_t real_output() const;
  void set_real_output(uint64_t value);
  private:
  uint64_t _internal_real_output() const;
  void _internal_set_real_output(uint64_t value);
  public:

  // optional uint64 real_output_in_tx_index = 5;
  bool has_real_output_in_tx_index() const;
  private:
  bool _internal_has_real_output_in_tx_index() const;
  public:
  void clear_real_output_in_tx_index();
  uint64_t real_output_in_tx_index() const;
  void set_real_output_in_tx_index(uint64_t value);
  private:
  uint64_t _internal_real_output_in_tx_index() const;
  void _internal_set_real_output_in_tx_index(uint64_t value);
  public:

  // optional uint64 amount = 6;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // optional bool rct = 7;
  bool has_rct() const;
  private:
  bool _internal_has_rct() const;
  public:
  void clear_rct();
  bool rct() const;
  void set_rct(bool value);
  private:
  bool _internal_rct() const;
  void _internal_set_rct(bool value);
  public:

  // optional uint32 subaddr_minor = 10;
  bool has_subaddr_minor() const;
  private:
  bool _internal_has_subaddr_minor() const;
  public:
  void clear_subaddr_minor();
  uint32_t subaddr_minor() const;
  void set_subaddr_minor(uint32_t value);
  private:
  uint32_t _internal_subaddr_minor() const;
  void _internal_set_subaddr_minor(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> real_out_additional_tx_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr real_out_tx_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki_;
    uint64_t real_output_;
    uint64_t real_output_in_tx_index_;
    uint64_t amount_;
    bool rct_;
    uint32_t subaddr_minor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress) */ {
 public:
  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress() : MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(nullptr) {}
  ~MoneroTransactionDestinationEntry_MoneroAccountPublicAddress() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);
  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&& from) noexcept
    : MoneroTransactionDestinationEntry_MoneroAccountPublicAddress() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& operator=(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& operator=(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress*>(
               &_MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& a, MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from) {
    MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress";
  }
  protected:
  explicit MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpendPublicKeyFieldNumber = 1,
    kViewPublicKeyFieldNumber = 2,
  };
  // optional bytes spend_public_key = 1;
  bool has_spend_public_key() const;
  private:
  bool _internal_has_spend_public_key() const;
  public:
  void clear_spend_public_key();
  const std::string& spend_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spend_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spend_public_key();
  PROTOBUF_NODISCARD std::string* release_spend_public_key();
  void set_allocated_spend_public_key(std::string* spend_public_key);
  private:
  const std::string& _internal_spend_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spend_public_key(const std::string& value);
  std::string* _internal_mutable_spend_public_key();
  public:

  // optional bytes view_public_key = 2;
  bool has_view_public_key() const;
  private:
  bool _internal_has_view_public_key() const;
  public:
  void clear_view_public_key();
  const std::string& view_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_public_key();
  PROTOBUF_NODISCARD std::string* release_view_public_key();
  void set_allocated_view_public_key(std::string* view_public_key);
  private:
  const std::string& _internal_view_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_public_key(const std::string& value);
  std::string* _internal_mutable_view_public_key();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spend_public_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_public_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionDestinationEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionDestinationEntry) */ {
 public:
  inline MoneroTransactionDestinationEntry() : MoneroTransactionDestinationEntry(nullptr) {}
  ~MoneroTransactionDestinationEntry() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionDestinationEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionDestinationEntry(const MoneroTransactionDestinationEntry& from);
  MoneroTransactionDestinationEntry(MoneroTransactionDestinationEntry&& from) noexcept
    : MoneroTransactionDestinationEntry() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionDestinationEntry& operator=(const MoneroTransactionDestinationEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionDestinationEntry& operator=(MoneroTransactionDestinationEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionDestinationEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionDestinationEntry* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionDestinationEntry*>(
               &_MoneroTransactionDestinationEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MoneroTransactionDestinationEntry& a, MoneroTransactionDestinationEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionDestinationEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionDestinationEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionDestinationEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionDestinationEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionDestinationEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionDestinationEntry& from) {
    MoneroTransactionDestinationEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionDestinationEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionDestinationEntry";
  }
  protected:
  explicit MoneroTransactionDestinationEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionDestinationEntry_MoneroAccountPublicAddress MoneroAccountPublicAddress;

  // accessors -------------------------------------------------------

  enum : int {
    kOriginalFieldNumber = 4,
    kAddrFieldNumber = 2,
    kAmountFieldNumber = 1,
    kIsSubaddressFieldNumber = 3,
    kIsIntegratedFieldNumber = 5,
  };
  // optional bytes original = 4;
  bool has_original() const;
  private:
  bool _internal_has_original() const;
  public:
  void clear_original();
  const std::string& original() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original();
  PROTOBUF_NODISCARD std::string* release_original();
  void set_allocated_original(std::string* original);
  private:
  const std::string& _internal_original() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original(const std::string& value);
  std::string* _internal_mutable_original();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& addr() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* release_addr();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* mutable_addr();
  void set_allocated_addr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& _internal_addr() const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* _internal_mutable_addr();
  public:
  void unsafe_arena_set_allocated_addr(
      ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr);
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* unsafe_arena_release_addr();

  // optional uint64 amount = 1;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // optional bool is_subaddress = 3;
  bool has_is_subaddress() const;
  private:
  bool _internal_has_is_subaddress() const;
  public:
  void clear_is_subaddress();
  bool is_subaddress() const;
  void set_is_subaddress(bool value);
  private:
  bool _internal_is_subaddress() const;
  void _internal_set_is_subaddress(bool value);
  public:

  // optional bool is_integrated = 5;
  bool has_is_integrated() const;
  private:
  bool _internal_has_is_integrated() const;
  public:
  void clear_is_integrated();
  bool is_integrated() const;
  void set_is_integrated(bool value);
  private:
  bool _internal_is_integrated() const;
  void _internal_set_is_integrated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_;
    ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr_;
    uint64_t amount_;
    bool is_subaddress_;
    bool is_integrated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionRsigData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionRsigData) */ {
 public:
  inline MoneroTransactionRsigData() : MoneroTransactionRsigData(nullptr) {}
  ~MoneroTransactionRsigData() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionRsigData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionRsigData(const MoneroTransactionRsigData& from);
  MoneroTransactionRsigData(MoneroTransactionRsigData&& from) noexcept
    : MoneroTransactionRsigData() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionRsigData& operator=(const MoneroTransactionRsigData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionRsigData& operator=(MoneroTransactionRsigData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionRsigData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionRsigData* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionRsigData*>(
               &_MoneroTransactionRsigData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MoneroTransactionRsigData& a, MoneroTransactionRsigData& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionRsigData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionRsigData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionRsigData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionRsigData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionRsigData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionRsigData& from) {
    MoneroTransactionRsigData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionRsigData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionRsigData";
  }
  protected:
  explicit MoneroTransactionRsigData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupingFieldNumber = 3,
    kRsigPartsFieldNumber = 6,
    kMaskFieldNumber = 4,
    kRsigFieldNumber = 5,
    kRsigTypeFieldNumber = 1,
    kOffloadTypeFieldNumber = 2,
    kBpVersionFieldNumber = 7,
  };
  // repeated uint64 grouping = 3;
  int grouping_size() const;
  private:
  int _internal_grouping_size() const;
  public:
  void clear_grouping();
  private:
  uint64_t _internal_grouping(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_grouping() const;
  void _internal_add_grouping(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_grouping();
  public:
  uint64_t grouping(int index) const;
  void set_grouping(int index, uint64_t value);
  void add_grouping(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      grouping() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_grouping();

  // repeated bytes rsig_parts = 6;
  int rsig_parts_size() const;
  private:
  int _internal_rsig_parts_size() const;
  public:
  void clear_rsig_parts();
  const std::string& rsig_parts(int index) const;
  std::string* mutable_rsig_parts(int index);
  void set_rsig_parts(int index, const std::string& value);
  void set_rsig_parts(int index, std::string&& value);
  void set_rsig_parts(int index, const char* value);
  void set_rsig_parts(int index, const void* value, size_t size);
  std::string* add_rsig_parts();
  void add_rsig_parts(const std::string& value);
  void add_rsig_parts(std::string&& value);
  void add_rsig_parts(const char* value);
  void add_rsig_parts(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& rsig_parts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_rsig_parts();
  private:
  const std::string& _internal_rsig_parts(int index) const;
  std::string* _internal_add_rsig_parts();
  public:

  // optional bytes mask = 4;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const std::string& mask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mask();
  PROTOBUF_NODISCARD std::string* release_mask();
  void set_allocated_mask(std::string* mask);
  private:
  const std::string& _internal_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mask(const std::string& value);
  std::string* _internal_mutable_mask();
  public:

  // optional bytes rsig = 5;
  bool has_rsig() const;
  private:
  bool _internal_has_rsig() const;
  public:
  void clear_rsig();
  const std::string& rsig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rsig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rsig();
  PROTOBUF_NODISCARD std::string* release_rsig();
  void set_allocated_rsig(std::string* rsig);
  private:
  const std::string& _internal_rsig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rsig(const std::string& value);
  std::string* _internal_mutable_rsig();
  public:

  // optional uint32 rsig_type = 1;
  bool has_rsig_type() const;
  private:
  bool _internal_has_rsig_type() const;
  public:
  void clear_rsig_type();
  uint32_t rsig_type() const;
  void set_rsig_type(uint32_t value);
  private:
  uint32_t _internal_rsig_type() const;
  void _internal_set_rsig_type(uint32_t value);
  public:

  // optional uint32 offload_type = 2;
  bool has_offload_type() const;
  private:
  bool _internal_has_offload_type() const;
  public:
  void clear_offload_type();
  uint32_t offload_type() const;
  void set_offload_type(uint32_t value);
  private:
  uint32_t _internal_offload_type() const;
  void _internal_set_offload_type(uint32_t value);
  public:

  // optional uint32 bp_version = 7;
  bool has_bp_version() const;
  private:
  bool _internal_has_bp_version() const;
  public:
  void clear_bp_version();
  uint32_t bp_version() const;
  void set_bp_version(uint32_t value);
  private:
  uint32_t _internal_bp_version() const;
  void _internal_set_bp_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionRsigData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > grouping_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> rsig_parts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rsig_;
    uint32_t rsig_type_;
    uint32_t offload_type_;
    uint32_t bp_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetAddress) */ {
 public:
  inline MoneroGetAddress() : MoneroGetAddress(nullptr) {}
  ~MoneroGetAddress() override;
  explicit PROTOBUF_CONSTEXPR MoneroGetAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroGetAddress(const MoneroGetAddress& from);
  MoneroGetAddress(MoneroGetAddress&& from) noexcept
    : MoneroGetAddress() {
    *this = ::std::move(from);
  }

  inline MoneroGetAddress& operator=(const MoneroGetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroGetAddress& operator=(MoneroGetAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroGetAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroGetAddress* internal_default_instance() {
    return reinterpret_cast<const MoneroGetAddress*>(
               &_MoneroGetAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MoneroGetAddress& a, MoneroGetAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroGetAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroGetAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroGetAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroGetAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroGetAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroGetAddress& from) {
    MoneroGetAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroGetAddress";
  }
  protected:
  explicit MoneroGetAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 1,
    kPaymentIdFieldNumber = 6,
    kShowDisplayFieldNumber = 2,
    kNetworkTypeFieldNumber = 3,
    kAccountFieldNumber = 4,
    kMinorFieldNumber = 5,
  };
  // repeated uint32 address_n = 1;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // optional bytes payment_id = 6;
  bool has_payment_id() const;
  private:
  bool _internal_has_payment_id() const;
  public:
  void clear_payment_id();
  const std::string& payment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_id();
  PROTOBUF_NODISCARD std::string* release_payment_id();
  void set_allocated_payment_id(std::string* payment_id);
  private:
  const std::string& _internal_payment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_id(const std::string& value);
  std::string* _internal_mutable_payment_id();
  public:

  // optional bool show_display = 2;
  bool has_show_display() const;
  private:
  bool _internal_has_show_display() const;
  public:
  void clear_show_display();
  bool show_display() const;
  void set_show_display(bool value);
  private:
  bool _internal_show_display() const;
  void _internal_set_show_display(bool value);
  public:

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::hw::trezor::messages::monero::MoneroNetworkType network_type() const;
  void set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  private:
  ::hw::trezor::messages::monero::MoneroNetworkType _internal_network_type() const;
  void _internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  public:

  // optional uint32 account = 4;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  uint32_t account() const;
  void set_account(uint32_t value);
  private:
  uint32_t _internal_account() const;
  void _internal_set_account(uint32_t value);
  public:

  // optional uint32 minor = 5;
  bool has_minor() const;
  private:
  bool _internal_has_minor() const;
  public:
  void clear_minor();
  uint32_t minor() const;
  void set_minor(uint32_t value);
  private:
  uint32_t _internal_minor() const;
  void _internal_set_minor(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_id_;
    bool show_display_;
    int network_type_;
    uint32_t account_;
    uint32_t minor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroAddress) */ {
 public:
  inline MoneroAddress() : MoneroAddress(nullptr) {}
  ~MoneroAddress() override;
  explicit PROTOBUF_CONSTEXPR MoneroAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroAddress(const MoneroAddress& from);
  MoneroAddress(MoneroAddress&& from) noexcept
    : MoneroAddress() {
    *this = ::std::move(from);
  }

  inline MoneroAddress& operator=(const MoneroAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroAddress& operator=(MoneroAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroAddress* internal_default_instance() {
    return reinterpret_cast<const MoneroAddress*>(
               &_MoneroAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MoneroAddress& a, MoneroAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroAddress& from) {
    MoneroAddress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroAddress";
  }
  protected:
  explicit MoneroAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // optional bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroAddress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetWatchKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetWatchKey) */ {
 public:
  inline MoneroGetWatchKey() : MoneroGetWatchKey(nullptr) {}
  ~MoneroGetWatchKey() override;
  explicit PROTOBUF_CONSTEXPR MoneroGetWatchKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroGetWatchKey(const MoneroGetWatchKey& from);
  MoneroGetWatchKey(MoneroGetWatchKey&& from) noexcept
    : MoneroGetWatchKey() {
    *this = ::std::move(from);
  }

  inline MoneroGetWatchKey& operator=(const MoneroGetWatchKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroGetWatchKey& operator=(MoneroGetWatchKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroGetWatchKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroGetWatchKey* internal_default_instance() {
    return reinterpret_cast<const MoneroGetWatchKey*>(
               &_MoneroGetWatchKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MoneroGetWatchKey& a, MoneroGetWatchKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroGetWatchKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroGetWatchKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroGetWatchKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroGetWatchKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroGetWatchKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroGetWatchKey& from) {
    MoneroGetWatchKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetWatchKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroGetWatchKey";
  }
  protected:
  explicit MoneroGetWatchKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 1,
    kNetworkTypeFieldNumber = 2,
  };
  // repeated uint32 address_n = 1;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::hw::trezor::messages::monero::MoneroNetworkType network_type() const;
  void set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  private:
  ::hw::trezor::messages::monero::MoneroNetworkType _internal_network_type() const;
  void _internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetWatchKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    int network_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroWatchKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroWatchKey) */ {
 public:
  inline MoneroWatchKey() : MoneroWatchKey(nullptr) {}
  ~MoneroWatchKey() override;
  explicit PROTOBUF_CONSTEXPR MoneroWatchKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroWatchKey(const MoneroWatchKey& from);
  MoneroWatchKey(MoneroWatchKey&& from) noexcept
    : MoneroWatchKey() {
    *this = ::std::move(from);
  }

  inline MoneroWatchKey& operator=(const MoneroWatchKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroWatchKey& operator=(MoneroWatchKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroWatchKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroWatchKey* internal_default_instance() {
    return reinterpret_cast<const MoneroWatchKey*>(
               &_MoneroWatchKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MoneroWatchKey& a, MoneroWatchKey& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroWatchKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroWatchKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroWatchKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroWatchKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroWatchKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroWatchKey& from) {
    MoneroWatchKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroWatchKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroWatchKey";
  }
  protected:
  explicit MoneroWatchKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWatchKeyFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // optional bytes watch_key = 1;
  bool has_watch_key() const;
  private:
  bool _internal_has_watch_key() const;
  public:
  void clear_watch_key();
  const std::string& watch_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_watch_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_watch_key();
  PROTOBUF_NODISCARD std::string* release_watch_key();
  void set_allocated_watch_key(std::string* watch_key);
  private:
  const std::string& _internal_watch_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_watch_key(const std::string& value);
  std::string* _internal_mutable_watch_key();
  public:

  // optional bytes address = 2;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroWatchKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr watch_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInitRequest_MoneroTransactionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData) */ {
 public:
  inline MoneroTransactionInitRequest_MoneroTransactionData() : MoneroTransactionInitRequest_MoneroTransactionData(nullptr) {}
  ~MoneroTransactionInitRequest_MoneroTransactionData() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionInitRequest_MoneroTransactionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionInitRequest_MoneroTransactionData(const MoneroTransactionInitRequest_MoneroTransactionData& from);
  MoneroTransactionInitRequest_MoneroTransactionData(MoneroTransactionInitRequest_MoneroTransactionData&& from) noexcept
    : MoneroTransactionInitRequest_MoneroTransactionData() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInitRequest_MoneroTransactionData& operator=(const MoneroTransactionInitRequest_MoneroTransactionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionInitRequest_MoneroTransactionData& operator=(MoneroTransactionInitRequest_MoneroTransactionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionInitRequest_MoneroTransactionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionInitRequest_MoneroTransactionData* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInitRequest_MoneroTransactionData*>(
               &_MoneroTransactionInitRequest_MoneroTransactionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MoneroTransactionInitRequest_MoneroTransactionData& a, MoneroTransactionInitRequest_MoneroTransactionData& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionInitRequest_MoneroTransactionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionInitRequest_MoneroTransactionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionInitRequest_MoneroTransactionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionInitRequest_MoneroTransactionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionInitRequest_MoneroTransactionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionInitRequest_MoneroTransactionData& from) {
    MoneroTransactionInitRequest_MoneroTransactionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInitRequest_MoneroTransactionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData";
  }
  protected:
  explicit MoneroTransactionInitRequest_MoneroTransactionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 4,
    kMinorIndicesFieldNumber = 10,
    kIntegratedIndicesFieldNumber = 12,
    kPaymentIdFieldNumber = 2,
    kMoneroVersionFieldNumber = 15,
    kChangeDtsFieldNumber = 5,
    kRsigDataFieldNumber = 11,
    kUnlockTimeFieldNumber = 3,
    kVersionFieldNumber = 1,
    kNumInputsFieldNumber = 6,
    kFeeFieldNumber = 8,
    kMixinFieldNumber = 7,
    kAccountFieldNumber = 9,
    kClientVersionFieldNumber = 13,
    kHardForkFieldNumber = 14,
  };
  // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >*
      mutable_outputs();
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& _internal_outputs(int index) const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* _internal_add_outputs();
  public:
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& outputs(int index) const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >&
      outputs() const;

  // repeated uint32 minor_indices = 10;
  int minor_indices_size() const;
  private:
  int _internal_minor_indices_size() const;
  public:
  void clear_minor_indices();
  private:
  uint32_t _internal_minor_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_minor_indices() const;
  void _internal_add_minor_indices(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_minor_indices();
  public:
  uint32_t minor_indices(int index) const;
  void set_minor_indices(int index, uint32_t value);
  void add_minor_indices(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      minor_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_minor_indices();

  // repeated uint32 integrated_indices = 12;
  int integrated_indices_size() const;
  private:
  int _internal_integrated_indices_size() const;
  public:
  void clear_integrated_indices();
  private:
  uint32_t _internal_integrated_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_integrated_indices() const;
  void _internal_add_integrated_indices(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_integrated_indices();
  public:
  uint32_t integrated_indices(int index) const;
  void set_integrated_indices(int index, uint32_t value);
  void add_integrated_indices(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      integrated_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_integrated_indices();

  // optional bytes payment_id = 2;
  bool has_payment_id() const;
  private:
  bool _internal_has_payment_id() const;
  public:
  void clear_payment_id();
  const std::string& payment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_id();
  PROTOBUF_NODISCARD std::string* release_payment_id();
  void set_allocated_payment_id(std::string* payment_id);
  private:
  const std::string& _internal_payment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_id(const std::string& value);
  std::string* _internal_mutable_payment_id();
  public:

  // optional bytes monero_version = 15;
  bool has_monero_version() const;
  private:
  bool _internal_has_monero_version() const;
  public:
  void clear_monero_version();
  const std::string& monero_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_monero_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_monero_version();
  PROTOBUF_NODISCARD std::string* release_monero_version();
  void set_allocated_monero_version(std::string* monero_version);
  private:
  const std::string& _internal_monero_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_monero_version(const std::string& value);
  std::string* _internal_mutable_monero_version();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
  bool has_change_dts() const;
  private:
  bool _internal_has_change_dts() const;
  public:
  void clear_change_dts();
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& change_dts() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* release_change_dts();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_change_dts();
  void set_allocated_change_dts(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& _internal_change_dts() const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* _internal_mutable_change_dts();
  public:
  void unsafe_arena_set_allocated_change_dts(
      ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts);
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* unsafe_arena_release_change_dts();

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
  bool has_rsig_data() const;
  private:
  bool _internal_has_rsig_data() const;
  public:
  void clear_rsig_data();
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& _internal_rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _internal_mutable_rsig_data();
  public:
  void unsafe_arena_set_allocated_rsig_data(
      ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* unsafe_arena_release_rsig_data();

  // optional uint64 unlock_time = 3;
  bool has_unlock_time() const;
  private:
  bool _internal_has_unlock_time() const;
  public:
  void clear_unlock_time();
  uint64_t unlock_time() const;
  void set_unlock_time(uint64_t value);
  private:
  uint64_t _internal_unlock_time() const;
  void _internal_set_unlock_time(uint64_t value);
  public:

  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional uint32 num_inputs = 6;
  bool has_num_inputs() const;
  private:
  bool _internal_has_num_inputs() const;
  public:
  void clear_num_inputs();
  uint32_t num_inputs() const;
  void set_num_inputs(uint32_t value);
  private:
  uint32_t _internal_num_inputs() const;
  void _internal_set_num_inputs(uint32_t value);
  public:

  // optional uint64 fee = 8;
  bool has_fee() const;
  private:
  bool _internal_has_fee() const;
  public:
  void clear_fee();
  uint64_t fee() const;
  void set_fee(uint64_t value);
  private:
  uint64_t _internal_fee() const;
  void _internal_set_fee(uint64_t value);
  public:

  // optional uint32 mixin = 7;
  bool has_mixin() const;
  private:
  bool _internal_has_mixin() const;
  public:
  void clear_mixin();
  uint32_t mixin() const;
  void set_mixin(uint32_t value);
  private:
  uint32_t _internal_mixin() const;
  void _internal_set_mixin(uint32_t value);
  public:

  // optional uint32 account = 9;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  uint32_t account() const;
  void set_account(uint32_t value);
  private:
  uint32_t _internal_account() const;
  void _internal_set_account(uint32_t value);
  public:

  // optional uint32 client_version = 13;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  uint32_t client_version() const;
  void set_client_version(uint32_t value);
  private:
  uint32_t _internal_client_version() const;
  void _internal_set_client_version(uint32_t value);
  public:

  // optional uint32 hard_fork = 14;
  bool has_hard_fork() const;
  private:
  bool _internal_has_hard_fork() const;
  public:
  void clear_hard_fork();
  uint32_t hard_fork() const;
  void set_hard_fork(uint32_t value);
  private:
  uint32_t _internal_hard_fork() const;
  void _internal_set_hard_fork(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > minor_indices_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > integrated_indices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr monero_version_;
    ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts_;
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
    uint64_t unlock_time_;
    uint32_t version_;
    uint32_t num_inputs_;
    uint64_t fee_;
    uint32_t mixin_;
    uint32_t account_;
    uint32_t client_version_;
    uint32_t hard_fork_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInitRequest) */ {
 public:
  inline MoneroTransactionInitRequest() : MoneroTransactionInitRequest(nullptr) {}
  ~MoneroTransactionInitRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionInitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionInitRequest(const MoneroTransactionInitRequest& from);
  MoneroTransactionInitRequest(MoneroTransactionInitRequest&& from) noexcept
    : MoneroTransactionInitRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInitRequest& operator=(const MoneroTransactionInitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionInitRequest& operator=(MoneroTransactionInitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionInitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionInitRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInitRequest*>(
               &_MoneroTransactionInitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MoneroTransactionInitRequest& a, MoneroTransactionInitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionInitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionInitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionInitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionInitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionInitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionInitRequest& from) {
    MoneroTransactionInitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionInitRequest";
  }
  protected:
  explicit MoneroTransactionInitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionInitRequest_MoneroTransactionData MoneroTransactionData;

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 2,
    kTsxDataFieldNumber = 4,
    kVersionFieldNumber = 1,
    kNetworkTypeFieldNumber = 3,
  };
  // repeated uint32 address_n = 2;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
  bool has_tsx_data() const;
  private:
  bool _internal_has_tsx_data() const;
  public:
  void clear_tsx_data();
  const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& tsx_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* release_tsx_data();
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* mutable_tsx_data();
  void set_allocated_tsx_data(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& _internal_tsx_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* _internal_mutable_tsx_data();
  public:
  void unsafe_arena_set_allocated_tsx_data(
      ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data);
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* unsafe_arena_release_tsx_data();

  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::hw::trezor::messages::monero::MoneroNetworkType network_type() const;
  void set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  private:
  ::hw::trezor::messages::monero::MoneroNetworkType _internal_network_type() const;
  void _internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data_;
    uint32_t version_;
    int network_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInitAck) */ {
 public:
  inline MoneroTransactionInitAck() : MoneroTransactionInitAck(nullptr) {}
  ~MoneroTransactionInitAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionInitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionInitAck(const MoneroTransactionInitAck& from);
  MoneroTransactionInitAck(MoneroTransactionInitAck&& from) noexcept
    : MoneroTransactionInitAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInitAck& operator=(const MoneroTransactionInitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionInitAck& operator=(MoneroTransactionInitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionInitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionInitAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInitAck*>(
               &_MoneroTransactionInitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MoneroTransactionInitAck& a, MoneroTransactionInitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionInitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionInitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionInitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionInitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionInitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionInitAck& from) {
    MoneroTransactionInitAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionInitAck";
  }
  protected:
  explicit MoneroTransactionInitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHmacsFieldNumber = 1,
    kRsigDataFieldNumber = 2,
  };
  // repeated bytes hmacs = 1;
  int hmacs_size() const;
  private:
  int _internal_hmacs_size() const;
  public:
  void clear_hmacs();
  const std::string& hmacs(int index) const;
  std::string* mutable_hmacs(int index);
  void set_hmacs(int index, const std::string& value);
  void set_hmacs(int index, std::string&& value);
  void set_hmacs(int index, const char* value);
  void set_hmacs(int index, const void* value, size_t size);
  std::string* add_hmacs();
  void add_hmacs(const std::string& value);
  void add_hmacs(std::string&& value);
  void add_hmacs(const char* value);
  void add_hmacs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hmacs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hmacs();
  private:
  const std::string& _internal_hmacs(int index) const;
  std::string* _internal_add_hmacs();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
  bool has_rsig_data() const;
  private:
  bool _internal_has_rsig_data() const;
  public:
  void clear_rsig_data();
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& _internal_rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _internal_mutable_rsig_data();
  public:
  void unsafe_arena_set_allocated_rsig_data(
      ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* unsafe_arena_release_rsig_data();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hmacs_;
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetInputRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetInputRequest) */ {
 public:
  inline MoneroTransactionSetInputRequest() : MoneroTransactionSetInputRequest(nullptr) {}
  ~MoneroTransactionSetInputRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSetInputRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSetInputRequest(const MoneroTransactionSetInputRequest& from);
  MoneroTransactionSetInputRequest(MoneroTransactionSetInputRequest&& from) noexcept
    : MoneroTransactionSetInputRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetInputRequest& operator=(const MoneroTransactionSetInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSetInputRequest& operator=(MoneroTransactionSetInputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSetInputRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSetInputRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetInputRequest*>(
               &_MoneroTransactionSetInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MoneroTransactionSetInputRequest& a, MoneroTransactionSetInputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSetInputRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSetInputRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSetInputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSetInputRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSetInputRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSetInputRequest& from) {
    MoneroTransactionSetInputRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetInputRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSetInputRequest";
  }
  protected:
  explicit MoneroTransactionSetInputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcEntrFieldNumber = 1,
  };
  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  bool has_src_entr() const;
  private:
  bool _internal_has_src_entr() const;
  public:
  void clear_src_entr();
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& _internal_src_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* _internal_mutable_src_entr();
  public:
  void unsafe_arena_set_allocated_src_entr(
      ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* unsafe_arena_release_src_entr();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetInputAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetInputAck) */ {
 public:
  inline MoneroTransactionSetInputAck() : MoneroTransactionSetInputAck(nullptr) {}
  ~MoneroTransactionSetInputAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSetInputAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSetInputAck(const MoneroTransactionSetInputAck& from);
  MoneroTransactionSetInputAck(MoneroTransactionSetInputAck&& from) noexcept
    : MoneroTransactionSetInputAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetInputAck& operator=(const MoneroTransactionSetInputAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSetInputAck& operator=(MoneroTransactionSetInputAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSetInputAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSetInputAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetInputAck*>(
               &_MoneroTransactionSetInputAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MoneroTransactionSetInputAck& a, MoneroTransactionSetInputAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSetInputAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSetInputAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSetInputAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSetInputAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSetInputAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSetInputAck& from) {
    MoneroTransactionSetInputAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetInputAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSetInputAck";
  }
  protected:
  explicit MoneroTransactionSetInputAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViniFieldNumber = 1,
    kViniHmacFieldNumber = 2,
    kPseudoOutFieldNumber = 3,
    kPseudoOutHmacFieldNumber = 4,
    kPseudoOutAlphaFieldNumber = 5,
    kSpendKeyFieldNumber = 6,
  };
  // optional bytes vini = 1;
  bool has_vini() const;
  private:
  bool _internal_has_vini() const;
  public:
  void clear_vini();
  const std::string& vini() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vini(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vini();
  PROTOBUF_NODISCARD std::string* release_vini();
  void set_allocated_vini(std::string* vini);
  private:
  const std::string& _internal_vini() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vini(const std::string& value);
  std::string* _internal_mutable_vini();
  public:

  // optional bytes vini_hmac = 2;
  bool has_vini_hmac() const;
  private:
  bool _internal_has_vini_hmac() const;
  public:
  void clear_vini_hmac();
  const std::string& vini_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vini_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vini_hmac();
  PROTOBUF_NODISCARD std::string* release_vini_hmac();
  void set_allocated_vini_hmac(std::string* vini_hmac);
  private:
  const std::string& _internal_vini_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vini_hmac(const std::string& value);
  std::string* _internal_mutable_vini_hmac();
  public:

  // optional bytes pseudo_out = 3;
  bool has_pseudo_out() const;
  private:
  bool _internal_has_pseudo_out() const;
  public:
  void clear_pseudo_out();
  const std::string& pseudo_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out();
  PROTOBUF_NODISCARD std::string* release_pseudo_out();
  void set_allocated_pseudo_out(std::string* pseudo_out);
  private:
  const std::string& _internal_pseudo_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out(const std::string& value);
  std::string* _internal_mutable_pseudo_out();
  public:

  // optional bytes pseudo_out_hmac = 4;
  bool has_pseudo_out_hmac() const;
  private:
  bool _internal_has_pseudo_out_hmac() const;
  public:
  void clear_pseudo_out_hmac();
  const std::string& pseudo_out_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out_hmac();
  PROTOBUF_NODISCARD std::string* release_pseudo_out_hmac();
  void set_allocated_pseudo_out_hmac(std::string* pseudo_out_hmac);
  private:
  const std::string& _internal_pseudo_out_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out_hmac(const std::string& value);
  std::string* _internal_mutable_pseudo_out_hmac();
  public:

  // optional bytes pseudo_out_alpha = 5;
  bool has_pseudo_out_alpha() const;
  private:
  bool _internal_has_pseudo_out_alpha() const;
  public:
  void clear_pseudo_out_alpha();
  const std::string& pseudo_out_alpha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out_alpha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out_alpha();
  PROTOBUF_NODISCARD std::string* release_pseudo_out_alpha();
  void set_allocated_pseudo_out_alpha(std::string* pseudo_out_alpha);
  private:
  const std::string& _internal_pseudo_out_alpha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out_alpha(const std::string& value);
  std::string* _internal_mutable_pseudo_out_alpha();
  public:

  // optional bytes spend_key = 6;
  bool has_spend_key() const;
  private:
  bool _internal_has_spend_key() const;
  public:
  void clear_spend_key();
  const std::string& spend_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spend_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spend_key();
  PROTOBUF_NODISCARD std::string* release_spend_key();
  void set_allocated_spend_key(std::string* spend_key);
  private:
  const std::string& _internal_spend_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spend_key(const std::string& value);
  std::string* _internal_mutable_spend_key();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vini_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vini_hmac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_hmac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_alpha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spend_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInputViniRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInputViniRequest) */ {
 public:
  inline MoneroTransactionInputViniRequest() : MoneroTransactionInputViniRequest(nullptr) {}
  ~MoneroTransactionInputViniRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionInputViniRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionInputViniRequest(const MoneroTransactionInputViniRequest& from);
  MoneroTransactionInputViniRequest(MoneroTransactionInputViniRequest&& from) noexcept
    : MoneroTransactionInputViniRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInputViniRequest& operator=(const MoneroTransactionInputViniRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionInputViniRequest& operator=(MoneroTransactionInputViniRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionInputViniRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionInputViniRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInputViniRequest*>(
               &_MoneroTransactionInputViniRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MoneroTransactionInputViniRequest& a, MoneroTransactionInputViniRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionInputViniRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionInputViniRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionInputViniRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionInputViniRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionInputViniRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionInputViniRequest& from) {
    MoneroTransactionInputViniRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionInputViniRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionInputViniRequest";
  }
  protected:
  explicit MoneroTransactionInputViniRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViniFieldNumber = 2,
    kViniHmacFieldNumber = 3,
    kPseudoOutFieldNumber = 4,
    kPseudoOutHmacFieldNumber = 5,
    kSrcEntrFieldNumber = 1,
    kOrigIdxFieldNumber = 6,
  };
  // optional bytes vini = 2;
  bool has_vini() const;
  private:
  bool _internal_has_vini() const;
  public:
  void clear_vini();
  const std::string& vini() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vini(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vini();
  PROTOBUF_NODISCARD std::string* release_vini();
  void set_allocated_vini(std::string* vini);
  private:
  const std::string& _internal_vini() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vini(const std::string& value);
  std::string* _internal_mutable_vini();
  public:

  // optional bytes vini_hmac = 3;
  bool has_vini_hmac() const;
  private:
  bool _internal_has_vini_hmac() const;
  public:
  void clear_vini_hmac();
  const std::string& vini_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vini_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vini_hmac();
  PROTOBUF_NODISCARD std::string* release_vini_hmac();
  void set_allocated_vini_hmac(std::string* vini_hmac);
  private:
  const std::string& _internal_vini_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vini_hmac(const std::string& value);
  std::string* _internal_mutable_vini_hmac();
  public:

  // optional bytes pseudo_out = 4;
  bool has_pseudo_out() const;
  private:
  bool _internal_has_pseudo_out() const;
  public:
  void clear_pseudo_out();
  const std::string& pseudo_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out();
  PROTOBUF_NODISCARD std::string* release_pseudo_out();
  void set_allocated_pseudo_out(std::string* pseudo_out);
  private:
  const std::string& _internal_pseudo_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out(const std::string& value);
  std::string* _internal_mutable_pseudo_out();
  public:

  // optional bytes pseudo_out_hmac = 5;
  bool has_pseudo_out_hmac() const;
  private:
  bool _internal_has_pseudo_out_hmac() const;
  public:
  void clear_pseudo_out_hmac();
  const std::string& pseudo_out_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out_hmac();
  PROTOBUF_NODISCARD std::string* release_pseudo_out_hmac();
  void set_allocated_pseudo_out_hmac(std::string* pseudo_out_hmac);
  private:
  const std::string& _internal_pseudo_out_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out_hmac(const std::string& value);
  std::string* _internal_mutable_pseudo_out_hmac();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  bool has_src_entr() const;
  private:
  bool _internal_has_src_entr() const;
  public:
  void clear_src_entr();
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& _internal_src_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* _internal_mutable_src_entr();
  public:
  void unsafe_arena_set_allocated_src_entr(
      ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* unsafe_arena_release_src_entr();

  // optional uint32 orig_idx = 6;
  bool has_orig_idx() const;
  private:
  bool _internal_has_orig_idx() const;
  public:
  void clear_orig_idx();
  uint32_t orig_idx() const;
  void set_orig_idx(uint32_t value);
  private:
  uint32_t _internal_orig_idx() const;
  void _internal_set_orig_idx(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vini_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vini_hmac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_hmac_;
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
    uint32_t orig_idx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionInputViniAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionInputViniAck) */ {
 public:
  inline MoneroTransactionInputViniAck() : MoneroTransactionInputViniAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroTransactionInputViniAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionInputViniAck(const MoneroTransactionInputViniAck& from);
  MoneroTransactionInputViniAck(MoneroTransactionInputViniAck&& from) noexcept
    : MoneroTransactionInputViniAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionInputViniAck& operator=(const MoneroTransactionInputViniAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionInputViniAck& operator=(MoneroTransactionInputViniAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionInputViniAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionInputViniAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionInputViniAck*>(
               &_MoneroTransactionInputViniAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MoneroTransactionInputViniAck& a, MoneroTransactionInputViniAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionInputViniAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionInputViniAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionInputViniAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionInputViniAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroTransactionInputViniAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroTransactionInputViniAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionInputViniAck";
  }
  protected:
  explicit MoneroTransactionInputViniAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllInputsSetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest) */ {
 public:
  inline MoneroTransactionAllInputsSetRequest() : MoneroTransactionAllInputsSetRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroTransactionAllInputsSetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionAllInputsSetRequest(const MoneroTransactionAllInputsSetRequest& from);
  MoneroTransactionAllInputsSetRequest(MoneroTransactionAllInputsSetRequest&& from) noexcept
    : MoneroTransactionAllInputsSetRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllInputsSetRequest& operator=(const MoneroTransactionAllInputsSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionAllInputsSetRequest& operator=(MoneroTransactionAllInputsSetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionAllInputsSetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionAllInputsSetRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllInputsSetRequest*>(
               &_MoneroTransactionAllInputsSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MoneroTransactionAllInputsSetRequest& a, MoneroTransactionAllInputsSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionAllInputsSetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionAllInputsSetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionAllInputsSetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionAllInputsSetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroTransactionAllInputsSetRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroTransactionAllInputsSetRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest";
  }
  protected:
  explicit MoneroTransactionAllInputsSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllInputsSetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllInputsSetAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck) */ {
 public:
  inline MoneroTransactionAllInputsSetAck() : MoneroTransactionAllInputsSetAck(nullptr) {}
  ~MoneroTransactionAllInputsSetAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionAllInputsSetAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionAllInputsSetAck(const MoneroTransactionAllInputsSetAck& from);
  MoneroTransactionAllInputsSetAck(MoneroTransactionAllInputsSetAck&& from) noexcept
    : MoneroTransactionAllInputsSetAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllInputsSetAck& operator=(const MoneroTransactionAllInputsSetAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionAllInputsSetAck& operator=(MoneroTransactionAllInputsSetAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionAllInputsSetAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionAllInputsSetAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllInputsSetAck*>(
               &_MoneroTransactionAllInputsSetAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MoneroTransactionAllInputsSetAck& a, MoneroTransactionAllInputsSetAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionAllInputsSetAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionAllInputsSetAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionAllInputsSetAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionAllInputsSetAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionAllInputsSetAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionAllInputsSetAck& from) {
    MoneroTransactionAllInputsSetAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllInputsSetAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck";
  }
  protected:
  explicit MoneroTransactionAllInputsSetAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsigDataFieldNumber = 1,
  };
  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  bool has_rsig_data() const;
  private:
  bool _internal_has_rsig_data() const;
  public:
  void clear_rsig_data();
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& _internal_rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _internal_mutable_rsig_data();
  public:
  void unsafe_arena_set_allocated_rsig_data(
      ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* unsafe_arena_release_rsig_data();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetOutputRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest) */ {
 public:
  inline MoneroTransactionSetOutputRequest() : MoneroTransactionSetOutputRequest(nullptr) {}
  ~MoneroTransactionSetOutputRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSetOutputRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSetOutputRequest(const MoneroTransactionSetOutputRequest& from);
  MoneroTransactionSetOutputRequest(MoneroTransactionSetOutputRequest&& from) noexcept
    : MoneroTransactionSetOutputRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetOutputRequest& operator=(const MoneroTransactionSetOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSetOutputRequest& operator=(MoneroTransactionSetOutputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSetOutputRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSetOutputRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetOutputRequest*>(
               &_MoneroTransactionSetOutputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MoneroTransactionSetOutputRequest& a, MoneroTransactionSetOutputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSetOutputRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSetOutputRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSetOutputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSetOutputRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSetOutputRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSetOutputRequest& from) {
    MoneroTransactionSetOutputRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetOutputRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSetOutputRequest";
  }
  protected:
  explicit MoneroTransactionSetOutputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstEntrHmacFieldNumber = 2,
    kDstEntrFieldNumber = 1,
    kRsigDataFieldNumber = 3,
    kIsOffloadedBpFieldNumber = 4,
  };
  // optional bytes dst_entr_hmac = 2;
  bool has_dst_entr_hmac() const;
  private:
  bool _internal_has_dst_entr_hmac() const;
  public:
  void clear_dst_entr_hmac();
  const std::string& dst_entr_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_entr_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_entr_hmac();
  PROTOBUF_NODISCARD std::string* release_dst_entr_hmac();
  void set_allocated_dst_entr_hmac(std::string* dst_entr_hmac);
  private:
  const std::string& _internal_dst_entr_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_entr_hmac(const std::string& value);
  std::string* _internal_mutable_dst_entr_hmac();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
  bool has_dst_entr() const;
  private:
  bool _internal_has_dst_entr() const;
  public:
  void clear_dst_entr();
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& dst_entr() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* release_dst_entr();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_dst_entr();
  void set_allocated_dst_entr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& _internal_dst_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* _internal_mutable_dst_entr();
  public:
  void unsafe_arena_set_allocated_dst_entr(
      ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr);
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* unsafe_arena_release_dst_entr();

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
  bool has_rsig_data() const;
  private:
  bool _internal_has_rsig_data() const;
  public:
  void clear_rsig_data();
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& _internal_rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _internal_mutable_rsig_data();
  public:
  void unsafe_arena_set_allocated_rsig_data(
      ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* unsafe_arena_release_rsig_data();

  // optional bool is_offloaded_bp = 4;
  bool has_is_offloaded_bp() const;
  private:
  bool _internal_has_is_offloaded_bp() const;
  public:
  void clear_is_offloaded_bp();
  bool is_offloaded_bp() const;
  void set_is_offloaded_bp(bool value);
  private:
  bool _internal_is_offloaded_bp() const;
  void _internal_set_is_offloaded_bp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_entr_hmac_;
    ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr_;
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
    bool is_offloaded_bp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSetOutputAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSetOutputAck) */ {
 public:
  inline MoneroTransactionSetOutputAck() : MoneroTransactionSetOutputAck(nullptr) {}
  ~MoneroTransactionSetOutputAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSetOutputAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSetOutputAck(const MoneroTransactionSetOutputAck& from);
  MoneroTransactionSetOutputAck(MoneroTransactionSetOutputAck&& from) noexcept
    : MoneroTransactionSetOutputAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSetOutputAck& operator=(const MoneroTransactionSetOutputAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSetOutputAck& operator=(MoneroTransactionSetOutputAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSetOutputAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSetOutputAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSetOutputAck*>(
               &_MoneroTransactionSetOutputAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MoneroTransactionSetOutputAck& a, MoneroTransactionSetOutputAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSetOutputAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSetOutputAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSetOutputAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSetOutputAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSetOutputAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSetOutputAck& from) {
    MoneroTransactionSetOutputAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSetOutputAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSetOutputAck";
  }
  protected:
  explicit MoneroTransactionSetOutputAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxOutFieldNumber = 1,
    kVoutiHmacFieldNumber = 2,
    kOutPkFieldNumber = 4,
    kEcdhInfoFieldNumber = 5,
    kRsigDataFieldNumber = 3,
  };
  // optional bytes tx_out = 1;
  bool has_tx_out() const;
  private:
  bool _internal_has_tx_out() const;
  public:
  void clear_tx_out();
  const std::string& tx_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_out();
  PROTOBUF_NODISCARD std::string* release_tx_out();
  void set_allocated_tx_out(std::string* tx_out);
  private:
  const std::string& _internal_tx_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_out(const std::string& value);
  std::string* _internal_mutable_tx_out();
  public:

  // optional bytes vouti_hmac = 2;
  bool has_vouti_hmac() const;
  private:
  bool _internal_has_vouti_hmac() const;
  public:
  void clear_vouti_hmac();
  const std::string& vouti_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vouti_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vouti_hmac();
  PROTOBUF_NODISCARD std::string* release_vouti_hmac();
  void set_allocated_vouti_hmac(std::string* vouti_hmac);
  private:
  const std::string& _internal_vouti_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vouti_hmac(const std::string& value);
  std::string* _internal_mutable_vouti_hmac();
  public:

  // optional bytes out_pk = 4;
  bool has_out_pk() const;
  private:
  bool _internal_has_out_pk() const;
  public:
  void clear_out_pk();
  const std::string& out_pk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_out_pk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_out_pk();
  PROTOBUF_NODISCARD std::string* release_out_pk();
  void set_allocated_out_pk(std::string* out_pk);
  private:
  const std::string& _internal_out_pk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_pk(const std::string& value);
  std::string* _internal_mutable_out_pk();
  public:

  // optional bytes ecdh_info = 5;
  bool has_ecdh_info() const;
  private:
  bool _internal_has_ecdh_info() const;
  public:
  void clear_ecdh_info();
  const std::string& ecdh_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdh_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdh_info();
  PROTOBUF_NODISCARD std::string* release_ecdh_info();
  void set_allocated_ecdh_info(std::string* ecdh_info);
  private:
  const std::string& _internal_ecdh_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdh_info(const std::string& value);
  std::string* _internal_mutable_ecdh_info();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
  bool has_rsig_data() const;
  private:
  bool _internal_has_rsig_data() const;
  public:
  void clear_rsig_data();
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& _internal_rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _internal_mutable_rsig_data();
  public:
  void unsafe_arena_set_allocated_rsig_data(
      ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* unsafe_arena_release_rsig_data();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vouti_hmac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr out_pk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdh_info_;
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest) */ {
 public:
  inline MoneroTransactionAllOutSetRequest() : MoneroTransactionAllOutSetRequest(nullptr) {}
  ~MoneroTransactionAllOutSetRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionAllOutSetRequest(const MoneroTransactionAllOutSetRequest& from);
  MoneroTransactionAllOutSetRequest(MoneroTransactionAllOutSetRequest&& from) noexcept
    : MoneroTransactionAllOutSetRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllOutSetRequest& operator=(const MoneroTransactionAllOutSetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionAllOutSetRequest& operator=(MoneroTransactionAllOutSetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionAllOutSetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionAllOutSetRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllOutSetRequest*>(
               &_MoneroTransactionAllOutSetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MoneroTransactionAllOutSetRequest& a, MoneroTransactionAllOutSetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionAllOutSetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionAllOutSetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionAllOutSetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionAllOutSetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionAllOutSetRequest& from) {
    MoneroTransactionAllOutSetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllOutSetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest";
  }
  protected:
  explicit MoneroTransactionAllOutSetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsigDataFieldNumber = 1,
  };
  // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
  bool has_rsig_data() const;
  private:
  bool _internal_has_rsig_data() const;
  public:
  void clear_rsig_data();
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& rsig_data() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionRsigData* release_rsig_data();
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* mutable_rsig_data();
  void set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData& _internal_rsig_data() const;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _internal_mutable_rsig_data();
  public:
  void unsafe_arena_set_allocated_rsig_data(
      ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data);
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* unsafe_arena_release_rsig_data();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetAck_MoneroRingCtSig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig) */ {
 public:
  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig() : MoneroTransactionAllOutSetAck_MoneroRingCtSig(nullptr) {}
  ~MoneroTransactionAllOutSetAck_MoneroRingCtSig() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetAck_MoneroRingCtSig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionAllOutSetAck_MoneroRingCtSig(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);
  MoneroTransactionAllOutSetAck_MoneroRingCtSig(MoneroTransactionAllOutSetAck_MoneroRingCtSig&& from) noexcept
    : MoneroTransactionAllOutSetAck_MoneroRingCtSig() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig& operator=(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig& operator=(MoneroTransactionAllOutSetAck_MoneroRingCtSig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionAllOutSetAck_MoneroRingCtSig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionAllOutSetAck_MoneroRingCtSig* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllOutSetAck_MoneroRingCtSig*>(
               &_MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MoneroTransactionAllOutSetAck_MoneroRingCtSig& a, MoneroTransactionAllOutSetAck_MoneroRingCtSig& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionAllOutSetAck_MoneroRingCtSig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetAck_MoneroRingCtSig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from) {
    MoneroTransactionAllOutSetAck_MoneroRingCtSig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig";
  }
  protected:
  explicit MoneroTransactionAllOutSetAck_MoneroRingCtSig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTxnFeeFieldNumber = 1,
    kRvTypeFieldNumber = 3,
  };
  // optional bytes message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional uint64 txn_fee = 1;
  bool has_txn_fee() const;
  private:
  bool _internal_has_txn_fee() const;
  public:
  void clear_txn_fee();
  uint64_t txn_fee() const;
  void set_txn_fee(uint64_t value);
  private:
  uint64_t _internal_txn_fee() const;
  void _internal_set_txn_fee(uint64_t value);
  public:

  // optional uint32 rv_type = 3;
  bool has_rv_type() const;
  private:
  bool _internal_has_rv_type() const;
  public:
  void clear_rv_type();
  uint32_t rv_type() const;
  void set_rv_type(uint32_t value);
  private:
  uint32_t _internal_rv_type() const;
  void _internal_set_rv_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t txn_fee_;
    uint32_t rv_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck) */ {
 public:
  inline MoneroTransactionAllOutSetAck() : MoneroTransactionAllOutSetAck(nullptr) {}
  ~MoneroTransactionAllOutSetAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionAllOutSetAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionAllOutSetAck(const MoneroTransactionAllOutSetAck& from);
  MoneroTransactionAllOutSetAck(MoneroTransactionAllOutSetAck&& from) noexcept
    : MoneroTransactionAllOutSetAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionAllOutSetAck& operator=(const MoneroTransactionAllOutSetAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionAllOutSetAck& operator=(MoneroTransactionAllOutSetAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionAllOutSetAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionAllOutSetAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionAllOutSetAck*>(
               &_MoneroTransactionAllOutSetAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MoneroTransactionAllOutSetAck& a, MoneroTransactionAllOutSetAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionAllOutSetAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionAllOutSetAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionAllOutSetAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionAllOutSetAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionAllOutSetAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionAllOutSetAck& from) {
    MoneroTransactionAllOutSetAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionAllOutSetAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionAllOutSetAck";
  }
  protected:
  explicit MoneroTransactionAllOutSetAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionAllOutSetAck_MoneroRingCtSig MoneroRingCtSig;

  // accessors -------------------------------------------------------

  enum : int {
    kExtraFieldNumber = 1,
    kTxPrefixHashFieldNumber = 2,
    kFullMessageHashFieldNumber = 5,
    kRvFieldNumber = 4,
  };
  // optional bytes extra = 1;
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // optional bytes tx_prefix_hash = 2;
  bool has_tx_prefix_hash() const;
  private:
  bool _internal_has_tx_prefix_hash() const;
  public:
  void clear_tx_prefix_hash();
  const std::string& tx_prefix_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_prefix_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_prefix_hash();
  PROTOBUF_NODISCARD std::string* release_tx_prefix_hash();
  void set_allocated_tx_prefix_hash(std::string* tx_prefix_hash);
  private:
  const std::string& _internal_tx_prefix_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_prefix_hash(const std::string& value);
  std::string* _internal_mutable_tx_prefix_hash();
  public:

  // optional bytes full_message_hash = 5;
  bool has_full_message_hash() const;
  private:
  bool _internal_has_full_message_hash() const;
  public:
  void clear_full_message_hash();
  const std::string& full_message_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_message_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_message_hash();
  PROTOBUF_NODISCARD std::string* release_full_message_hash();
  void set_allocated_full_message_hash(std::string* full_message_hash);
  private:
  const std::string& _internal_full_message_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_message_hash(const std::string& value);
  std::string* _internal_mutable_full_message_hash();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
  bool has_rv() const;
  private:
  bool _internal_has_rv() const;
  public:
  void clear_rv();
  const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& rv() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* release_rv();
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* mutable_rv();
  void set_allocated_rv(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& _internal_rv() const;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* _internal_mutable_rv();
  public:
  void unsafe_arena_set_allocated_rv(
      ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv);
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* unsafe_arena_release_rv();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_prefix_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_message_hash_;
    ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSignInputRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSignInputRequest) */ {
 public:
  inline MoneroTransactionSignInputRequest() : MoneroTransactionSignInputRequest(nullptr) {}
  ~MoneroTransactionSignInputRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSignInputRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSignInputRequest(const MoneroTransactionSignInputRequest& from);
  MoneroTransactionSignInputRequest(MoneroTransactionSignInputRequest&& from) noexcept
    : MoneroTransactionSignInputRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSignInputRequest& operator=(const MoneroTransactionSignInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSignInputRequest& operator=(MoneroTransactionSignInputRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSignInputRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSignInputRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSignInputRequest*>(
               &_MoneroTransactionSignInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MoneroTransactionSignInputRequest& a, MoneroTransactionSignInputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSignInputRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSignInputRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSignInputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSignInputRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSignInputRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSignInputRequest& from) {
    MoneroTransactionSignInputRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSignInputRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSignInputRequest";
  }
  protected:
  explicit MoneroTransactionSignInputRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViniFieldNumber = 2,
    kViniHmacFieldNumber = 3,
    kPseudoOutFieldNumber = 4,
    kPseudoOutHmacFieldNumber = 5,
    kPseudoOutAlphaFieldNumber = 6,
    kSpendKeyFieldNumber = 7,
    kSrcEntrFieldNumber = 1,
    kOrigIdxFieldNumber = 8,
  };
  // optional bytes vini = 2;
  bool has_vini() const;
  private:
  bool _internal_has_vini() const;
  public:
  void clear_vini();
  const std::string& vini() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vini(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vini();
  PROTOBUF_NODISCARD std::string* release_vini();
  void set_allocated_vini(std::string* vini);
  private:
  const std::string& _internal_vini() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vini(const std::string& value);
  std::string* _internal_mutable_vini();
  public:

  // optional bytes vini_hmac = 3;
  bool has_vini_hmac() const;
  private:
  bool _internal_has_vini_hmac() const;
  public:
  void clear_vini_hmac();
  const std::string& vini_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vini_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vini_hmac();
  PROTOBUF_NODISCARD std::string* release_vini_hmac();
  void set_allocated_vini_hmac(std::string* vini_hmac);
  private:
  const std::string& _internal_vini_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vini_hmac(const std::string& value);
  std::string* _internal_mutable_vini_hmac();
  public:

  // optional bytes pseudo_out = 4;
  bool has_pseudo_out() const;
  private:
  bool _internal_has_pseudo_out() const;
  public:
  void clear_pseudo_out();
  const std::string& pseudo_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out();
  PROTOBUF_NODISCARD std::string* release_pseudo_out();
  void set_allocated_pseudo_out(std::string* pseudo_out);
  private:
  const std::string& _internal_pseudo_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out(const std::string& value);
  std::string* _internal_mutable_pseudo_out();
  public:

  // optional bytes pseudo_out_hmac = 5;
  bool has_pseudo_out_hmac() const;
  private:
  bool _internal_has_pseudo_out_hmac() const;
  public:
  void clear_pseudo_out_hmac();
  const std::string& pseudo_out_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out_hmac();
  PROTOBUF_NODISCARD std::string* release_pseudo_out_hmac();
  void set_allocated_pseudo_out_hmac(std::string* pseudo_out_hmac);
  private:
  const std::string& _internal_pseudo_out_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out_hmac(const std::string& value);
  std::string* _internal_mutable_pseudo_out_hmac();
  public:

  // optional bytes pseudo_out_alpha = 6;
  bool has_pseudo_out_alpha() const;
  private:
  bool _internal_has_pseudo_out_alpha() const;
  public:
  void clear_pseudo_out_alpha();
  const std::string& pseudo_out_alpha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out_alpha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out_alpha();
  PROTOBUF_NODISCARD std::string* release_pseudo_out_alpha();
  void set_allocated_pseudo_out_alpha(std::string* pseudo_out_alpha);
  private:
  const std::string& _internal_pseudo_out_alpha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out_alpha(const std::string& value);
  std::string* _internal_mutable_pseudo_out_alpha();
  public:

  // optional bytes spend_key = 7;
  bool has_spend_key() const;
  private:
  bool _internal_has_spend_key() const;
  public:
  void clear_spend_key();
  const std::string& spend_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spend_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spend_key();
  PROTOBUF_NODISCARD std::string* release_spend_key();
  void set_allocated_spend_key(std::string* spend_key);
  private:
  const std::string& _internal_spend_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spend_key(const std::string& value);
  std::string* _internal_mutable_spend_key();
  public:

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  bool has_src_entr() const;
  private:
  bool _internal_has_src_entr() const;
  public:
  void clear_src_entr();
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  PROTOBUF_NODISCARD ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);
  private:
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& _internal_src_entr() const;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* _internal_mutable_src_entr();
  public:
  void unsafe_arena_set_allocated_src_entr(
      ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* unsafe_arena_release_src_entr();

  // optional uint32 orig_idx = 8;
  bool has_orig_idx() const;
  private:
  bool _internal_has_orig_idx() const;
  public:
  void clear_orig_idx();
  uint32_t orig_idx() const;
  void set_orig_idx(uint32_t value);
  private:
  uint32_t _internal_orig_idx() const;
  void _internal_set_orig_idx(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vini_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vini_hmac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_hmac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_alpha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spend_key_;
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
    uint32_t orig_idx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionSignInputAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionSignInputAck) */ {
 public:
  inline MoneroTransactionSignInputAck() : MoneroTransactionSignInputAck(nullptr) {}
  ~MoneroTransactionSignInputAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionSignInputAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionSignInputAck(const MoneroTransactionSignInputAck& from);
  MoneroTransactionSignInputAck(MoneroTransactionSignInputAck&& from) noexcept
    : MoneroTransactionSignInputAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionSignInputAck& operator=(const MoneroTransactionSignInputAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionSignInputAck& operator=(MoneroTransactionSignInputAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionSignInputAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionSignInputAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionSignInputAck*>(
               &_MoneroTransactionSignInputAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MoneroTransactionSignInputAck& a, MoneroTransactionSignInputAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionSignInputAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionSignInputAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionSignInputAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionSignInputAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionSignInputAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionSignInputAck& from) {
    MoneroTransactionSignInputAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionSignInputAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionSignInputAck";
  }
  protected:
  explicit MoneroTransactionSignInputAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kPseudoOutFieldNumber = 2,
  };
  // optional bytes signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional bytes pseudo_out = 2;
  bool has_pseudo_out() const;
  private:
  bool _internal_has_pseudo_out() const;
  public:
  void clear_pseudo_out();
  const std::string& pseudo_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_out();
  PROTOBUF_NODISCARD std::string* release_pseudo_out();
  void set_allocated_pseudo_out(std::string* pseudo_out);
  private:
  const std::string& _internal_pseudo_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_out(const std::string& value);
  std::string* _internal_mutable_pseudo_out();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_out_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionFinalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionFinalRequest) */ {
 public:
  inline MoneroTransactionFinalRequest() : MoneroTransactionFinalRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroTransactionFinalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionFinalRequest(const MoneroTransactionFinalRequest& from);
  MoneroTransactionFinalRequest(MoneroTransactionFinalRequest&& from) noexcept
    : MoneroTransactionFinalRequest() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionFinalRequest& operator=(const MoneroTransactionFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionFinalRequest& operator=(MoneroTransactionFinalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionFinalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionFinalRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionFinalRequest*>(
               &_MoneroTransactionFinalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MoneroTransactionFinalRequest& a, MoneroTransactionFinalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionFinalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionFinalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionFinalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionFinalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroTransactionFinalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroTransactionFinalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionFinalRequest";
  }
  protected:
  explicit MoneroTransactionFinalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroTransactionFinalAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroTransactionFinalAck) */ {
 public:
  inline MoneroTransactionFinalAck() : MoneroTransactionFinalAck(nullptr) {}
  ~MoneroTransactionFinalAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroTransactionFinalAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroTransactionFinalAck(const MoneroTransactionFinalAck& from);
  MoneroTransactionFinalAck(MoneroTransactionFinalAck&& from) noexcept
    : MoneroTransactionFinalAck() {
    *this = ::std::move(from);
  }

  inline MoneroTransactionFinalAck& operator=(const MoneroTransactionFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroTransactionFinalAck& operator=(MoneroTransactionFinalAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroTransactionFinalAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroTransactionFinalAck* internal_default_instance() {
    return reinterpret_cast<const MoneroTransactionFinalAck*>(
               &_MoneroTransactionFinalAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(MoneroTransactionFinalAck& a, MoneroTransactionFinalAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroTransactionFinalAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroTransactionFinalAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroTransactionFinalAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroTransactionFinalAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroTransactionFinalAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroTransactionFinalAck& from) {
    MoneroTransactionFinalAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroTransactionFinalAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroTransactionFinalAck";
  }
  protected:
  explicit MoneroTransactionFinalAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoutKeyFieldNumber = 1,
    kSaltFieldNumber = 2,
    kRandMultFieldNumber = 3,
    kTxEncKeysFieldNumber = 4,
    kOpeningKeyFieldNumber = 5,
  };
  // optional bytes cout_key = 1;
  bool has_cout_key() const;
  private:
  bool _internal_has_cout_key() const;
  public:
  void clear_cout_key();
  const std::string& cout_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cout_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cout_key();
  PROTOBUF_NODISCARD std::string* release_cout_key();
  void set_allocated_cout_key(std::string* cout_key);
  private:
  const std::string& _internal_cout_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cout_key(const std::string& value);
  std::string* _internal_mutable_cout_key();
  public:

  // optional bytes salt = 2;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // optional bytes rand_mult = 3;
  bool has_rand_mult() const;
  private:
  bool _internal_has_rand_mult() const;
  public:
  void clear_rand_mult();
  const std::string& rand_mult() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rand_mult(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rand_mult();
  PROTOBUF_NODISCARD std::string* release_rand_mult();
  void set_allocated_rand_mult(std::string* rand_mult);
  private:
  const std::string& _internal_rand_mult() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rand_mult(const std::string& value);
  std::string* _internal_mutable_rand_mult();
  public:

  // optional bytes tx_enc_keys = 4;
  bool has_tx_enc_keys() const;
  private:
  bool _internal_has_tx_enc_keys() const;
  public:
  void clear_tx_enc_keys();
  const std::string& tx_enc_keys() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_enc_keys(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_enc_keys();
  PROTOBUF_NODISCARD std::string* release_tx_enc_keys();
  void set_allocated_tx_enc_keys(std::string* tx_enc_keys);
  private:
  const std::string& _internal_tx_enc_keys() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_enc_keys(const std::string& value);
  std::string* _internal_mutable_tx_enc_keys();
  public:

  // optional bytes opening_key = 5;
  bool has_opening_key() const;
  private:
  bool _internal_has_opening_key() const;
  public:
  void clear_opening_key();
  const std::string& opening_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opening_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opening_key();
  PROTOBUF_NODISCARD std::string* release_opening_key();
  void set_allocated_opening_key(std::string* opening_key);
  private:
  const std::string& _internal_opening_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opening_key(const std::string& value);
  std::string* _internal_mutable_opening_key();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionFinalAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cout_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rand_mult_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_enc_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opening_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList) */ {
 public:
  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList() : MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(nullptr) {}
  ~MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);
  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList&& from) noexcept
    : MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& operator=(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& operator=(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList*>(
               &_MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& a, MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from) {
    MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList";
  }
  protected:
  explicit MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinorIndicesFieldNumber = 2,
    kAccountFieldNumber = 1,
  };
  // repeated uint32 minor_indices = 2;
  int minor_indices_size() const;
  private:
  int _internal_minor_indices_size() const;
  public:
  void clear_minor_indices();
  private:
  uint32_t _internal_minor_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_minor_indices() const;
  void _internal_add_minor_indices(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_minor_indices();
  public:
  uint32_t minor_indices(int index) const;
  void set_minor_indices(int index, uint32_t value);
  void add_minor_indices(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      minor_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_minor_indices();

  // required uint32 account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  uint32_t account() const;
  void set_account(uint32_t value);
  private:
  uint32_t _internal_account() const;
  void _internal_set_account(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > minor_indices_;
    uint32_t account_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest) */ {
 public:
  inline MoneroKeyImageExportInitRequest() : MoneroKeyImageExportInitRequest(nullptr) {}
  ~MoneroKeyImageExportInitRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageExportInitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageExportInitRequest(const MoneroKeyImageExportInitRequest& from);
  MoneroKeyImageExportInitRequest(MoneroKeyImageExportInitRequest&& from) noexcept
    : MoneroKeyImageExportInitRequest() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageExportInitRequest& operator=(const MoneroKeyImageExportInitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageExportInitRequest& operator=(MoneroKeyImageExportInitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageExportInitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageExportInitRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageExportInitRequest*>(
               &_MoneroKeyImageExportInitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MoneroKeyImageExportInitRequest& a, MoneroKeyImageExportInitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageExportInitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageExportInitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageExportInitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageExportInitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageExportInitRequest& from) {
    MoneroKeyImageExportInitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageExportInitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageExportInitRequest";
  }
  protected:
  explicit MoneroKeyImageExportInitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList MoneroSubAddressIndicesList;

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 3,
    kSubsFieldNumber = 5,
    kHashFieldNumber = 2,
    kNumFieldNumber = 1,
    kNetworkTypeFieldNumber = 4,
  };
  // repeated uint32 address_n = 3;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
  int subs_size() const;
  private:
  int _internal_subs_size() const;
  public:
  void clear_subs();
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* mutable_subs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >*
      mutable_subs();
  private:
  const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& _internal_subs(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* _internal_add_subs();
  public:
  const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& subs(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* add_subs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >&
      subs() const;

  // required bytes hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // required uint64 num = 1;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  uint64_t num() const;
  void set_num(uint64_t value);
  private:
  uint64_t _internal_num() const;
  void _internal_set_num(uint64_t value);
  public:

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 4 [default = MAINNET];
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::hw::trezor::messages::monero::MoneroNetworkType network_type() const;
  void set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  private:
  ::hw::trezor::messages::monero::MoneroNetworkType _internal_network_type() const;
  void _internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList > subs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    uint64_t num_;
    int network_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageExportInitAck) */ {
 public:
  inline MoneroKeyImageExportInitAck() : MoneroKeyImageExportInitAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageExportInitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageExportInitAck(const MoneroKeyImageExportInitAck& from);
  MoneroKeyImageExportInitAck(MoneroKeyImageExportInitAck&& from) noexcept
    : MoneroKeyImageExportInitAck() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageExportInitAck& operator=(const MoneroKeyImageExportInitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageExportInitAck& operator=(MoneroKeyImageExportInitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageExportInitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageExportInitAck* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageExportInitAck*>(
               &_MoneroKeyImageExportInitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MoneroKeyImageExportInitAck& a, MoneroKeyImageExportInitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageExportInitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageExportInitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageExportInitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageExportInitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroKeyImageExportInitAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroKeyImageExportInitAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageExportInitAck";
  }
  protected:
  explicit MoneroKeyImageExportInitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepRequest_MoneroTransferDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails) */ {
 public:
  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails() : MoneroKeyImageSyncStepRequest_MoneroTransferDetails(nullptr) {}
  ~MoneroKeyImageSyncStepRequest_MoneroTransferDetails() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepRequest_MoneroTransferDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageSyncStepRequest_MoneroTransferDetails(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);
  MoneroKeyImageSyncStepRequest_MoneroTransferDetails(MoneroKeyImageSyncStepRequest_MoneroTransferDetails&& from) noexcept
    : MoneroKeyImageSyncStepRequest_MoneroTransferDetails() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails& operator=(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails& operator=(MoneroKeyImageSyncStepRequest_MoneroTransferDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageSyncStepRequest_MoneroTransferDetails* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepRequest_MoneroTransferDetails*>(
               &_MoneroKeyImageSyncStepRequest_MoneroTransferDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails& a, MoneroKeyImageSyncStepRequest_MoneroTransferDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepRequest_MoneroTransferDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from) {
    MoneroKeyImageSyncStepRequest_MoneroTransferDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails";
  }
  protected:
  explicit MoneroKeyImageSyncStepRequest_MoneroTransferDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalTxPubKeysFieldNumber = 3,
    kOutKeyFieldNumber = 1,
    kTxPubKeyFieldNumber = 2,
    kInternalOutputIndexFieldNumber = 4,
    kSubAddrMajorFieldNumber = 5,
    kSubAddrMinorFieldNumber = 6,
  };
  // repeated bytes additional_tx_pub_keys = 3;
  int additional_tx_pub_keys_size() const;
  private:
  int _internal_additional_tx_pub_keys_size() const;
  public:
  void clear_additional_tx_pub_keys();
  const std::string& additional_tx_pub_keys(int index) const;
  std::string* mutable_additional_tx_pub_keys(int index);
  void set_additional_tx_pub_keys(int index, const std::string& value);
  void set_additional_tx_pub_keys(int index, std::string&& value);
  void set_additional_tx_pub_keys(int index, const char* value);
  void set_additional_tx_pub_keys(int index, const void* value, size_t size);
  std::string* add_additional_tx_pub_keys();
  void add_additional_tx_pub_keys(const std::string& value);
  void add_additional_tx_pub_keys(std::string&& value);
  void add_additional_tx_pub_keys(const char* value);
  void add_additional_tx_pub_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_tx_pub_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_tx_pub_keys();
  private:
  const std::string& _internal_additional_tx_pub_keys(int index) const;
  std::string* _internal_add_additional_tx_pub_keys();
  public:

  // required bytes out_key = 1;
  bool has_out_key() const;
  private:
  bool _internal_has_out_key() const;
  public:
  void clear_out_key();
  const std::string& out_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_out_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_out_key();
  PROTOBUF_NODISCARD std::string* release_out_key();
  void set_allocated_out_key(std::string* out_key);
  private:
  const std::string& _internal_out_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_key(const std::string& value);
  std::string* _internal_mutable_out_key();
  public:

  // required bytes tx_pub_key = 2;
  bool has_tx_pub_key() const;
  private:
  bool _internal_has_tx_pub_key() const;
  public:
  void clear_tx_pub_key();
  const std::string& tx_pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_pub_key();
  PROTOBUF_NODISCARD std::string* release_tx_pub_key();
  void set_allocated_tx_pub_key(std::string* tx_pub_key);
  private:
  const std::string& _internal_tx_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_pub_key(const std::string& value);
  std::string* _internal_mutable_tx_pub_key();
  public:

  // required uint64 internal_output_index = 4;
  bool has_internal_output_index() const;
  private:
  bool _internal_has_internal_output_index() const;
  public:
  void clear_internal_output_index();
  uint64_t internal_output_index() const;
  void set_internal_output_index(uint64_t value);
  private:
  uint64_t _internal_internal_output_index() const;
  void _internal_set_internal_output_index(uint64_t value);
  public:

  // optional uint32 sub_addr_major = 5;
  bool has_sub_addr_major() const;
  private:
  bool _internal_has_sub_addr_major() const;
  public:
  void clear_sub_addr_major();
  uint32_t sub_addr_major() const;
  void set_sub_addr_major(uint32_t value);
  private:
  uint32_t _internal_sub_addr_major() const;
  void _internal_set_sub_addr_major(uint32_t value);
  public:

  // optional uint32 sub_addr_minor = 6;
  bool has_sub_addr_minor() const;
  private:
  bool _internal_has_sub_addr_minor() const;
  public:
  void clear_sub_addr_minor();
  uint32_t sub_addr_minor() const;
  void set_sub_addr_minor(uint32_t value);
  private:
  uint32_t _internal_sub_addr_minor() const;
  void _internal_set_sub_addr_minor(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_tx_pub_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr out_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_pub_key_;
    uint64_t internal_output_index_;
    uint32_t sub_addr_major_;
    uint32_t sub_addr_minor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest) */ {
 public:
  inline MoneroKeyImageSyncStepRequest() : MoneroKeyImageSyncStepRequest(nullptr) {}
  ~MoneroKeyImageSyncStepRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageSyncStepRequest(const MoneroKeyImageSyncStepRequest& from);
  MoneroKeyImageSyncStepRequest(MoneroKeyImageSyncStepRequest&& from) noexcept
    : MoneroKeyImageSyncStepRequest() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepRequest& operator=(const MoneroKeyImageSyncStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageSyncStepRequest& operator=(MoneroKeyImageSyncStepRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageSyncStepRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageSyncStepRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepRequest*>(
               &_MoneroKeyImageSyncStepRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MoneroKeyImageSyncStepRequest& a, MoneroKeyImageSyncStepRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageSyncStepRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageSyncStepRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageSyncStepRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageSyncStepRequest& from) {
    MoneroKeyImageSyncStepRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest";
  }
  protected:
  explicit MoneroKeyImageSyncStepRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageSyncStepRequest_MoneroTransferDetails MoneroTransferDetails;

  // accessors -------------------------------------------------------

  enum : int {
    kTdisFieldNumber = 1,
  };
  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
  int tdis_size() const;
  private:
  int _internal_tdis_size() const;
  public:
  void clear_tdis();
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* mutable_tdis(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >*
      mutable_tdis();
  private:
  const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& _internal_tdis(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* _internal_add_tdis();
  public:
  const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& tdis(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* add_tdis();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >&
      tdis() const;

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails > tdis_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage) */ {
 public:
  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage() : MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(nullptr) {}
  ~MoneroKeyImageSyncStepAck_MoneroExportedKeyImage() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);
  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage&& from) noexcept
    : MoneroKeyImageSyncStepAck_MoneroExportedKeyImage() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& operator=(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& operator=(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage*>(
               &_MoneroKeyImageSyncStepAck_MoneroExportedKeyImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& a, MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from) {
    MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage";
  }
  protected:
  explicit MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIvFieldNumber = 1,
    kBlobFieldNumber = 3,
  };
  // optional bytes iv = 1;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // optional bytes blob = 3;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const std::string& blob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blob();
  PROTOBUF_NODISCARD std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  private:
  const std::string& _internal_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck) */ {
 public:
  inline MoneroKeyImageSyncStepAck() : MoneroKeyImageSyncStepAck(nullptr) {}
  ~MoneroKeyImageSyncStepAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageSyncStepAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageSyncStepAck(const MoneroKeyImageSyncStepAck& from);
  MoneroKeyImageSyncStepAck(MoneroKeyImageSyncStepAck&& from) noexcept
    : MoneroKeyImageSyncStepAck() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncStepAck& operator=(const MoneroKeyImageSyncStepAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageSyncStepAck& operator=(MoneroKeyImageSyncStepAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageSyncStepAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageSyncStepAck* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncStepAck*>(
               &_MoneroKeyImageSyncStepAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MoneroKeyImageSyncStepAck& a, MoneroKeyImageSyncStepAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageSyncStepAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageSyncStepAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncStepAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageSyncStepAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageSyncStepAck& from) {
    MoneroKeyImageSyncStepAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncStepAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageSyncStepAck";
  }
  protected:
  explicit MoneroKeyImageSyncStepAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageSyncStepAck_MoneroExportedKeyImage MoneroExportedKeyImage;

  // accessors -------------------------------------------------------

  enum : int {
    kKisFieldNumber = 1,
  };
  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
  int kis_size() const;
  private:
  int _internal_kis_size() const;
  public:
  void clear_kis();
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* mutable_kis(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >*
      mutable_kis();
  private:
  const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& _internal_kis(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* _internal_add_kis();
  public:
  const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& kis(int index) const;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* add_kis();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >&
      kis() const;

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage > kis_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncFinalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest) */ {
 public:
  inline MoneroKeyImageSyncFinalRequest() : MoneroKeyImageSyncFinalRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageSyncFinalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageSyncFinalRequest(const MoneroKeyImageSyncFinalRequest& from);
  MoneroKeyImageSyncFinalRequest(MoneroKeyImageSyncFinalRequest&& from) noexcept
    : MoneroKeyImageSyncFinalRequest() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncFinalRequest& operator=(const MoneroKeyImageSyncFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageSyncFinalRequest& operator=(MoneroKeyImageSyncFinalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageSyncFinalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageSyncFinalRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncFinalRequest*>(
               &_MoneroKeyImageSyncFinalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MoneroKeyImageSyncFinalRequest& a, MoneroKeyImageSyncFinalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageSyncFinalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageSyncFinalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncFinalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncFinalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroKeyImageSyncFinalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroKeyImageSyncFinalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest";
  }
  protected:
  explicit MoneroKeyImageSyncFinalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncFinalAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck) */ {
 public:
  inline MoneroKeyImageSyncFinalAck() : MoneroKeyImageSyncFinalAck(nullptr) {}
  ~MoneroKeyImageSyncFinalAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroKeyImageSyncFinalAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroKeyImageSyncFinalAck(const MoneroKeyImageSyncFinalAck& from);
  MoneroKeyImageSyncFinalAck(MoneroKeyImageSyncFinalAck&& from) noexcept
    : MoneroKeyImageSyncFinalAck() {
    *this = ::std::move(from);
  }

  inline MoneroKeyImageSyncFinalAck& operator=(const MoneroKeyImageSyncFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroKeyImageSyncFinalAck& operator=(MoneroKeyImageSyncFinalAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroKeyImageSyncFinalAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroKeyImageSyncFinalAck* internal_default_instance() {
    return reinterpret_cast<const MoneroKeyImageSyncFinalAck*>(
               &_MoneroKeyImageSyncFinalAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(MoneroKeyImageSyncFinalAck& a, MoneroKeyImageSyncFinalAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroKeyImageSyncFinalAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroKeyImageSyncFinalAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncFinalAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroKeyImageSyncFinalAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroKeyImageSyncFinalAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroKeyImageSyncFinalAck& from) {
    MoneroKeyImageSyncFinalAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroKeyImageSyncFinalAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck";
  }
  protected:
  explicit MoneroKeyImageSyncFinalAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncKeyFieldNumber = 1,
  };
  // optional bytes enc_key = 1;
  bool has_enc_key() const;
  private:
  bool _internal_has_enc_key() const;
  public:
  void clear_enc_key();
  const std::string& enc_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enc_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enc_key();
  PROTOBUF_NODISCARD std::string* release_enc_key();
  void set_allocated_enc_key(std::string* enc_key);
  private:
  const std::string& _internal_enc_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enc_key(const std::string& value);
  std::string* _internal_mutable_enc_key();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enc_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetTxKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetTxKeyRequest) */ {
 public:
  inline MoneroGetTxKeyRequest() : MoneroGetTxKeyRequest(nullptr) {}
  ~MoneroGetTxKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroGetTxKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroGetTxKeyRequest(const MoneroGetTxKeyRequest& from);
  MoneroGetTxKeyRequest(MoneroGetTxKeyRequest&& from) noexcept
    : MoneroGetTxKeyRequest() {
    *this = ::std::move(from);
  }

  inline MoneroGetTxKeyRequest& operator=(const MoneroGetTxKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroGetTxKeyRequest& operator=(MoneroGetTxKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroGetTxKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroGetTxKeyRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroGetTxKeyRequest*>(
               &_MoneroGetTxKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MoneroGetTxKeyRequest& a, MoneroGetTxKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroGetTxKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroGetTxKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroGetTxKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroGetTxKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroGetTxKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroGetTxKeyRequest& from) {
    MoneroGetTxKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetTxKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroGetTxKeyRequest";
  }
  protected:
  explicit MoneroGetTxKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 1,
    kSalt1FieldNumber = 3,
    kSalt2FieldNumber = 4,
    kTxEncKeysFieldNumber = 5,
    kTxPrefixHashFieldNumber = 6,
    kViewPublicKeyFieldNumber = 8,
    kNetworkTypeFieldNumber = 2,
    kReasonFieldNumber = 7,
  };
  // repeated uint32 address_n = 1;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // required bytes salt1 = 3;
  bool has_salt1() const;
  private:
  bool _internal_has_salt1() const;
  public:
  void clear_salt1();
  const std::string& salt1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt1();
  PROTOBUF_NODISCARD std::string* release_salt1();
  void set_allocated_salt1(std::string* salt1);
  private:
  const std::string& _internal_salt1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt1(const std::string& value);
  std::string* _internal_mutable_salt1();
  public:

  // required bytes salt2 = 4;
  bool has_salt2() const;
  private:
  bool _internal_has_salt2() const;
  public:
  void clear_salt2();
  const std::string& salt2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt2();
  PROTOBUF_NODISCARD std::string* release_salt2();
  void set_allocated_salt2(std::string* salt2);
  private:
  const std::string& _internal_salt2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt2(const std::string& value);
  std::string* _internal_mutable_salt2();
  public:

  // required bytes tx_enc_keys = 5;
  bool has_tx_enc_keys() const;
  private:
  bool _internal_has_tx_enc_keys() const;
  public:
  void clear_tx_enc_keys();
  const std::string& tx_enc_keys() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_enc_keys(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_enc_keys();
  PROTOBUF_NODISCARD std::string* release_tx_enc_keys();
  void set_allocated_tx_enc_keys(std::string* tx_enc_keys);
  private:
  const std::string& _internal_tx_enc_keys() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_enc_keys(const std::string& value);
  std::string* _internal_mutable_tx_enc_keys();
  public:

  // required bytes tx_prefix_hash = 6;
  bool has_tx_prefix_hash() const;
  private:
  bool _internal_has_tx_prefix_hash() const;
  public:
  void clear_tx_prefix_hash();
  const std::string& tx_prefix_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_prefix_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_prefix_hash();
  PROTOBUF_NODISCARD std::string* release_tx_prefix_hash();
  void set_allocated_tx_prefix_hash(std::string* tx_prefix_hash);
  private:
  const std::string& _internal_tx_prefix_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_prefix_hash(const std::string& value);
  std::string* _internal_mutable_tx_prefix_hash();
  public:

  // optional bytes view_public_key = 8;
  bool has_view_public_key() const;
  private:
  bool _internal_has_view_public_key() const;
  public:
  void clear_view_public_key();
  const std::string& view_public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_public_key();
  PROTOBUF_NODISCARD std::string* release_view_public_key();
  void set_allocated_view_public_key(std::string* view_public_key);
  private:
  const std::string& _internal_view_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_public_key(const std::string& value);
  std::string* _internal_mutable_view_public_key();
  public:

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::hw::trezor::messages::monero::MoneroNetworkType network_type() const;
  void set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  private:
  ::hw::trezor::messages::monero::MoneroNetworkType _internal_network_type() const;
  void _internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  public:

  // optional uint32 reason = 7;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  uint32_t reason() const;
  void set_reason(uint32_t value);
  private:
  uint32_t _internal_reason() const;
  void _internal_set_reason(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetTxKeyRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_enc_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_prefix_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_public_key_;
    int network_type_;
    uint32_t reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroGetTxKeyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroGetTxKeyAck) */ {
 public:
  inline MoneroGetTxKeyAck() : MoneroGetTxKeyAck(nullptr) {}
  ~MoneroGetTxKeyAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroGetTxKeyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroGetTxKeyAck(const MoneroGetTxKeyAck& from);
  MoneroGetTxKeyAck(MoneroGetTxKeyAck&& from) noexcept
    : MoneroGetTxKeyAck() {
    *this = ::std::move(from);
  }

  inline MoneroGetTxKeyAck& operator=(const MoneroGetTxKeyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroGetTxKeyAck& operator=(MoneroGetTxKeyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroGetTxKeyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroGetTxKeyAck* internal_default_instance() {
    return reinterpret_cast<const MoneroGetTxKeyAck*>(
               &_MoneroGetTxKeyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(MoneroGetTxKeyAck& a, MoneroGetTxKeyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroGetTxKeyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroGetTxKeyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroGetTxKeyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroGetTxKeyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroGetTxKeyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroGetTxKeyAck& from) {
    MoneroGetTxKeyAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroGetTxKeyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroGetTxKeyAck";
  }
  protected:
  explicit MoneroGetTxKeyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltFieldNumber = 1,
    kTxKeysFieldNumber = 2,
    kTxDerivationsFieldNumber = 3,
  };
  // optional bytes salt = 1;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // optional bytes tx_keys = 2;
  bool has_tx_keys() const;
  private:
  bool _internal_has_tx_keys() const;
  public:
  void clear_tx_keys();
  const std::string& tx_keys() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_keys(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_keys();
  PROTOBUF_NODISCARD std::string* release_tx_keys();
  void set_allocated_tx_keys(std::string* tx_keys);
  private:
  const std::string& _internal_tx_keys() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_keys(const std::string& value);
  std::string* _internal_mutable_tx_keys();
  public:

  // optional bytes tx_derivations = 3;
  bool has_tx_derivations() const;
  private:
  bool _internal_has_tx_derivations() const;
  public:
  void clear_tx_derivations();
  const std::string& tx_derivations() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_derivations(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_derivations();
  PROTOBUF_NODISCARD std::string* release_tx_derivations();
  void set_allocated_tx_derivations(std::string* tx_derivations);
  private:
  const std::string& _internal_tx_derivations() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_derivations(const std::string& value);
  std::string* _internal_mutable_tx_derivations();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetTxKeyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_derivations_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStartRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest) */ {
 public:
  inline MoneroLiveRefreshStartRequest() : MoneroLiveRefreshStartRequest(nullptr) {}
  ~MoneroLiveRefreshStartRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroLiveRefreshStartRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroLiveRefreshStartRequest(const MoneroLiveRefreshStartRequest& from);
  MoneroLiveRefreshStartRequest(MoneroLiveRefreshStartRequest&& from) noexcept
    : MoneroLiveRefreshStartRequest() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStartRequest& operator=(const MoneroLiveRefreshStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroLiveRefreshStartRequest& operator=(MoneroLiveRefreshStartRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroLiveRefreshStartRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroLiveRefreshStartRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStartRequest*>(
               &_MoneroLiveRefreshStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MoneroLiveRefreshStartRequest& a, MoneroLiveRefreshStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroLiveRefreshStartRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroLiveRefreshStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroLiveRefreshStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStartRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroLiveRefreshStartRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroLiveRefreshStartRequest& from) {
    MoneroLiveRefreshStartRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStartRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroLiveRefreshStartRequest";
  }
  protected:
  explicit MoneroLiveRefreshStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressNFieldNumber = 1,
    kNetworkTypeFieldNumber = 2,
  };
  // repeated uint32 address_n = 1;
  int address_n_size() const;
  private:
  int _internal_address_n_size() const;
  public:
  void clear_address_n();
  private:
  uint32_t _internal_address_n(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_address_n() const;
  void _internal_add_address_n(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_address_n();
  public:
  uint32_t address_n(int index) const;
  void set_address_n(int index, uint32_t value);
  void add_address_n(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      address_n() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_address_n();

  // optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  ::hw::trezor::messages::monero::MoneroNetworkType network_type() const;
  void set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  private:
  ::hw::trezor::messages::monero::MoneroNetworkType _internal_network_type() const;
  void _internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > address_n_;
    int network_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStartAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStartAck) */ {
 public:
  inline MoneroLiveRefreshStartAck() : MoneroLiveRefreshStartAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroLiveRefreshStartAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroLiveRefreshStartAck(const MoneroLiveRefreshStartAck& from);
  MoneroLiveRefreshStartAck(MoneroLiveRefreshStartAck&& from) noexcept
    : MoneroLiveRefreshStartAck() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStartAck& operator=(const MoneroLiveRefreshStartAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroLiveRefreshStartAck& operator=(MoneroLiveRefreshStartAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroLiveRefreshStartAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroLiveRefreshStartAck* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStartAck*>(
               &_MoneroLiveRefreshStartAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MoneroLiveRefreshStartAck& a, MoneroLiveRefreshStartAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroLiveRefreshStartAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroLiveRefreshStartAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroLiveRefreshStartAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStartAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroLiveRefreshStartAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroLiveRefreshStartAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroLiveRefreshStartAck";
  }
  protected:
  explicit MoneroLiveRefreshStartAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStartAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStepRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest) */ {
 public:
  inline MoneroLiveRefreshStepRequest() : MoneroLiveRefreshStepRequest(nullptr) {}
  ~MoneroLiveRefreshStepRequest() override;
  explicit PROTOBUF_CONSTEXPR MoneroLiveRefreshStepRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroLiveRefreshStepRequest(const MoneroLiveRefreshStepRequest& from);
  MoneroLiveRefreshStepRequest(MoneroLiveRefreshStepRequest&& from) noexcept
    : MoneroLiveRefreshStepRequest() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStepRequest& operator=(const MoneroLiveRefreshStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroLiveRefreshStepRequest& operator=(MoneroLiveRefreshStepRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroLiveRefreshStepRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroLiveRefreshStepRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStepRequest*>(
               &_MoneroLiveRefreshStepRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(MoneroLiveRefreshStepRequest& a, MoneroLiveRefreshStepRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroLiveRefreshStepRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroLiveRefreshStepRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroLiveRefreshStepRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStepRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroLiveRefreshStepRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroLiveRefreshStepRequest& from) {
    MoneroLiveRefreshStepRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStepRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroLiveRefreshStepRequest";
  }
  protected:
  explicit MoneroLiveRefreshStepRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutKeyFieldNumber = 1,
    kRecvDerivFieldNumber = 2,
    kRealOutIdxFieldNumber = 3,
    kSubAddrMajorFieldNumber = 4,
    kSubAddrMinorFieldNumber = 5,
  };
  // required bytes out_key = 1;
  bool has_out_key() const;
  private:
  bool _internal_has_out_key() const;
  public:
  void clear_out_key();
  const std::string& out_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_out_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_out_key();
  PROTOBUF_NODISCARD std::string* release_out_key();
  void set_allocated_out_key(std::string* out_key);
  private:
  const std::string& _internal_out_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_key(const std::string& value);
  std::string* _internal_mutable_out_key();
  public:

  // required bytes recv_deriv = 2;
  bool has_recv_deriv() const;
  private:
  bool _internal_has_recv_deriv() const;
  public:
  void clear_recv_deriv();
  const std::string& recv_deriv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recv_deriv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recv_deriv();
  PROTOBUF_NODISCARD std::string* release_recv_deriv();
  void set_allocated_recv_deriv(std::string* recv_deriv);
  private:
  const std::string& _internal_recv_deriv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recv_deriv(const std::string& value);
  std::string* _internal_mutable_recv_deriv();
  public:

  // required uint64 real_out_idx = 3;
  bool has_real_out_idx() const;
  private:
  bool _internal_has_real_out_idx() const;
  public:
  void clear_real_out_idx();
  uint64_t real_out_idx() const;
  void set_real_out_idx(uint64_t value);
  private:
  uint64_t _internal_real_out_idx() const;
  void _internal_set_real_out_idx(uint64_t value);
  public:

  // required uint32 sub_addr_major = 4;
  bool has_sub_addr_major() const;
  private:
  bool _internal_has_sub_addr_major() const;
  public:
  void clear_sub_addr_major();
  uint32_t sub_addr_major() const;
  void set_sub_addr_major(uint32_t value);
  private:
  uint32_t _internal_sub_addr_major() const;
  void _internal_set_sub_addr_major(uint32_t value);
  public:

  // required uint32 sub_addr_minor = 5;
  bool has_sub_addr_minor() const;
  private:
  bool _internal_has_sub_addr_minor() const;
  public:
  void clear_sub_addr_minor();
  uint32_t sub_addr_minor() const;
  void set_sub_addr_minor(uint32_t value);
  private:
  uint32_t _internal_sub_addr_minor() const;
  void _internal_set_sub_addr_minor(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr out_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recv_deriv_;
    uint64_t real_out_idx_;
    uint32_t sub_addr_major_;
    uint32_t sub_addr_minor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshStepAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshStepAck) */ {
 public:
  inline MoneroLiveRefreshStepAck() : MoneroLiveRefreshStepAck(nullptr) {}
  ~MoneroLiveRefreshStepAck() override;
  explicit PROTOBUF_CONSTEXPR MoneroLiveRefreshStepAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroLiveRefreshStepAck(const MoneroLiveRefreshStepAck& from);
  MoneroLiveRefreshStepAck(MoneroLiveRefreshStepAck&& from) noexcept
    : MoneroLiveRefreshStepAck() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshStepAck& operator=(const MoneroLiveRefreshStepAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroLiveRefreshStepAck& operator=(MoneroLiveRefreshStepAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroLiveRefreshStepAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroLiveRefreshStepAck* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshStepAck*>(
               &_MoneroLiveRefreshStepAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(MoneroLiveRefreshStepAck& a, MoneroLiveRefreshStepAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroLiveRefreshStepAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroLiveRefreshStepAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroLiveRefreshStepAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroLiveRefreshStepAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoneroLiveRefreshStepAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoneroLiveRefreshStepAck& from) {
    MoneroLiveRefreshStepAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoneroLiveRefreshStepAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroLiveRefreshStepAck";
  }
  protected:
  explicit MoneroLiveRefreshStepAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSaltFieldNumber = 1,
    kKeyImageFieldNumber = 2,
  };
  // optional bytes salt = 1;
  bool has_salt() const;
  private:
  bool _internal_has_salt() const;
  public:
  void clear_salt();
  const std::string& salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* salt);
  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(const std::string& value);
  std::string* _internal_mutable_salt();
  public:

  // optional bytes key_image = 2;
  bool has_key_image() const;
  private:
  bool _internal_has_key_image() const;
  public:
  void clear_key_image();
  const std::string& key_image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_image();
  PROTOBUF_NODISCARD std::string* release_key_image();
  void set_allocated_key_image(std::string* key_image);
  private:
  const std::string& _internal_key_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_image(const std::string& value);
  std::string* _internal_mutable_key_image();
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshStepAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_image_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshFinalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest) */ {
 public:
  inline MoneroLiveRefreshFinalRequest() : MoneroLiveRefreshFinalRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroLiveRefreshFinalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroLiveRefreshFinalRequest(const MoneroLiveRefreshFinalRequest& from);
  MoneroLiveRefreshFinalRequest(MoneroLiveRefreshFinalRequest&& from) noexcept
    : MoneroLiveRefreshFinalRequest() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshFinalRequest& operator=(const MoneroLiveRefreshFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroLiveRefreshFinalRequest& operator=(MoneroLiveRefreshFinalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroLiveRefreshFinalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroLiveRefreshFinalRequest* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshFinalRequest*>(
               &_MoneroLiveRefreshFinalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(MoneroLiveRefreshFinalRequest& a, MoneroLiveRefreshFinalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroLiveRefreshFinalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroLiveRefreshFinalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroLiveRefreshFinalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroLiveRefreshFinalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroLiveRefreshFinalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroLiveRefreshFinalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest";
  }
  protected:
  explicit MoneroLiveRefreshFinalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshFinalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class MoneroLiveRefreshFinalAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck) */ {
 public:
  inline MoneroLiveRefreshFinalAck() : MoneroLiveRefreshFinalAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoneroLiveRefreshFinalAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoneroLiveRefreshFinalAck(const MoneroLiveRefreshFinalAck& from);
  MoneroLiveRefreshFinalAck(MoneroLiveRefreshFinalAck&& from) noexcept
    : MoneroLiveRefreshFinalAck() {
    *this = ::std::move(from);
  }

  inline MoneroLiveRefreshFinalAck& operator=(const MoneroLiveRefreshFinalAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoneroLiveRefreshFinalAck& operator=(MoneroLiveRefreshFinalAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoneroLiveRefreshFinalAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoneroLiveRefreshFinalAck* internal_default_instance() {
    return reinterpret_cast<const MoneroLiveRefreshFinalAck*>(
               &_MoneroLiveRefreshFinalAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MoneroLiveRefreshFinalAck& a, MoneroLiveRefreshFinalAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoneroLiveRefreshFinalAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoneroLiveRefreshFinalAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoneroLiveRefreshFinalAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoneroLiveRefreshFinalAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoneroLiveRefreshFinalAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoneroLiveRefreshFinalAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.MoneroLiveRefreshFinalAck";
  }
  protected:
  explicit MoneroLiveRefreshFinalAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroLiveRefreshFinalAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class DebugMoneroDiagRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.DebugMoneroDiagRequest) */ {
 public:
  inline DebugMoneroDiagRequest() : DebugMoneroDiagRequest(nullptr) {}
  ~DebugMoneroDiagRequest() override;
  explicit PROTOBUF_CONSTEXPR DebugMoneroDiagRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugMoneroDiagRequest(const DebugMoneroDiagRequest& from);
  DebugMoneroDiagRequest(DebugMoneroDiagRequest&& from) noexcept
    : DebugMoneroDiagRequest() {
    *this = ::std::move(from);
  }

  inline DebugMoneroDiagRequest& operator=(const DebugMoneroDiagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugMoneroDiagRequest& operator=(DebugMoneroDiagRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugMoneroDiagRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugMoneroDiagRequest* internal_default_instance() {
    return reinterpret_cast<const DebugMoneroDiagRequest*>(
               &_DebugMoneroDiagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DebugMoneroDiagRequest& a, DebugMoneroDiagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugMoneroDiagRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugMoneroDiagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugMoneroDiagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugMoneroDiagRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugMoneroDiagRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugMoneroDiagRequest& from) {
    DebugMoneroDiagRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugMoneroDiagRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.DebugMoneroDiagRequest";
  }
  protected:
  explicit DebugMoneroDiagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPdFieldNumber = 4,
    kData1FieldNumber = 5,
    kData2FieldNumber = 6,
    kInsFieldNumber = 1,
    kP1FieldNumber = 2,
    kP2FieldNumber = 3,
  };
  // repeated uint64 pd = 4;
  int pd_size() const;
  private:
  int _internal_pd_size() const;
  public:
  void clear_pd();
  private:
  uint64_t _internal_pd(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_pd() const;
  void _internal_add_pd(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_pd();
  public:
  uint64_t pd(int index) const;
  void set_pd(int index, uint64_t value);
  void add_pd(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      pd() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_pd();

  // optional bytes data1 = 5;
  bool has_data1() const;
  private:
  bool _internal_has_data1() const;
  public:
  void clear_data1();
  const std::string& data1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data1();
  PROTOBUF_NODISCARD std::string* release_data1();
  void set_allocated_data1(std::string* data1);
  private:
  const std::string& _internal_data1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data1(const std::string& value);
  std::string* _internal_mutable_data1();
  public:

  // optional bytes data2 = 6;
  bool has_data2() const;
  private:
  bool _internal_has_data2() const;
  public:
  void clear_data2();
  const std::string& data2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data2();
  PROTOBUF_NODISCARD std::string* release_data2();
  void set_allocated_data2(std::string* data2);
  private:
  const std::string& _internal_data2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data2(const std::string& value);
  std::string* _internal_mutable_data2();
  public:

  // optional uint64 ins = 1;
  bool has_ins() const;
  private:
  bool _internal_has_ins() const;
  public:
  void clear_ins();
  uint64_t ins() const;
  void set_ins(uint64_t value);
  private:
  uint64_t _internal_ins() const;
  void _internal_set_ins(uint64_t value);
  public:

  // optional uint64 p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  uint64_t p1() const;
  void set_p1(uint64_t value);
  private:
  uint64_t _internal_p1() const;
  void _internal_set_p1(uint64_t value);
  public:

  // optional uint64 p2 = 3;
  bool has_p2() const;
  private:
  bool _internal_has_p2() const;
  public:
  void clear_p2();
  uint64_t p2() const;
  void set_p2(uint64_t value);
  private:
  uint64_t _internal_p2() const;
  void _internal_set_p2(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.DebugMoneroDiagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > pd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data2_;
    uint64_t ins_;
    uint64_t p1_;
    uint64_t p2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// -------------------------------------------------------------------

class DebugMoneroDiagAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.monero.DebugMoneroDiagAck) */ {
 public:
  inline DebugMoneroDiagAck() : DebugMoneroDiagAck(nullptr) {}
  ~DebugMoneroDiagAck() override;
  explicit PROTOBUF_CONSTEXPR DebugMoneroDiagAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugMoneroDiagAck(const DebugMoneroDiagAck& from);
  DebugMoneroDiagAck(DebugMoneroDiagAck&& from) noexcept
    : DebugMoneroDiagAck() {
    *this = ::std::move(from);
  }

  inline DebugMoneroDiagAck& operator=(const DebugMoneroDiagAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugMoneroDiagAck& operator=(DebugMoneroDiagAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugMoneroDiagAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugMoneroDiagAck* internal_default_instance() {
    return reinterpret_cast<const DebugMoneroDiagAck*>(
               &_DebugMoneroDiagAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(DebugMoneroDiagAck& a, DebugMoneroDiagAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugMoneroDiagAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugMoneroDiagAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugMoneroDiagAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugMoneroDiagAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugMoneroDiagAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugMoneroDiagAck& from) {
    DebugMoneroDiagAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugMoneroDiagAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hw.trezor.messages.monero.DebugMoneroDiagAck";
  }
  protected:
  explicit DebugMoneroDiagAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPdFieldNumber = 4,
    kData1FieldNumber = 5,
    kData2FieldNumber = 6,
    kInsFieldNumber = 1,
    kP1FieldNumber = 2,
    kP2FieldNumber = 3,
  };
  // repeated uint64 pd = 4;
  int pd_size() const;
  private:
  int _internal_pd_size() const;
  public:
  void clear_pd();
  private:
  uint64_t _internal_pd(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_pd() const;
  void _internal_add_pd(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_pd();
  public:
  uint64_t pd(int index) const;
  void set_pd(int index, uint64_t value);
  void add_pd(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      pd() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_pd();

  // optional bytes data1 = 5;
  bool has_data1() const;
  private:
  bool _internal_has_data1() const;
  public:
  void clear_data1();
  const std::string& data1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data1();
  PROTOBUF_NODISCARD std::string* release_data1();
  void set_allocated_data1(std::string* data1);
  private:
  const std::string& _internal_data1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data1(const std::string& value);
  std::string* _internal_mutable_data1();
  public:

  // optional bytes data2 = 6;
  bool has_data2() const;
  private:
  bool _internal_has_data2() const;
  public:
  void clear_data2();
  const std::string& data2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data2();
  PROTOBUF_NODISCARD std::string* release_data2();
  void set_allocated_data2(std::string* data2);
  private:
  const std::string& _internal_data2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data2(const std::string& value);
  std::string* _internal_mutable_data2();
  public:

  // optional uint64 ins = 1;
  bool has_ins() const;
  private:
  bool _internal_has_ins() const;
  public:
  void clear_ins();
  uint64_t ins() const;
  void set_ins(uint64_t value);
  private:
  uint64_t _internal_ins() const;
  void _internal_set_ins(uint64_t value);
  public:

  // optional uint64 p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  uint64_t p1() const;
  void set_p1(uint64_t value);
  private:
  uint64_t _internal_p1() const;
  void _internal_set_p1(uint64_t value);
  public:

  // optional uint64 p2 = 3;
  bool has_p2() const;
  private:
  bool _internal_has_p2() const;
  public:
  void clear_p2();
  uint64_t p2() const;
  void set_p2(uint64_t value);
  private:
  uint64_t _internal_p2() const;
  void _internal_set_p2(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.DebugMoneroDiagAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > pd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data2_;
    uint64_t ins_;
    uint64_t p1_;
    uint64_t p2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messages_2dmonero_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic

// required bytes dest = 1;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_has_dest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::has_dest() const {
  return _internal_has_dest();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::clear_dest() {
  _impl_.dest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::dest() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
  return _internal_dest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_dest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}
inline std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::mutable_dest() {
  std::string* _s = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_dest() const {
  return _impl_.dest_.Get();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_set_dest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dest_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_mutable_dest() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dest_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::release_dest() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
  if (!_internal_has_dest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_allocated_dest(std::string* dest) {
  if (dest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dest_.SetAllocated(dest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_.IsDefault()) {
    _impl_.dest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.dest)
}

// required bytes commitment = 2;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_has_commitment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::has_commitment() const {
  return _internal_has_commitment();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::clear_commitment() {
  _impl_.commitment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::commitment() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
  return _internal_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_commitment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.commitment_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}
inline std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::mutable_commitment() {
  std::string* _s = _internal_mutable_commitment();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_commitment() const {
  return _impl_.commitment_.Get();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_set_commitment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::_internal_mutable_commitment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::release_commitment() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
  if (!_internal_has_commitment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.commitment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commitment_.IsDefault()) {
    _impl_.commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::set_allocated_commitment(std::string* commitment) {
  if (commitment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.commitment_.SetAllocated(commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commitment_.IsDefault()) {
    _impl_.commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic.commitment)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroOutputEntry

// optional uint64 idx = 1;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::_internal_has_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::has_idx() const {
  return _internal_has_idx();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_idx() {
  _impl_.idx_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t MoneroTransactionSourceEntry_MoneroOutputEntry::_internal_idx() const {
  return _impl_.idx_;
}
inline uint64_t MoneroTransactionSourceEntry_MoneroOutputEntry::idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.idx)
  return _internal_idx();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::_internal_set_idx(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.idx_ = value;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_idx(uint64_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.idx)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::has_key() const {
  return _internal_has_key();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& MoneroTransactionSourceEntry_MoneroOutputEntry::_internal_key() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic&>(
      ::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic& MoneroTransactionSourceEntry_MoneroOutputEntry::key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  return _internal_key();
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::unsafe_arena_set_allocated_key(
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* MoneroTransactionSourceEntry_MoneroOutputEntry::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* MoneroTransactionSourceEntry_MoneroOutputEntry::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* MoneroTransactionSourceEntry_MoneroOutputEntry::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* MoneroTransactionSourceEntry_MoneroOutputEntry::mutable_key() {
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  return _msg;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_allocated_key(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroMultisigKLRki

// optional bytes K = 1;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_has_k() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_k() const {
  return _internal_has_k();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_k() {
  _impl_.k_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::k() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.k_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_k() const {
  return _impl_.k_.Get();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_set_k(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.k_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_mutable_k() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.k_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_k() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  if (!_internal_has_k()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.k_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.k_.SetAllocated(k, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k_.IsDefault()) {
    _impl_.k_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}

// optional bytes L = 2;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_has_l() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_l() const {
  return _internal_has_l();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_l() {
  _impl_.l_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::l() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  return _internal_l();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.l_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_l() {
  std::string* _s = _internal_mutable_l();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_l() const {
  return _impl_.l_.Get();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_set_l(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.l_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_mutable_l() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.l_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_l() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  if (!_internal_has_l()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.l_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.l_.IsDefault()) {
    _impl_.l_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_l(std::string* l) {
  if (l != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.l_.SetAllocated(l, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.l_.IsDefault()) {
    _impl_.l_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}

// optional bytes R = 3;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_r() const {
  return _internal_has_r();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_r() {
  _impl_.r_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::r() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  return _internal_r();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.r_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_r() {
  std::string* _s = _internal_mutable_r();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_r() const {
  return _impl_.r_.Get();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_set_r(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.r_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_mutable_r() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.r_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_r() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  if (!_internal_has_r()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.r_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.r_.IsDefault()) {
    _impl_.r_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_r(std::string* r) {
  if (r != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.r_.SetAllocated(r, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.r_.IsDefault()) {
    _impl_.r_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}

// optional bytes ki = 4;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_has_ki() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_ki() const {
  return _internal_has_ki();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_ki() {
  _impl_.ki_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::ki() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  return _internal_ki();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.ki_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_ki() {
  std::string* _s = _internal_mutable_ki();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_ki() const {
  return _impl_.ki_.Get();
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_set_ki(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ki_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::_internal_mutable_ki() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.ki_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_ki() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  if (!_internal_has_ki()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.ki_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ki_.IsDefault()) {
    _impl_.ki_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_ki(std::string* ki) {
  if (ki != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ki_.SetAllocated(ki, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ki_.IsDefault()) {
    _impl_.ki_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry

// repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
inline int MoneroTransactionSourceEntry::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int MoneroTransactionSourceEntry::outputs_size() const {
  return _internal_outputs_size();
}
inline void MoneroTransactionSourceEntry::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >*
MoneroTransactionSourceEntry::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return &_impl_.outputs_;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& MoneroTransactionSourceEntry::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& MoneroTransactionSourceEntry::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return _internal_outputs(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::add_outputs() {
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >&
MoneroTransactionSourceEntry::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return _impl_.outputs_;
}

// optional uint64 real_output = 2;
inline bool MoneroTransactionSourceEntry::_internal_has_real_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_real_output() const {
  return _internal_has_real_output();
}
inline void MoneroTransactionSourceEntry::clear_real_output() {
  _impl_.real_output_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t MoneroTransactionSourceEntry::_internal_real_output() const {
  return _impl_.real_output_;
}
inline uint64_t MoneroTransactionSourceEntry::real_output() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
  return _internal_real_output();
}
inline void MoneroTransactionSourceEntry::_internal_set_real_output(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.real_output_ = value;
}
inline void MoneroTransactionSourceEntry::set_real_output(uint64_t value) {
  _internal_set_real_output(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
}

// optional bytes real_out_tx_key = 3;
inline bool MoneroTransactionSourceEntry::_internal_has_real_out_tx_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_real_out_tx_key() const {
  return _internal_has_real_out_tx_key();
}
inline void MoneroTransactionSourceEntry::clear_real_out_tx_key() {
  _impl_.real_out_tx_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSourceEntry::real_out_tx_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  return _internal_real_out_tx_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry::set_real_out_tx_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.real_out_tx_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
inline std::string* MoneroTransactionSourceEntry::mutable_real_out_tx_key() {
  std::string* _s = _internal_mutable_real_out_tx_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry::_internal_real_out_tx_key() const {
  return _impl_.real_out_tx_key_.Get();
}
inline void MoneroTransactionSourceEntry::_internal_set_real_out_tx_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.real_out_tx_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry::_internal_mutable_real_out_tx_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.real_out_tx_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry::release_real_out_tx_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  if (!_internal_has_real_out_tx_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.real_out_tx_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_out_tx_key_.IsDefault()) {
    _impl_.real_out_tx_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry::set_allocated_real_out_tx_key(std::string* real_out_tx_key) {
  if (real_out_tx_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.real_out_tx_key_.SetAllocated(real_out_tx_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.real_out_tx_key_.IsDefault()) {
    _impl_.real_out_tx_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}

// repeated bytes real_out_additional_tx_keys = 4;
inline int MoneroTransactionSourceEntry::_internal_real_out_additional_tx_keys_size() const {
  return _impl_.real_out_additional_tx_keys_.size();
}
inline int MoneroTransactionSourceEntry::real_out_additional_tx_keys_size() const {
  return _internal_real_out_additional_tx_keys_size();
}
inline void MoneroTransactionSourceEntry::clear_real_out_additional_tx_keys() {
  _impl_.real_out_additional_tx_keys_.Clear();
}
inline std::string* MoneroTransactionSourceEntry::add_real_out_additional_tx_keys() {
  std::string* _s = _internal_add_real_out_additional_tx_keys();
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry::_internal_real_out_additional_tx_keys(int index) const {
  return _impl_.real_out_additional_tx_keys_.Get(index);
}
inline const std::string& MoneroTransactionSourceEntry::real_out_additional_tx_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return _internal_real_out_additional_tx_keys(index);
}
inline std::string* MoneroTransactionSourceEntry::mutable_real_out_additional_tx_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return _impl_.real_out_additional_tx_keys_.Mutable(index);
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const std::string& value) {
  _impl_.real_out_additional_tx_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, std::string&& value) {
  _impl_.real_out_additional_tx_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.real_out_additional_tx_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const void* value, size_t size) {
  _impl_.real_out_additional_tx_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline std::string* MoneroTransactionSourceEntry::_internal_add_real_out_additional_tx_keys() {
  return _impl_.real_out_additional_tx_keys_.Add();
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const std::string& value) {
  _impl_.real_out_additional_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(std::string&& value) {
  _impl_.real_out_additional_tx_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.real_out_additional_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const void* value, size_t size) {
  _impl_.real_out_additional_tx_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MoneroTransactionSourceEntry::real_out_additional_tx_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return _impl_.real_out_additional_tx_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MoneroTransactionSourceEntry::mutable_real_out_additional_tx_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return &_impl_.real_out_additional_tx_keys_;
}

// optional uint64 real_output_in_tx_index = 5;
inline bool MoneroTransactionSourceEntry::_internal_has_real_output_in_tx_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_real_output_in_tx_index() const {
  return _internal_has_real_output_in_tx_index();
}
inline void MoneroTransactionSourceEntry::clear_real_output_in_tx_index() {
  _impl_.real_output_in_tx_index_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t MoneroTransactionSourceEntry::_internal_real_output_in_tx_index() const {
  return _impl_.real_output_in_tx_index_;
}
inline uint64_t MoneroTransactionSourceEntry::real_output_in_tx_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
  return _internal_real_output_in_tx_index();
}
inline void MoneroTransactionSourceEntry::_internal_set_real_output_in_tx_index(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.real_output_in_tx_index_ = value;
}
inline void MoneroTransactionSourceEntry::set_real_output_in_tx_index(uint64_t value) {
  _internal_set_real_output_in_tx_index(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
}

// optional uint64 amount = 6;
inline bool MoneroTransactionSourceEntry::_internal_has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_amount() const {
  return _internal_has_amount();
}
inline void MoneroTransactionSourceEntry::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t MoneroTransactionSourceEntry::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t MoneroTransactionSourceEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
  return _internal_amount();
}
inline void MoneroTransactionSourceEntry::_internal_set_amount(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.amount_ = value;
}
inline void MoneroTransactionSourceEntry::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
}

// optional bool rct = 7;
inline bool MoneroTransactionSourceEntry::_internal_has_rct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_rct() const {
  return _internal_has_rct();
}
inline void MoneroTransactionSourceEntry::clear_rct() {
  _impl_.rct_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool MoneroTransactionSourceEntry::_internal_rct() const {
  return _impl_.rct_;
}
inline bool MoneroTransactionSourceEntry::rct() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
  return _internal_rct();
}
inline void MoneroTransactionSourceEntry::_internal_set_rct(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.rct_ = value;
}
inline void MoneroTransactionSourceEntry::set_rct(bool value) {
  _internal_set_rct(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
}

// optional bytes mask = 8;
inline bool MoneroTransactionSourceEntry::_internal_has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_mask() const {
  return _internal_has_mask();
}
inline void MoneroTransactionSourceEntry::clear_mask() {
  _impl_.mask_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSourceEntry::mask() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSourceEntry::set_mask(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mask_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
inline std::string* MoneroTransactionSourceEntry::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  return _s;
}
inline const std::string& MoneroTransactionSourceEntry::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void MoneroTransactionSourceEntry::_internal_set_mask(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry::_internal_mutable_mask() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSourceEntry::release_mask() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  if (!_internal_has_mask()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mask_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSourceEntry::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
inline bool MoneroTransactionSourceEntry::_internal_has_multisig_klrki() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multisig_klrki_ != nullptr);
  return value;
}
inline bool MoneroTransactionSourceEntry::has_multisig_klrki() const {
  return _internal_has_multisig_klrki();
}
inline void MoneroTransactionSourceEntry::clear_multisig_klrki() {
  if (_impl_.multisig_klrki_ != nullptr) _impl_.multisig_klrki_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& MoneroTransactionSourceEntry::_internal_multisig_klrki() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* p = _impl_.multisig_klrki_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki&>(
      ::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_MoneroMultisigKLRki_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& MoneroTransactionSourceEntry::multisig_klrki() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  return _internal_multisig_klrki();
}
inline void MoneroTransactionSourceEntry::unsafe_arena_set_allocated_multisig_klrki(
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multisig_klrki_);
  }
  _impl_.multisig_klrki_ = multisig_klrki;
  if (multisig_klrki) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::release_multisig_klrki() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* temp = _impl_.multisig_klrki_;
  _impl_.multisig_klrki_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::unsafe_arena_release_multisig_klrki() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* temp = _impl_.multisig_klrki_;
  _impl_.multisig_klrki_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::_internal_mutable_multisig_klrki() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.multisig_klrki_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki>(GetArenaForAllocation());
    _impl_.multisig_klrki_ = p;
  }
  return _impl_.multisig_klrki_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::mutable_multisig_klrki() {
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* _msg = _internal_mutable_multisig_klrki();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  return _msg;
}
inline void MoneroTransactionSourceEntry::set_allocated_multisig_klrki(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.multisig_klrki_;
  }
  if (multisig_klrki) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multisig_klrki);
    if (message_arena != submessage_arena) {
      multisig_klrki = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multisig_klrki, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.multisig_klrki_ = multisig_klrki;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
}

// optional uint32 subaddr_minor = 10;
inline bool MoneroTransactionSourceEntry::_internal_has_subaddr_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MoneroTransactionSourceEntry::has_subaddr_minor() const {
  return _internal_has_subaddr_minor();
}
inline void MoneroTransactionSourceEntry::clear_subaddr_minor() {
  _impl_.subaddr_minor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t MoneroTransactionSourceEntry::_internal_subaddr_minor() const {
  return _impl_.subaddr_minor_;
}
inline uint32_t MoneroTransactionSourceEntry::subaddr_minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.subaddr_minor)
  return _internal_subaddr_minor();
}
inline void MoneroTransactionSourceEntry::_internal_set_subaddr_minor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.subaddr_minor_ = value;
}
inline void MoneroTransactionSourceEntry::set_subaddr_minor(uint32_t value) {
  _internal_set_subaddr_minor(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.subaddr_minor)
}

// -------------------------------------------------------------------

// MoneroTransactionDestinationEntry_MoneroAccountPublicAddress

// optional bytes spend_public_key = 1;
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_has_spend_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::has_spend_public_key() const {
  return _internal_has_spend_public_key();
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_spend_public_key() {
  _impl_.spend_public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::spend_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  return _internal_spend_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.spend_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
inline std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::mutable_spend_public_key() {
  std::string* _s = _internal_mutable_spend_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  return _s;
}
inline const std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_spend_public_key() const {
  return _impl_.spend_public_key_.Get();
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_set_spend_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.spend_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_mutable_spend_public_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.spend_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::release_spend_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  if (!_internal_has_spend_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.spend_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_public_key_.IsDefault()) {
    _impl_.spend_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_allocated_spend_public_key(std::string* spend_public_key) {
  if (spend_public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.spend_public_key_.SetAllocated(spend_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_public_key_.IsDefault()) {
    _impl_.spend_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}

// optional bytes view_public_key = 2;
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_has_view_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::has_view_public_key() const {
  return _internal_has_view_public_key();
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_view_public_key() {
  _impl_.view_public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::view_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  return _internal_view_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.view_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
inline std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::mutable_view_public_key() {
  std::string* _s = _internal_mutable_view_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  return _s;
}
inline const std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_view_public_key() const {
  return _impl_.view_public_key_.Get();
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_set_view_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.view_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::_internal_mutable_view_public_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.view_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::release_view_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  if (!_internal_has_view_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.view_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_public_key_.IsDefault()) {
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_allocated_view_public_key(std::string* view_public_key) {
  if (view_public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.view_public_key_.SetAllocated(view_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_public_key_.IsDefault()) {
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}

// -------------------------------------------------------------------

// MoneroTransactionDestinationEntry

// optional uint64 amount = 1;
inline bool MoneroTransactionDestinationEntry::_internal_has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionDestinationEntry::has_amount() const {
  return _internal_has_amount();
}
inline void MoneroTransactionDestinationEntry::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t MoneroTransactionDestinationEntry::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t MoneroTransactionDestinationEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
  return _internal_amount();
}
inline void MoneroTransactionDestinationEntry::_internal_set_amount(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.amount_ = value;
}
inline void MoneroTransactionDestinationEntry::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
}

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
inline bool MoneroTransactionDestinationEntry::_internal_has_addr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addr_ != nullptr);
  return value;
}
inline bool MoneroTransactionDestinationEntry::has_addr() const {
  return _internal_has_addr();
}
inline void MoneroTransactionDestinationEntry::clear_addr() {
  if (_impl_.addr_ != nullptr) _impl_.addr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& MoneroTransactionDestinationEntry::_internal_addr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* p = _impl_.addr_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress&>(
      ::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_MoneroAccountPublicAddress_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& MoneroTransactionDestinationEntry::addr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  return _internal_addr();
}
inline void MoneroTransactionDestinationEntry::unsafe_arena_set_allocated_addr(
    ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.addr_);
  }
  _impl_.addr_ = addr;
  if (addr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::release_addr() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* temp = _impl_.addr_;
  _impl_.addr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::unsafe_arena_release_addr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* temp = _impl_.addr_;
  _impl_.addr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::_internal_mutable_addr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.addr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(GetArenaForAllocation());
    _impl_.addr_ = p;
  }
  return _impl_.addr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::mutable_addr() {
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* _msg = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  return _msg;
}
inline void MoneroTransactionDestinationEntry::set_allocated_addr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.addr_;
  }
  if (addr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(addr);
    if (message_arena != submessage_arena) {
      addr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.addr_ = addr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
}

// optional bool is_subaddress = 3;
inline bool MoneroTransactionDestinationEntry::_internal_has_is_subaddress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionDestinationEntry::has_is_subaddress() const {
  return _internal_has_is_subaddress();
}
inline void MoneroTransactionDestinationEntry::clear_is_subaddress() {
  _impl_.is_subaddress_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MoneroTransactionDestinationEntry::_internal_is_subaddress() const {
  return _impl_.is_subaddress_;
}
inline bool MoneroTransactionDestinationEntry::is_subaddress() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
  return _internal_is_subaddress();
}
inline void MoneroTransactionDestinationEntry::_internal_set_is_subaddress(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_subaddress_ = value;
}
inline void MoneroTransactionDestinationEntry::set_is_subaddress(bool value) {
  _internal_set_is_subaddress(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
}

// optional bytes original = 4;
inline bool MoneroTransactionDestinationEntry::_internal_has_original() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionDestinationEntry::has_original() const {
  return _internal_has_original();
}
inline void MoneroTransactionDestinationEntry::clear_original() {
  _impl_.original_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionDestinationEntry::original() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.original)
  return _internal_original();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionDestinationEntry::set_original(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.original_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.original)
}
inline std::string* MoneroTransactionDestinationEntry::mutable_original() {
  std::string* _s = _internal_mutable_original();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.original)
  return _s;
}
inline const std::string& MoneroTransactionDestinationEntry::_internal_original() const {
  return _impl_.original_.Get();
}
inline void MoneroTransactionDestinationEntry::_internal_set_original(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.original_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionDestinationEntry::_internal_mutable_original() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.original_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionDestinationEntry::release_original() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.original)
  if (!_internal_has_original()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.original_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.original_.IsDefault()) {
    _impl_.original_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionDestinationEntry::set_allocated_original(std::string* original) {
  if (original != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.original_.SetAllocated(original, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.original_.IsDefault()) {
    _impl_.original_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.original)
}

// optional bool is_integrated = 5;
inline bool MoneroTransactionDestinationEntry::_internal_has_is_integrated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionDestinationEntry::has_is_integrated() const {
  return _internal_has_is_integrated();
}
inline void MoneroTransactionDestinationEntry::clear_is_integrated() {
  _impl_.is_integrated_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool MoneroTransactionDestinationEntry::_internal_is_integrated() const {
  return _impl_.is_integrated_;
}
inline bool MoneroTransactionDestinationEntry::is_integrated() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_integrated)
  return _internal_is_integrated();
}
inline void MoneroTransactionDestinationEntry::_internal_set_is_integrated(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_integrated_ = value;
}
inline void MoneroTransactionDestinationEntry::set_is_integrated(bool value) {
  _internal_set_is_integrated(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_integrated)
}

// -------------------------------------------------------------------

// MoneroTransactionRsigData

// optional uint32 rsig_type = 1;
inline bool MoneroTransactionRsigData::_internal_has_rsig_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionRsigData::has_rsig_type() const {
  return _internal_has_rsig_type();
}
inline void MoneroTransactionRsigData::clear_rsig_type() {
  _impl_.rsig_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MoneroTransactionRsigData::_internal_rsig_type() const {
  return _impl_.rsig_type_;
}
inline uint32_t MoneroTransactionRsigData::rsig_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_type)
  return _internal_rsig_type();
}
inline void MoneroTransactionRsigData::_internal_set_rsig_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rsig_type_ = value;
}
inline void MoneroTransactionRsigData::set_rsig_type(uint32_t value) {
  _internal_set_rsig_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_type)
}

// optional uint32 offload_type = 2;
inline bool MoneroTransactionRsigData::_internal_has_offload_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionRsigData::has_offload_type() const {
  return _internal_has_offload_type();
}
inline void MoneroTransactionRsigData::clear_offload_type() {
  _impl_.offload_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoneroTransactionRsigData::_internal_offload_type() const {
  return _impl_.offload_type_;
}
inline uint32_t MoneroTransactionRsigData::offload_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.offload_type)
  return _internal_offload_type();
}
inline void MoneroTransactionRsigData::_internal_set_offload_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.offload_type_ = value;
}
inline void MoneroTransactionRsigData::set_offload_type(uint32_t value) {
  _internal_set_offload_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.offload_type)
}

// repeated uint64 grouping = 3;
inline int MoneroTransactionRsigData::_internal_grouping_size() const {
  return _impl_.grouping_.size();
}
inline int MoneroTransactionRsigData::grouping_size() const {
  return _internal_grouping_size();
}
inline void MoneroTransactionRsigData::clear_grouping() {
  _impl_.grouping_.Clear();
}
inline uint64_t MoneroTransactionRsigData::_internal_grouping(int index) const {
  return _impl_.grouping_.Get(index);
}
inline uint64_t MoneroTransactionRsigData::grouping(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
  return _internal_grouping(index);
}
inline void MoneroTransactionRsigData::set_grouping(int index, uint64_t value) {
  _impl_.grouping_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
}
inline void MoneroTransactionRsigData::_internal_add_grouping(uint64_t value) {
  _impl_.grouping_.Add(value);
}
inline void MoneroTransactionRsigData::add_grouping(uint64_t value) {
  _internal_add_grouping(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
MoneroTransactionRsigData::_internal_grouping() const {
  return _impl_.grouping_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
MoneroTransactionRsigData::grouping() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
  return _internal_grouping();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
MoneroTransactionRsigData::_internal_mutable_grouping() {
  return &_impl_.grouping_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
MoneroTransactionRsigData::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionRsigData.grouping)
  return _internal_mutable_grouping();
}

// optional bytes mask = 4;
inline bool MoneroTransactionRsigData::_internal_has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionRsigData::has_mask() const {
  return _internal_has_mask();
}
inline void MoneroTransactionRsigData::clear_mask() {
  _impl_.mask_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionRsigData::mask() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
  return _internal_mask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionRsigData::set_mask(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mask_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}
inline std::string* MoneroTransactionRsigData::mutable_mask() {
  std::string* _s = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
  return _s;
}
inline const std::string& MoneroTransactionRsigData::_internal_mask() const {
  return _impl_.mask_.Get();
}
inline void MoneroTransactionRsigData::_internal_set_mask(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mask_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionRsigData::_internal_mutable_mask() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mask_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionRsigData::release_mask() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
  if (!_internal_has_mask()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mask_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionRsigData::set_allocated_mask(std::string* mask) {
  if (mask != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mask_.SetAllocated(mask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mask_.IsDefault()) {
    _impl_.mask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionRsigData.mask)
}

// optional bytes rsig = 5;
inline bool MoneroTransactionRsigData::_internal_has_rsig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionRsigData::has_rsig() const {
  return _internal_has_rsig();
}
inline void MoneroTransactionRsigData::clear_rsig() {
  _impl_.rsig_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionRsigData::rsig() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
  return _internal_rsig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionRsigData::set_rsig(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.rsig_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}
inline std::string* MoneroTransactionRsigData::mutable_rsig() {
  std::string* _s = _internal_mutable_rsig();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
  return _s;
}
inline const std::string& MoneroTransactionRsigData::_internal_rsig() const {
  return _impl_.rsig_.Get();
}
inline void MoneroTransactionRsigData::_internal_set_rsig(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rsig_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionRsigData::_internal_mutable_rsig() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.rsig_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionRsigData::release_rsig() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
  if (!_internal_has_rsig()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.rsig_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rsig_.IsDefault()) {
    _impl_.rsig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionRsigData::set_allocated_rsig(std::string* rsig) {
  if (rsig != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rsig_.SetAllocated(rsig, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rsig_.IsDefault()) {
    _impl_.rsig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig)
}

// repeated bytes rsig_parts = 6;
inline int MoneroTransactionRsigData::_internal_rsig_parts_size() const {
  return _impl_.rsig_parts_.size();
}
inline int MoneroTransactionRsigData::rsig_parts_size() const {
  return _internal_rsig_parts_size();
}
inline void MoneroTransactionRsigData::clear_rsig_parts() {
  _impl_.rsig_parts_.Clear();
}
inline std::string* MoneroTransactionRsigData::add_rsig_parts() {
  std::string* _s = _internal_add_rsig_parts();
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return _s;
}
inline const std::string& MoneroTransactionRsigData::_internal_rsig_parts(int index) const {
  return _impl_.rsig_parts_.Get(index);
}
inline const std::string& MoneroTransactionRsigData::rsig_parts(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return _internal_rsig_parts(index);
}
inline std::string* MoneroTransactionRsigData::mutable_rsig_parts(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return _impl_.rsig_parts_.Mutable(index);
}
inline void MoneroTransactionRsigData::set_rsig_parts(int index, const std::string& value) {
  _impl_.rsig_parts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::set_rsig_parts(int index, std::string&& value) {
  _impl_.rsig_parts_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::set_rsig_parts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.rsig_parts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::set_rsig_parts(int index, const void* value, size_t size) {
  _impl_.rsig_parts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline std::string* MoneroTransactionRsigData::_internal_add_rsig_parts() {
  return _impl_.rsig_parts_.Add();
}
inline void MoneroTransactionRsigData::add_rsig_parts(const std::string& value) {
  _impl_.rsig_parts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::add_rsig_parts(std::string&& value) {
  _impl_.rsig_parts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::add_rsig_parts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.rsig_parts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline void MoneroTransactionRsigData::add_rsig_parts(const void* value, size_t size) {
  _impl_.rsig_parts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MoneroTransactionRsigData::rsig_parts() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return _impl_.rsig_parts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MoneroTransactionRsigData::mutable_rsig_parts() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionRsigData.rsig_parts)
  return &_impl_.rsig_parts_;
}

// optional uint32 bp_version = 7;
inline bool MoneroTransactionRsigData::_internal_has_bp_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionRsigData::has_bp_version() const {
  return _internal_has_bp_version();
}
inline void MoneroTransactionRsigData::clear_bp_version() {
  _impl_.bp_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoneroTransactionRsigData::_internal_bp_version() const {
  return _impl_.bp_version_;
}
inline uint32_t MoneroTransactionRsigData::bp_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionRsigData.bp_version)
  return _internal_bp_version();
}
inline void MoneroTransactionRsigData::_internal_set_bp_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bp_version_ = value;
}
inline void MoneroTransactionRsigData::set_bp_version(uint32_t value) {
  _internal_set_bp_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionRsigData.bp_version)
}

// -------------------------------------------------------------------

// MoneroGetAddress

// repeated uint32 address_n = 1;
inline int MoneroGetAddress::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int MoneroGetAddress::address_n_size() const {
  return _internal_address_n_size();
}
inline void MoneroGetAddress::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t MoneroGetAddress::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t MoneroGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return _internal_address_n(index);
}
inline void MoneroGetAddress::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.address_n)
}
inline void MoneroGetAddress::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void MoneroGetAddress::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetAddress.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroGetAddress::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroGetAddress::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return _internal_mutable_address_n();
}

// optional bool show_display = 2;
inline bool MoneroGetAddress::_internal_has_show_display() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroGetAddress::has_show_display() const {
  return _internal_has_show_display();
}
inline void MoneroGetAddress::clear_show_display() {
  _impl_.show_display_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool MoneroGetAddress::_internal_show_display() const {
  return _impl_.show_display_;
}
inline bool MoneroGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.show_display)
  return _internal_show_display();
}
inline void MoneroGetAddress::_internal_set_show_display(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.show_display_ = value;
}
inline void MoneroGetAddress::set_show_display(bool value) {
  _internal_set_show_display(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.show_display)
}

// optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
inline bool MoneroGetAddress::_internal_has_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroGetAddress::has_network_type() const {
  return _internal_has_network_type();
}
inline void MoneroGetAddress::clear_network_type() {
  _impl_.network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroGetAddress::_internal_network_type() const {
  return static_cast< ::hw::trezor::messages::monero::MoneroNetworkType >(_impl_.network_type_);
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroGetAddress::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.network_type)
  return _internal_network_type();
}
inline void MoneroGetAddress::_internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  assert(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.network_type_ = value;
}
inline void MoneroGetAddress::set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.network_type)
}

// optional uint32 account = 4;
inline bool MoneroGetAddress::_internal_has_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroGetAddress::has_account() const {
  return _internal_has_account();
}
inline void MoneroGetAddress::clear_account() {
  _impl_.account_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoneroGetAddress::_internal_account() const {
  return _impl_.account_;
}
inline uint32_t MoneroGetAddress::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.account)
  return _internal_account();
}
inline void MoneroGetAddress::_internal_set_account(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.account_ = value;
}
inline void MoneroGetAddress::set_account(uint32_t value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.account)
}

// optional uint32 minor = 5;
inline bool MoneroGetAddress::_internal_has_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroGetAddress::has_minor() const {
  return _internal_has_minor();
}
inline void MoneroGetAddress::clear_minor() {
  _impl_.minor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoneroGetAddress::_internal_minor() const {
  return _impl_.minor_;
}
inline uint32_t MoneroGetAddress::minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.minor)
  return _internal_minor();
}
inline void MoneroGetAddress::_internal_set_minor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.minor_ = value;
}
inline void MoneroGetAddress::set_minor(uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.minor)
}

// optional bytes payment_id = 6;
inline bool MoneroGetAddress::_internal_has_payment_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroGetAddress::has_payment_id() const {
  return _internal_has_payment_id();
}
inline void MoneroGetAddress::clear_payment_id() {
  _impl_.payment_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroGetAddress::payment_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.payment_id)
  return _internal_payment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetAddress::set_payment_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.payment_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.payment_id)
}
inline std::string* MoneroGetAddress::mutable_payment_id() {
  std::string* _s = _internal_mutable_payment_id();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetAddress.payment_id)
  return _s;
}
inline const std::string& MoneroGetAddress::_internal_payment_id() const {
  return _impl_.payment_id_.Get();
}
inline void MoneroGetAddress::_internal_set_payment_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetAddress::_internal_mutable_payment_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetAddress::release_payment_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetAddress.payment_id)
  if (!_internal_has_payment_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.payment_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payment_id_.IsDefault()) {
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetAddress::set_allocated_payment_id(std::string* payment_id) {
  if (payment_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payment_id_.SetAllocated(payment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payment_id_.IsDefault()) {
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetAddress.payment_id)
}

// -------------------------------------------------------------------

// MoneroAddress

// optional bytes address = 1;
inline bool MoneroAddress::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroAddress::has_address() const {
  return _internal_has_address();
}
inline void MoneroAddress::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroAddress.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroAddress::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroAddress.address)
}
inline std::string* MoneroAddress::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroAddress.address)
  return _s;
}
inline const std::string& MoneroAddress::_internal_address() const {
  return _impl_.address_.Get();
}
inline void MoneroAddress::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroAddress::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroAddress::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroAddress.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroAddress::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroAddress.address)
}

// -------------------------------------------------------------------

// MoneroGetWatchKey

// repeated uint32 address_n = 1;
inline int MoneroGetWatchKey::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int MoneroGetWatchKey::address_n_size() const {
  return _internal_address_n_size();
}
inline void MoneroGetWatchKey::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t MoneroGetWatchKey::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t MoneroGetWatchKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return _internal_address_n(index);
}
inline void MoneroGetWatchKey::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
}
inline void MoneroGetWatchKey::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void MoneroGetWatchKey::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroGetWatchKey::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroGetWatchKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroGetWatchKey::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroGetWatchKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return _internal_mutable_address_n();
}

// optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
inline bool MoneroGetWatchKey::_internal_has_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroGetWatchKey::has_network_type() const {
  return _internal_has_network_type();
}
inline void MoneroGetWatchKey::clear_network_type() {
  _impl_.network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroGetWatchKey::_internal_network_type() const {
  return static_cast< ::hw::trezor::messages::monero::MoneroNetworkType >(_impl_.network_type_);
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroGetWatchKey::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
  return _internal_network_type();
}
inline void MoneroGetWatchKey::_internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  assert(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.network_type_ = value;
}
inline void MoneroGetWatchKey::set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
}

// -------------------------------------------------------------------

// MoneroWatchKey

// optional bytes watch_key = 1;
inline bool MoneroWatchKey::_internal_has_watch_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroWatchKey::has_watch_key() const {
  return _internal_has_watch_key();
}
inline void MoneroWatchKey::clear_watch_key() {
  _impl_.watch_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroWatchKey::watch_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  return _internal_watch_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroWatchKey::set_watch_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.watch_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
inline std::string* MoneroWatchKey::mutable_watch_key() {
  std::string* _s = _internal_mutable_watch_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  return _s;
}
inline const std::string& MoneroWatchKey::_internal_watch_key() const {
  return _impl_.watch_key_.Get();
}
inline void MoneroWatchKey::_internal_set_watch_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.watch_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroWatchKey::_internal_mutable_watch_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.watch_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroWatchKey::release_watch_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  if (!_internal_has_watch_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.watch_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.watch_key_.IsDefault()) {
    _impl_.watch_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroWatchKey::set_allocated_watch_key(std::string* watch_key) {
  if (watch_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.watch_key_.SetAllocated(watch_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.watch_key_.IsDefault()) {
    _impl_.watch_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}

// optional bytes address = 2;
inline bool MoneroWatchKey::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroWatchKey::has_address() const {
  return _internal_has_address();
}
inline void MoneroWatchKey::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroWatchKey::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroWatchKey.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroWatchKey::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroWatchKey.address)
}
inline std::string* MoneroWatchKey::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroWatchKey.address)
  return _s;
}
inline const std::string& MoneroWatchKey::_internal_address() const {
  return _impl_.address_.Get();
}
inline void MoneroWatchKey::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroWatchKey::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroWatchKey::release_address() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroWatchKey.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroWatchKey::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroWatchKey.address)
}

// -------------------------------------------------------------------

// MoneroTransactionInitRequest_MoneroTransactionData

// optional uint32 version = 1;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_version() const {
  return _internal_has_version();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
  return _internal_version();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.version_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
}

// optional bytes payment_id = 2;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_payment_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_payment_id() const {
  return _internal_has_payment_id();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_payment_id() {
  _impl_.payment_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionInitRequest_MoneroTransactionData::payment_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  return _internal_payment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.payment_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
inline std::string* MoneroTransactionInitRequest_MoneroTransactionData::mutable_payment_id() {
  std::string* _s = _internal_mutable_payment_id();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  return _s;
}
inline const std::string& MoneroTransactionInitRequest_MoneroTransactionData::_internal_payment_id() const {
  return _impl_.payment_id_.Get();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_payment_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionInitRequest_MoneroTransactionData::_internal_mutable_payment_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionInitRequest_MoneroTransactionData::release_payment_id() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  if (!_internal_has_payment_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.payment_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payment_id_.IsDefault()) {
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_payment_id(std::string* payment_id) {
  if (payment_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payment_id_.SetAllocated(payment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payment_id_.IsDefault()) {
    _impl_.payment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}

// optional uint64 unlock_time = 3;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_unlock_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_unlock_time() const {
  return _internal_has_unlock_time();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_unlock_time() {
  _impl_.unlock_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_unlock_time() const {
  return _impl_.unlock_time_;
}
inline uint64_t MoneroTransactionInitRequest_MoneroTransactionData::unlock_time() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
  return _internal_unlock_time();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_unlock_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.unlock_time_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_unlock_time(uint64_t value) {
  _internal_set_unlock_time(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
}

// repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
inline int MoneroTransactionInitRequest_MoneroTransactionData::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int MoneroTransactionInitRequest_MoneroTransactionData::outputs_size() const {
  return _internal_outputs_size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return &_impl_.outputs_;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return _internal_outputs(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::add_outputs() {
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >&
MoneroTransactionInitRequest_MoneroTransactionData::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return _impl_.outputs_;
}

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_change_dts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_dts_ != nullptr);
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_change_dts() const {
  return _internal_has_change_dts();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_change_dts() {
  if (_impl_.change_dts_ != nullptr) _impl_.change_dts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::_internal_change_dts() const {
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* p = _impl_.change_dts_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry&>(
      ::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::change_dts() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  return _internal_change_dts();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::unsafe_arena_set_allocated_change_dts(
    ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.change_dts_);
  }
  _impl_.change_dts_ = change_dts;
  if (change_dts) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::release_change_dts() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = _impl_.change_dts_;
  _impl_.change_dts_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::unsafe_arena_release_change_dts() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = _impl_.change_dts_;
  _impl_.change_dts_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::_internal_mutable_change_dts() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.change_dts_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry>(GetArenaForAllocation());
    _impl_.change_dts_ = p;
  }
  return _impl_.change_dts_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::mutable_change_dts() {
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* _msg = _internal_mutable_change_dts();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  return _msg;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_change_dts(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.change_dts_;
  }
  if (change_dts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_dts);
    if (message_arena != submessage_arena) {
      change_dts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_dts, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.change_dts_ = change_dts;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
}

// optional uint32 num_inputs = 6;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_num_inputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_num_inputs() const {
  return _internal_has_num_inputs();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_num_inputs() {
  _impl_.num_inputs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_num_inputs() const {
  return _impl_.num_inputs_;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::num_inputs() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
  return _internal_num_inputs();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_num_inputs(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.num_inputs_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_num_inputs(uint32_t value) {
  _internal_set_num_inputs(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
}

// optional uint32 mixin = 7;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_mixin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_mixin() const {
  return _internal_has_mixin();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_mixin() {
  _impl_.mixin_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_mixin() const {
  return _impl_.mixin_;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::mixin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
  return _internal_mixin();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_mixin(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.mixin_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_mixin(uint32_t value) {
  _internal_set_mixin(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
}

// optional uint64 fee = 8;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_fee() const {
  return _internal_has_fee();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_fee() {
  _impl_.fee_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_fee() const {
  return _impl_.fee_;
}
inline uint64_t MoneroTransactionInitRequest_MoneroTransactionData::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
  return _internal_fee();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_fee(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fee_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_fee(uint64_t value) {
  _internal_set_fee(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
}

// optional uint32 account = 9;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_account() const {
  return _internal_has_account();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_account() {
  _impl_.account_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_account() const {
  return _impl_.account_;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
  return _internal_account();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_account(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.account_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_account(uint32_t value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
}

// repeated uint32 minor_indices = 10;
inline int MoneroTransactionInitRequest_MoneroTransactionData::_internal_minor_indices_size() const {
  return _impl_.minor_indices_.size();
}
inline int MoneroTransactionInitRequest_MoneroTransactionData::minor_indices_size() const {
  return _internal_minor_indices_size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_minor_indices() {
  _impl_.minor_indices_.Clear();
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_minor_indices(int index) const {
  return _impl_.minor_indices_.Get(index);
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::minor_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return _internal_minor_indices(index);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_minor_indices(int index, uint32_t value) {
  _impl_.minor_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_add_minor_indices(uint32_t value) {
  _impl_.minor_indices_.Add(value);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_minor_indices(uint32_t value) {
  _internal_add_minor_indices(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroTransactionInitRequest_MoneroTransactionData::_internal_minor_indices() const {
  return _impl_.minor_indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroTransactionInitRequest_MoneroTransactionData::minor_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return _internal_minor_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroTransactionInitRequest_MoneroTransactionData::_internal_mutable_minor_indices() {
  return &_impl_.minor_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_minor_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return _internal_mutable_minor_indices();
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_rsig_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsig_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_rsig_data() const {
  return _internal_has_rsig_data();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_rsig_data() {
  if (_impl_.rsig_data_ != nullptr) _impl_.rsig_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionInitRequest_MoneroTransactionData::_internal_rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = _impl_.rsig_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionInitRequest_MoneroTransactionData::rsig_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
  return _internal_rsig_data();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::unsafe_arena_set_allocated_rsig_data(
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsig_data_);
  }
  _impl_.rsig_data_ = rsig_data;
  if (rsig_data) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitRequest_MoneroTransactionData::release_rsig_data() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitRequest_MoneroTransactionData::unsafe_arena_release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitRequest_MoneroTransactionData::_internal_mutable_rsig_data() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaForAllocation());
    _impl_.rsig_data_ = p;
  }
  return _impl_.rsig_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitRequest_MoneroTransactionData::mutable_rsig_data() {
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _msg = _internal_mutable_rsig_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
  return _msg;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsig_data_;
  }
  if (rsig_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsig_data);
    if (message_arena != submessage_arena) {
      rsig_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.rsig_data)
}

// repeated uint32 integrated_indices = 12;
inline int MoneroTransactionInitRequest_MoneroTransactionData::_internal_integrated_indices_size() const {
  return _impl_.integrated_indices_.size();
}
inline int MoneroTransactionInitRequest_MoneroTransactionData::integrated_indices_size() const {
  return _internal_integrated_indices_size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_integrated_indices() {
  _impl_.integrated_indices_.Clear();
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_integrated_indices(int index) const {
  return _impl_.integrated_indices_.Get(index);
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::integrated_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
  return _internal_integrated_indices(index);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_integrated_indices(int index, uint32_t value) {
  _impl_.integrated_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_add_integrated_indices(uint32_t value) {
  _impl_.integrated_indices_.Add(value);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_integrated_indices(uint32_t value) {
  _internal_add_integrated_indices(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroTransactionInitRequest_MoneroTransactionData::_internal_integrated_indices() const {
  return _impl_.integrated_indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroTransactionInitRequest_MoneroTransactionData::integrated_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
  return _internal_integrated_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroTransactionInitRequest_MoneroTransactionData::_internal_mutable_integrated_indices() {
  return &_impl_.integrated_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_integrated_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.integrated_indices)
  return _internal_mutable_integrated_indices();
}

// optional uint32 client_version = 13;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_client_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_client_version() const {
  return _internal_has_client_version();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_client_version() {
  _impl_.client_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_client_version() const {
  return _impl_.client_version_;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::client_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.client_version)
  return _internal_client_version();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_client_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.client_version_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_client_version(uint32_t value) {
  _internal_set_client_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.client_version)
}

// optional uint32 hard_fork = 14;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_hard_fork() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_hard_fork() const {
  return _internal_has_hard_fork();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_hard_fork() {
  _impl_.hard_fork_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::_internal_hard_fork() const {
  return _impl_.hard_fork_;
}
inline uint32_t MoneroTransactionInitRequest_MoneroTransactionData::hard_fork() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.hard_fork)
  return _internal_hard_fork();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_hard_fork(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.hard_fork_ = value;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_hard_fork(uint32_t value) {
  _internal_set_hard_fork(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.hard_fork)
}

// optional bytes monero_version = 15;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::_internal_has_monero_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_monero_version() const {
  return _internal_has_monero_version();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_monero_version() {
  _impl_.monero_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionInitRequest_MoneroTransactionData::monero_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.monero_version)
  return _internal_monero_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionInitRequest_MoneroTransactionData::set_monero_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.monero_version_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.monero_version)
}
inline std::string* MoneroTransactionInitRequest_MoneroTransactionData::mutable_monero_version() {
  std::string* _s = _internal_mutable_monero_version();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.monero_version)
  return _s;
}
inline const std::string& MoneroTransactionInitRequest_MoneroTransactionData::_internal_monero_version() const {
  return _impl_.monero_version_.Get();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::_internal_set_monero_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.monero_version_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionInitRequest_MoneroTransactionData::_internal_mutable_monero_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.monero_version_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionInitRequest_MoneroTransactionData::release_monero_version() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.monero_version)
  if (!_internal_has_monero_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.monero_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.monero_version_.IsDefault()) {
    _impl_.monero_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_monero_version(std::string* monero_version) {
  if (monero_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.monero_version_.SetAllocated(monero_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.monero_version_.IsDefault()) {
    _impl_.monero_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.monero_version)
}

// -------------------------------------------------------------------

// MoneroTransactionInitRequest

// optional uint32 version = 1;
inline bool MoneroTransactionInitRequest::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest::has_version() const {
  return _internal_has_version();
}
inline void MoneroTransactionInitRequest::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MoneroTransactionInitRequest::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t MoneroTransactionInitRequest::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
  return _internal_version();
}
inline void MoneroTransactionInitRequest::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}
inline void MoneroTransactionInitRequest::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
}

// repeated uint32 address_n = 2;
inline int MoneroTransactionInitRequest::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int MoneroTransactionInitRequest::address_n_size() const {
  return _internal_address_n_size();
}
inline void MoneroTransactionInitRequest::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t MoneroTransactionInitRequest::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t MoneroTransactionInitRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return _internal_address_n(index);
}
inline void MoneroTransactionInitRequest::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
}
inline void MoneroTransactionInitRequest::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void MoneroTransactionInitRequest::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroTransactionInitRequest::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroTransactionInitRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroTransactionInitRequest::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroTransactionInitRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return _internal_mutable_address_n();
}

// optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 3 [default = MAINNET];
inline bool MoneroTransactionInitRequest::_internal_has_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionInitRequest::has_network_type() const {
  return _internal_has_network_type();
}
inline void MoneroTransactionInitRequest::clear_network_type() {
  _impl_.network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroTransactionInitRequest::_internal_network_type() const {
  return static_cast< ::hw::trezor::messages::monero::MoneroNetworkType >(_impl_.network_type_);
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroTransactionInitRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
  return _internal_network_type();
}
inline void MoneroTransactionInitRequest::_internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  assert(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.network_type_ = value;
}
inline void MoneroTransactionInitRequest::set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
}

// optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
inline bool MoneroTransactionInitRequest::_internal_has_tsx_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tsx_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionInitRequest::has_tsx_data() const {
  return _internal_has_tsx_data();
}
inline void MoneroTransactionInitRequest::clear_tsx_data() {
  if (_impl_.tsx_data_ != nullptr) _impl_.tsx_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& MoneroTransactionInitRequest::_internal_tsx_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* p = _impl_.tsx_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionInitRequest_MoneroTransactionData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& MoneroTransactionInitRequest::tsx_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  return _internal_tsx_data();
}
inline void MoneroTransactionInitRequest::unsafe_arena_set_allocated_tsx_data(
    ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tsx_data_);
  }
  _impl_.tsx_data_ = tsx_data;
  if (tsx_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::release_tsx_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* temp = _impl_.tsx_data_;
  _impl_.tsx_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::unsafe_arena_release_tsx_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* temp = _impl_.tsx_data_;
  _impl_.tsx_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::_internal_mutable_tsx_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tsx_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData>(GetArenaForAllocation());
    _impl_.tsx_data_ = p;
  }
  return _impl_.tsx_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::mutable_tsx_data() {
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* _msg = _internal_mutable_tsx_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  return _msg;
}
inline void MoneroTransactionInitRequest::set_allocated_tsx_data(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tsx_data_;
  }
  if (tsx_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tsx_data);
    if (message_arena != submessage_arena) {
      tsx_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tsx_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tsx_data_ = tsx_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
}

// -------------------------------------------------------------------

// MoneroTransactionInitAck

// repeated bytes hmacs = 1;
inline int MoneroTransactionInitAck::_internal_hmacs_size() const {
  return _impl_.hmacs_.size();
}
inline int MoneroTransactionInitAck::hmacs_size() const {
  return _internal_hmacs_size();
}
inline void MoneroTransactionInitAck::clear_hmacs() {
  _impl_.hmacs_.Clear();
}
inline std::string* MoneroTransactionInitAck::add_hmacs() {
  std::string* _s = _internal_add_hmacs();
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return _s;
}
inline const std::string& MoneroTransactionInitAck::_internal_hmacs(int index) const {
  return _impl_.hmacs_.Get(index);
}
inline const std::string& MoneroTransactionInitAck::hmacs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return _internal_hmacs(index);
}
inline std::string* MoneroTransactionInitAck::mutable_hmacs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return _impl_.hmacs_.Mutable(index);
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const std::string& value) {
  _impl_.hmacs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::set_hmacs(int index, std::string&& value) {
  _impl_.hmacs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hmacs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const void* value, size_t size) {
  _impl_.hmacs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline std::string* MoneroTransactionInitAck::_internal_add_hmacs() {
  return _impl_.hmacs_.Add();
}
inline void MoneroTransactionInitAck::add_hmacs(const std::string& value) {
  _impl_.hmacs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::add_hmacs(std::string&& value) {
  _impl_.hmacs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::add_hmacs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hmacs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::add_hmacs(const void* value, size_t size) {
  _impl_.hmacs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MoneroTransactionInitAck::hmacs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return _impl_.hmacs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MoneroTransactionInitAck::mutable_hmacs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return &_impl_.hmacs_;
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;
inline bool MoneroTransactionInitAck::_internal_has_rsig_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsig_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionInitAck::has_rsig_data() const {
  return _internal_has_rsig_data();
}
inline void MoneroTransactionInitAck::clear_rsig_data() {
  if (_impl_.rsig_data_ != nullptr) _impl_.rsig_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionInitAck::_internal_rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = _impl_.rsig_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionInitAck::rsig_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
  return _internal_rsig_data();
}
inline void MoneroTransactionInitAck::unsafe_arena_set_allocated_rsig_data(
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsig_data_);
  }
  _impl_.rsig_data_ = rsig_data;
  if (rsig_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitAck::release_rsig_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitAck::unsafe_arena_release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitAck::_internal_mutable_rsig_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaForAllocation());
    _impl_.rsig_data_ = p;
  }
  return _impl_.rsig_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionInitAck::mutable_rsig_data() {
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _msg = _internal_mutable_rsig_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
  return _msg;
}
inline void MoneroTransactionInitAck::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsig_data_;
  }
  if (rsig_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsig_data);
    if (message_arena != submessage_arena) {
      rsig_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitAck.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionSetInputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionSetInputRequest::_internal_has_src_entr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_entr_ != nullptr);
  return value;
}
inline bool MoneroTransactionSetInputRequest::has_src_entr() const {
  return _internal_has_src_entr();
}
inline void MoneroTransactionSetInputRequest::clear_src_entr() {
  if (_impl_.src_entr_ != nullptr) _impl_.src_entr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSetInputRequest::_internal_src_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* p = _impl_.src_entr_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry&>(
      ::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSetInputRequest::src_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  return _internal_src_entr();
}
inline void MoneroTransactionSetInputRequest::unsafe_arena_set_allocated_src_entr(
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_entr_);
  }
  _impl_.src_entr_ = src_entr;
  if (src_entr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::release_src_entr() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = _impl_.src_entr_;
  _impl_.src_entr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::unsafe_arena_release_src_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = _impl_.src_entr_;
  _impl_.src_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::_internal_mutable_src_entr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.src_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(GetArenaForAllocation());
    _impl_.src_entr_ = p;
  }
  return _impl_.src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::mutable_src_entr() {
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* _msg = _internal_mutable_src_entr();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  return _msg;
}
inline void MoneroTransactionSetInputRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.src_entr_;
  }
  if (src_entr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src_entr);
    if (message_arena != submessage_arena) {
      src_entr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_entr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.src_entr_ = src_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
}

// -------------------------------------------------------------------

// MoneroTransactionSetInputAck

// optional bytes vini = 1;
inline bool MoneroTransactionSetInputAck::_internal_has_vini() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSetInputAck::has_vini() const {
  return _internal_has_vini();
}
inline void MoneroTransactionSetInputAck::clear_vini() {
  _impl_.vini_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSetInputAck::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  return _internal_vini();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetInputAck::set_vini(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vini_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
inline std::string* MoneroTransactionSetInputAck::mutable_vini() {
  std::string* _s = _internal_mutable_vini();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  return _s;
}
inline const std::string& MoneroTransactionSetInputAck::_internal_vini() const {
  return _impl_.vini_.Get();
}
inline void MoneroTransactionSetInputAck::_internal_set_vini(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vini_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::_internal_mutable_vini() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vini_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::release_vini() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  if (!_internal_has_vini()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vini_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_.IsDefault()) {
    _impl_.vini_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetInputAck::set_allocated_vini(std::string* vini) {
  if (vini != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vini_.SetAllocated(vini, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_.IsDefault()) {
    _impl_.vini_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}

// optional bytes vini_hmac = 2;
inline bool MoneroTransactionSetInputAck::_internal_has_vini_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSetInputAck::has_vini_hmac() const {
  return _internal_has_vini_hmac();
}
inline void MoneroTransactionSetInputAck::clear_vini_hmac() {
  _impl_.vini_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSetInputAck::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  return _internal_vini_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetInputAck::set_vini_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vini_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
inline std::string* MoneroTransactionSetInputAck::mutable_vini_hmac() {
  std::string* _s = _internal_mutable_vini_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  return _s;
}
inline const std::string& MoneroTransactionSetInputAck::_internal_vini_hmac() const {
  return _impl_.vini_hmac_.Get();
}
inline void MoneroTransactionSetInputAck::_internal_set_vini_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vini_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::_internal_mutable_vini_hmac() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vini_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::release_vini_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  if (!_internal_has_vini_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vini_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_hmac_.IsDefault()) {
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetInputAck::set_allocated_vini_hmac(std::string* vini_hmac) {
  if (vini_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vini_hmac_.SetAllocated(vini_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_hmac_.IsDefault()) {
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}

// optional bytes pseudo_out = 3;
inline bool MoneroTransactionSetInputAck::_internal_has_pseudo_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionSetInputAck::has_pseudo_out() const {
  return _internal_has_pseudo_out();
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out() {
  _impl_.pseudo_out_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionSetInputAck::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  return _internal_pseudo_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetInputAck::set_pseudo_out(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.pseudo_out_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
inline std::string* MoneroTransactionSetInputAck::mutable_pseudo_out() {
  std::string* _s = _internal_mutable_pseudo_out();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  return _s;
}
inline const std::string& MoneroTransactionSetInputAck::_internal_pseudo_out() const {
  return _impl_.pseudo_out_.Get();
}
inline void MoneroTransactionSetInputAck::_internal_set_pseudo_out(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pseudo_out_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::_internal_mutable_pseudo_out() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.pseudo_out_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  if (!_internal_has_pseudo_out()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.pseudo_out_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out(std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pseudo_out_.SetAllocated(pseudo_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}

// optional bytes pseudo_out_hmac = 4;
inline bool MoneroTransactionSetInputAck::_internal_has_pseudo_out_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionSetInputAck::has_pseudo_out_hmac() const {
  return _internal_has_pseudo_out_hmac();
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out_hmac() {
  _impl_.pseudo_out_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroTransactionSetInputAck::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  return _internal_pseudo_out_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetInputAck::set_pseudo_out_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.pseudo_out_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
inline std::string* MoneroTransactionSetInputAck::mutable_pseudo_out_hmac() {
  std::string* _s = _internal_mutable_pseudo_out_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  return _s;
}
inline const std::string& MoneroTransactionSetInputAck::_internal_pseudo_out_hmac() const {
  return _impl_.pseudo_out_hmac_.Get();
}
inline void MoneroTransactionSetInputAck::_internal_set_pseudo_out_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pseudo_out_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::_internal_mutable_pseudo_out_hmac() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.pseudo_out_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::release_pseudo_out_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  if (!_internal_has_pseudo_out_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.pseudo_out_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_hmac_.IsDefault()) {
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out_hmac(std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.pseudo_out_hmac_.SetAllocated(pseudo_out_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_hmac_.IsDefault()) {
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}

// optional bytes pseudo_out_alpha = 5;
inline bool MoneroTransactionSetInputAck::_internal_has_pseudo_out_alpha() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionSetInputAck::has_pseudo_out_alpha() const {
  return _internal_has_pseudo_out_alpha();
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out_alpha() {
  _impl_.pseudo_out_alpha_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MoneroTransactionSetInputAck::pseudo_out_alpha() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
  return _internal_pseudo_out_alpha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetInputAck::set_pseudo_out_alpha(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.pseudo_out_alpha_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}
inline std::string* MoneroTransactionSetInputAck::mutable_pseudo_out_alpha() {
  std::string* _s = _internal_mutable_pseudo_out_alpha();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
  return _s;
}
inline const std::string& MoneroTransactionSetInputAck::_internal_pseudo_out_alpha() const {
  return _impl_.pseudo_out_alpha_.Get();
}
inline void MoneroTransactionSetInputAck::_internal_set_pseudo_out_alpha(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pseudo_out_alpha_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::_internal_mutable_pseudo_out_alpha() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pseudo_out_alpha_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::release_pseudo_out_alpha() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
  if (!_internal_has_pseudo_out_alpha()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.pseudo_out_alpha_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_alpha_.IsDefault()) {
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out_alpha(std::string* pseudo_out_alpha) {
  if (pseudo_out_alpha != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pseudo_out_alpha_.SetAllocated(pseudo_out_alpha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_alpha_.IsDefault()) {
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_alpha)
}

// optional bytes spend_key = 6;
inline bool MoneroTransactionSetInputAck::_internal_has_spend_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoneroTransactionSetInputAck::has_spend_key() const {
  return _internal_has_spend_key();
}
inline void MoneroTransactionSetInputAck::clear_spend_key() {
  _impl_.spend_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MoneroTransactionSetInputAck::spend_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
  return _internal_spend_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetInputAck::set_spend_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.spend_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}
inline std::string* MoneroTransactionSetInputAck::mutable_spend_key() {
  std::string* _s = _internal_mutable_spend_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
  return _s;
}
inline const std::string& MoneroTransactionSetInputAck::_internal_spend_key() const {
  return _impl_.spend_key_.Get();
}
inline void MoneroTransactionSetInputAck::_internal_set_spend_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.spend_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::_internal_mutable_spend_key() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.spend_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetInputAck::release_spend_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
  if (!_internal_has_spend_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.spend_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_key_.IsDefault()) {
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetInputAck::set_allocated_spend_key(std::string* spend_key) {
  if (spend_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.spend_key_.SetAllocated(spend_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_key_.IsDefault()) {
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_key)
}

// -------------------------------------------------------------------

// MoneroTransactionInputViniRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionInputViniRequest::_internal_has_src_entr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_entr_ != nullptr);
  return value;
}
inline bool MoneroTransactionInputViniRequest::has_src_entr() const {
  return _internal_has_src_entr();
}
inline void MoneroTransactionInputViniRequest::clear_src_entr() {
  if (_impl_.src_entr_ != nullptr) _impl_.src_entr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionInputViniRequest::_internal_src_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* p = _impl_.src_entr_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry&>(
      ::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionInputViniRequest::src_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  return _internal_src_entr();
}
inline void MoneroTransactionInputViniRequest::unsafe_arena_set_allocated_src_entr(
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_entr_);
  }
  _impl_.src_entr_ = src_entr;
  if (src_entr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::release_src_entr() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = _impl_.src_entr_;
  _impl_.src_entr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::unsafe_arena_release_src_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = _impl_.src_entr_;
  _impl_.src_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::_internal_mutable_src_entr() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.src_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(GetArenaForAllocation());
    _impl_.src_entr_ = p;
  }
  return _impl_.src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::mutable_src_entr() {
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* _msg = _internal_mutable_src_entr();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  return _msg;
}
inline void MoneroTransactionInputViniRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.src_entr_;
  }
  if (src_entr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src_entr);
    if (message_arena != submessage_arena) {
      src_entr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_entr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.src_entr_ = src_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
}

// optional bytes vini = 2;
inline bool MoneroTransactionInputViniRequest::_internal_has_vini() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionInputViniRequest::has_vini() const {
  return _internal_has_vini();
}
inline void MoneroTransactionInputViniRequest::clear_vini() {
  _impl_.vini_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionInputViniRequest::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  return _internal_vini();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionInputViniRequest::set_vini(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vini_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
inline std::string* MoneroTransactionInputViniRequest::mutable_vini() {
  std::string* _s = _internal_mutable_vini();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  return _s;
}
inline const std::string& MoneroTransactionInputViniRequest::_internal_vini() const {
  return _impl_.vini_.Get();
}
inline void MoneroTransactionInputViniRequest::_internal_set_vini(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vini_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::_internal_mutable_vini() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vini_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::release_vini() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  if (!_internal_has_vini()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vini_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_.IsDefault()) {
    _impl_.vini_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionInputViniRequest::set_allocated_vini(std::string* vini) {
  if (vini != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vini_.SetAllocated(vini, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_.IsDefault()) {
    _impl_.vini_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}

// optional bytes vini_hmac = 3;
inline bool MoneroTransactionInputViniRequest::_internal_has_vini_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionInputViniRequest::has_vini_hmac() const {
  return _internal_has_vini_hmac();
}
inline void MoneroTransactionInputViniRequest::clear_vini_hmac() {
  _impl_.vini_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionInputViniRequest::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  return _internal_vini_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionInputViniRequest::set_vini_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vini_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
inline std::string* MoneroTransactionInputViniRequest::mutable_vini_hmac() {
  std::string* _s = _internal_mutable_vini_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  return _s;
}
inline const std::string& MoneroTransactionInputViniRequest::_internal_vini_hmac() const {
  return _impl_.vini_hmac_.Get();
}
inline void MoneroTransactionInputViniRequest::_internal_set_vini_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vini_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::_internal_mutable_vini_hmac() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vini_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::release_vini_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  if (!_internal_has_vini_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vini_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_hmac_.IsDefault()) {
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionInputViniRequest::set_allocated_vini_hmac(std::string* vini_hmac) {
  if (vini_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vini_hmac_.SetAllocated(vini_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_hmac_.IsDefault()) {
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}

// optional bytes pseudo_out = 4;
inline bool MoneroTransactionInputViniRequest::_internal_has_pseudo_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionInputViniRequest::has_pseudo_out() const {
  return _internal_has_pseudo_out();
}
inline void MoneroTransactionInputViniRequest::clear_pseudo_out() {
  _impl_.pseudo_out_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionInputViniRequest::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  return _internal_pseudo_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionInputViniRequest::set_pseudo_out(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.pseudo_out_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
inline std::string* MoneroTransactionInputViniRequest::mutable_pseudo_out() {
  std::string* _s = _internal_mutable_pseudo_out();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  return _s;
}
inline const std::string& MoneroTransactionInputViniRequest::_internal_pseudo_out() const {
  return _impl_.pseudo_out_.Get();
}
inline void MoneroTransactionInputViniRequest::_internal_set_pseudo_out(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pseudo_out_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::_internal_mutable_pseudo_out() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.pseudo_out_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  if (!_internal_has_pseudo_out()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.pseudo_out_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionInputViniRequest::set_allocated_pseudo_out(std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pseudo_out_.SetAllocated(pseudo_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}

// optional bytes pseudo_out_hmac = 5;
inline bool MoneroTransactionInputViniRequest::_internal_has_pseudo_out_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionInputViniRequest::has_pseudo_out_hmac() const {
  return _internal_has_pseudo_out_hmac();
}
inline void MoneroTransactionInputViniRequest::clear_pseudo_out_hmac() {
  _impl_.pseudo_out_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroTransactionInputViniRequest::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  return _internal_pseudo_out_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.pseudo_out_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
inline std::string* MoneroTransactionInputViniRequest::mutable_pseudo_out_hmac() {
  std::string* _s = _internal_mutable_pseudo_out_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  return _s;
}
inline const std::string& MoneroTransactionInputViniRequest::_internal_pseudo_out_hmac() const {
  return _impl_.pseudo_out_hmac_.Get();
}
inline void MoneroTransactionInputViniRequest::_internal_set_pseudo_out_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pseudo_out_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::_internal_mutable_pseudo_out_hmac() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.pseudo_out_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionInputViniRequest::release_pseudo_out_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  if (!_internal_has_pseudo_out_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.pseudo_out_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_hmac_.IsDefault()) {
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionInputViniRequest::set_allocated_pseudo_out_hmac(std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.pseudo_out_hmac_.SetAllocated(pseudo_out_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_hmac_.IsDefault()) {
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}

// optional uint32 orig_idx = 6;
inline bool MoneroTransactionInputViniRequest::_internal_has_orig_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoneroTransactionInputViniRequest::has_orig_idx() const {
  return _internal_has_orig_idx();
}
inline void MoneroTransactionInputViniRequest::clear_orig_idx() {
  _impl_.orig_idx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoneroTransactionInputViniRequest::_internal_orig_idx() const {
  return _impl_.orig_idx_;
}
inline uint32_t MoneroTransactionInputViniRequest::orig_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.orig_idx)
  return _internal_orig_idx();
}
inline void MoneroTransactionInputViniRequest::_internal_set_orig_idx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.orig_idx_ = value;
}
inline void MoneroTransactionInputViniRequest::set_orig_idx(uint32_t value) {
  _internal_set_orig_idx(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.orig_idx)
}

// -------------------------------------------------------------------

// MoneroTransactionInputViniAck

// -------------------------------------------------------------------

// MoneroTransactionAllInputsSetRequest

// -------------------------------------------------------------------

// MoneroTransactionAllInputsSetAck

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
inline bool MoneroTransactionAllInputsSetAck::_internal_has_rsig_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsig_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionAllInputsSetAck::has_rsig_data() const {
  return _internal_has_rsig_data();
}
inline void MoneroTransactionAllInputsSetAck::clear_rsig_data() {
  if (_impl_.rsig_data_ != nullptr) _impl_.rsig_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionAllInputsSetAck::_internal_rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = _impl_.rsig_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionAllInputsSetAck::rsig_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
  return _internal_rsig_data();
}
inline void MoneroTransactionAllInputsSetAck::unsafe_arena_set_allocated_rsig_data(
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsig_data_);
  }
  _impl_.rsig_data_ = rsig_data;
  if (rsig_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllInputsSetAck::release_rsig_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllInputsSetAck::unsafe_arena_release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllInputsSetAck::_internal_mutable_rsig_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaForAllocation());
    _impl_.rsig_data_ = p;
  }
  return _impl_.rsig_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllInputsSetAck::mutable_rsig_data() {
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _msg = _internal_mutable_rsig_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
  return _msg;
}
inline void MoneroTransactionAllInputsSetAck::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsig_data_;
  }
  if (rsig_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsig_data);
    if (message_arena != submessage_arena) {
      rsig_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllInputsSetAck.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionSetOutputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
inline bool MoneroTransactionSetOutputRequest::_internal_has_dst_entr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_entr_ != nullptr);
  return value;
}
inline bool MoneroTransactionSetOutputRequest::has_dst_entr() const {
  return _internal_has_dst_entr();
}
inline void MoneroTransactionSetOutputRequest::clear_dst_entr() {
  if (_impl_.dst_entr_ != nullptr) _impl_.dst_entr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionSetOutputRequest::_internal_dst_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* p = _impl_.dst_entr_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry&>(
      ::hw::trezor::messages::monero::_MoneroTransactionDestinationEntry_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionSetOutputRequest::dst_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  return _internal_dst_entr();
}
inline void MoneroTransactionSetOutputRequest::unsafe_arena_set_allocated_dst_entr(
    ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dst_entr_);
  }
  _impl_.dst_entr_ = dst_entr;
  if (dst_entr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::release_dst_entr() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = _impl_.dst_entr_;
  _impl_.dst_entr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::unsafe_arena_release_dst_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = _impl_.dst_entr_;
  _impl_.dst_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::_internal_mutable_dst_entr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dst_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionDestinationEntry>(GetArenaForAllocation());
    _impl_.dst_entr_ = p;
  }
  return _impl_.dst_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::mutable_dst_entr() {
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* _msg = _internal_mutable_dst_entr();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  return _msg;
}
inline void MoneroTransactionSetOutputRequest::set_allocated_dst_entr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dst_entr_;
  }
  if (dst_entr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dst_entr);
    if (message_arena != submessage_arena) {
      dst_entr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst_entr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dst_entr_ = dst_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
}

// optional bytes dst_entr_hmac = 2;
inline bool MoneroTransactionSetOutputRequest::_internal_has_dst_entr_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSetOutputRequest::has_dst_entr_hmac() const {
  return _internal_has_dst_entr_hmac();
}
inline void MoneroTransactionSetOutputRequest::clear_dst_entr_hmac() {
  _impl_.dst_entr_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSetOutputRequest::dst_entr_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  return _internal_dst_entr_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dst_entr_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
inline std::string* MoneroTransactionSetOutputRequest::mutable_dst_entr_hmac() {
  std::string* _s = _internal_mutable_dst_entr_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  return _s;
}
inline const std::string& MoneroTransactionSetOutputRequest::_internal_dst_entr_hmac() const {
  return _impl_.dst_entr_hmac_.Get();
}
inline void MoneroTransactionSetOutputRequest::_internal_set_dst_entr_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dst_entr_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputRequest::_internal_mutable_dst_entr_hmac() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dst_entr_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputRequest::release_dst_entr_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  if (!_internal_has_dst_entr_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dst_entr_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_entr_hmac_.IsDefault()) {
    _impl_.dst_entr_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetOutputRequest::set_allocated_dst_entr_hmac(std::string* dst_entr_hmac) {
  if (dst_entr_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dst_entr_hmac_.SetAllocated(dst_entr_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_entr_hmac_.IsDefault()) {
    _impl_.dst_entr_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
inline bool MoneroTransactionSetOutputRequest::_internal_has_rsig_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsig_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionSetOutputRequest::has_rsig_data() const {
  return _internal_has_rsig_data();
}
inline void MoneroTransactionSetOutputRequest::clear_rsig_data() {
  if (_impl_.rsig_data_ != nullptr) _impl_.rsig_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionSetOutputRequest::_internal_rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = _impl_.rsig_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionSetOutputRequest::rsig_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
  return _internal_rsig_data();
}
inline void MoneroTransactionSetOutputRequest::unsafe_arena_set_allocated_rsig_data(
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsig_data_);
  }
  _impl_.rsig_data_ = rsig_data;
  if (rsig_data) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputRequest::release_rsig_data() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputRequest::unsafe_arena_release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputRequest::_internal_mutable_rsig_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaForAllocation());
    _impl_.rsig_data_ = p;
  }
  return _impl_.rsig_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputRequest::mutable_rsig_data() {
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _msg = _internal_mutable_rsig_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
  return _msg;
}
inline void MoneroTransactionSetOutputRequest::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsig_data_;
  }
  if (rsig_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsig_data);
    if (message_arena != submessage_arena) {
      rsig_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.rsig_data)
}

// optional bool is_offloaded_bp = 4;
inline bool MoneroTransactionSetOutputRequest::_internal_has_is_offloaded_bp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionSetOutputRequest::has_is_offloaded_bp() const {
  return _internal_has_is_offloaded_bp();
}
inline void MoneroTransactionSetOutputRequest::clear_is_offloaded_bp() {
  _impl_.is_offloaded_bp_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MoneroTransactionSetOutputRequest::_internal_is_offloaded_bp() const {
  return _impl_.is_offloaded_bp_;
}
inline bool MoneroTransactionSetOutputRequest::is_offloaded_bp() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.is_offloaded_bp)
  return _internal_is_offloaded_bp();
}
inline void MoneroTransactionSetOutputRequest::_internal_set_is_offloaded_bp(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_offloaded_bp_ = value;
}
inline void MoneroTransactionSetOutputRequest::set_is_offloaded_bp(bool value) {
  _internal_set_is_offloaded_bp(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.is_offloaded_bp)
}

// -------------------------------------------------------------------

// MoneroTransactionSetOutputAck

// optional bytes tx_out = 1;
inline bool MoneroTransactionSetOutputAck::_internal_has_tx_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSetOutputAck::has_tx_out() const {
  return _internal_has_tx_out();
}
inline void MoneroTransactionSetOutputAck::clear_tx_out() {
  _impl_.tx_out_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSetOutputAck::tx_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  return _internal_tx_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetOutputAck::set_tx_out(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tx_out_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
inline std::string* MoneroTransactionSetOutputAck::mutable_tx_out() {
  std::string* _s = _internal_mutable_tx_out();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  return _s;
}
inline const std::string& MoneroTransactionSetOutputAck::_internal_tx_out() const {
  return _impl_.tx_out_.Get();
}
inline void MoneroTransactionSetOutputAck::_internal_set_tx_out(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tx_out_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::_internal_mutable_tx_out() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tx_out_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::release_tx_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  if (!_internal_has_tx_out()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tx_out_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_out_.IsDefault()) {
    _impl_.tx_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetOutputAck::set_allocated_tx_out(std::string* tx_out) {
  if (tx_out != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tx_out_.SetAllocated(tx_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_out_.IsDefault()) {
    _impl_.tx_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}

// optional bytes vouti_hmac = 2;
inline bool MoneroTransactionSetOutputAck::_internal_has_vouti_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSetOutputAck::has_vouti_hmac() const {
  return _internal_has_vouti_hmac();
}
inline void MoneroTransactionSetOutputAck::clear_vouti_hmac() {
  _impl_.vouti_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSetOutputAck::vouti_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  return _internal_vouti_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetOutputAck::set_vouti_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vouti_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
inline std::string* MoneroTransactionSetOutputAck::mutable_vouti_hmac() {
  std::string* _s = _internal_mutable_vouti_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  return _s;
}
inline const std::string& MoneroTransactionSetOutputAck::_internal_vouti_hmac() const {
  return _impl_.vouti_hmac_.Get();
}
inline void MoneroTransactionSetOutputAck::_internal_set_vouti_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vouti_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::_internal_mutable_vouti_hmac() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vouti_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::release_vouti_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  if (!_internal_has_vouti_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vouti_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vouti_hmac_.IsDefault()) {
    _impl_.vouti_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetOutputAck::set_allocated_vouti_hmac(std::string* vouti_hmac) {
  if (vouti_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vouti_hmac_.SetAllocated(vouti_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vouti_hmac_.IsDefault()) {
    _impl_.vouti_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;
inline bool MoneroTransactionSetOutputAck::_internal_has_rsig_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsig_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionSetOutputAck::has_rsig_data() const {
  return _internal_has_rsig_data();
}
inline void MoneroTransactionSetOutputAck::clear_rsig_data() {
  if (_impl_.rsig_data_ != nullptr) _impl_.rsig_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionSetOutputAck::_internal_rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = _impl_.rsig_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionSetOutputAck::rsig_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
  return _internal_rsig_data();
}
inline void MoneroTransactionSetOutputAck::unsafe_arena_set_allocated_rsig_data(
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsig_data_);
  }
  _impl_.rsig_data_ = rsig_data;
  if (rsig_data) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputAck::release_rsig_data() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputAck::unsafe_arena_release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputAck::_internal_mutable_rsig_data() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaForAllocation());
    _impl_.rsig_data_ = p;
  }
  return _impl_.rsig_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionSetOutputAck::mutable_rsig_data() {
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _msg = _internal_mutable_rsig_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
  return _msg;
}
inline void MoneroTransactionSetOutputAck::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsig_data_;
  }
  if (rsig_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsig_data);
    if (message_arena != submessage_arena) {
      rsig_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig_data)
}

// optional bytes out_pk = 4;
inline bool MoneroTransactionSetOutputAck::_internal_has_out_pk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionSetOutputAck::has_out_pk() const {
  return _internal_has_out_pk();
}
inline void MoneroTransactionSetOutputAck::clear_out_pk() {
  _impl_.out_pk_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionSetOutputAck::out_pk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  return _internal_out_pk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetOutputAck::set_out_pk(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.out_pk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
inline std::string* MoneroTransactionSetOutputAck::mutable_out_pk() {
  std::string* _s = _internal_mutable_out_pk();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  return _s;
}
inline const std::string& MoneroTransactionSetOutputAck::_internal_out_pk() const {
  return _impl_.out_pk_.Get();
}
inline void MoneroTransactionSetOutputAck::_internal_set_out_pk(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.out_pk_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::_internal_mutable_out_pk() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.out_pk_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::release_out_pk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  if (!_internal_has_out_pk()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.out_pk_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.out_pk_.IsDefault()) {
    _impl_.out_pk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetOutputAck::set_allocated_out_pk(std::string* out_pk) {
  if (out_pk != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.out_pk_.SetAllocated(out_pk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.out_pk_.IsDefault()) {
    _impl_.out_pk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}

// optional bytes ecdh_info = 5;
inline bool MoneroTransactionSetOutputAck::_internal_has_ecdh_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionSetOutputAck::has_ecdh_info() const {
  return _internal_has_ecdh_info();
}
inline void MoneroTransactionSetOutputAck::clear_ecdh_info() {
  _impl_.ecdh_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroTransactionSetOutputAck::ecdh_info() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  return _internal_ecdh_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSetOutputAck::set_ecdh_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.ecdh_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
inline std::string* MoneroTransactionSetOutputAck::mutable_ecdh_info() {
  std::string* _s = _internal_mutable_ecdh_info();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  return _s;
}
inline const std::string& MoneroTransactionSetOutputAck::_internal_ecdh_info() const {
  return _impl_.ecdh_info_.Get();
}
inline void MoneroTransactionSetOutputAck::_internal_set_ecdh_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ecdh_info_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::_internal_mutable_ecdh_info() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.ecdh_info_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSetOutputAck::release_ecdh_info() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  if (!_internal_has_ecdh_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.ecdh_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecdh_info_.IsDefault()) {
    _impl_.ecdh_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSetOutputAck::set_allocated_ecdh_info(std::string* ecdh_info) {
  if (ecdh_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ecdh_info_.SetAllocated(ecdh_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ecdh_info_.IsDefault()) {
    _impl_.ecdh_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetRequest

// optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;
inline bool MoneroTransactionAllOutSetRequest::_internal_has_rsig_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rsig_data_ != nullptr);
  return value;
}
inline bool MoneroTransactionAllOutSetRequest::has_rsig_data() const {
  return _internal_has_rsig_data();
}
inline void MoneroTransactionAllOutSetRequest::clear_rsig_data() {
  if (_impl_.rsig_data_ != nullptr) _impl_.rsig_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionAllOutSetRequest::_internal_rsig_data() const {
  const ::hw::trezor::messages::monero::MoneroTransactionRsigData* p = _impl_.rsig_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionRsigData&>(
      ::hw::trezor::messages::monero::_MoneroTransactionRsigData_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionRsigData& MoneroTransactionAllOutSetRequest::rsig_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
  return _internal_rsig_data();
}
inline void MoneroTransactionAllOutSetRequest::unsafe_arena_set_allocated_rsig_data(
    ::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rsig_data_);
  }
  _impl_.rsig_data_ = rsig_data;
  if (rsig_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllOutSetRequest::release_rsig_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllOutSetRequest::unsafe_arena_release_rsig_data() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* temp = _impl_.rsig_data_;
  _impl_.rsig_data_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllOutSetRequest::_internal_mutable_rsig_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rsig_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionRsigData>(GetArenaForAllocation());
    _impl_.rsig_data_ = p;
  }
  return _impl_.rsig_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionRsigData* MoneroTransactionAllOutSetRequest::mutable_rsig_data() {
  ::hw::trezor::messages::monero::MoneroTransactionRsigData* _msg = _internal_mutable_rsig_data();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
  return _msg;
}
inline void MoneroTransactionAllOutSetRequest::set_allocated_rsig_data(::hw::trezor::messages::monero::MoneroTransactionRsigData* rsig_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rsig_data_;
  }
  if (rsig_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rsig_data);
    if (message_arena != submessage_arena) {
      rsig_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsig_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rsig_data_ = rsig_data;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest.rsig_data)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetAck_MoneroRingCtSig

// optional uint64 txn_fee = 1;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_has_txn_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_txn_fee() const {
  return _internal_has_txn_fee();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_txn_fee() {
  _impl_.txn_fee_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_txn_fee() const {
  return _impl_.txn_fee_;
}
inline uint64_t MoneroTransactionAllOutSetAck_MoneroRingCtSig::txn_fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
  return _internal_txn_fee();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_set_txn_fee(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.txn_fee_ = value;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_txn_fee(uint64_t value) {
  _internal_set_txn_fee(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
}

// optional bytes message = 2;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_message() const {
  return _internal_has_message();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionAllOutSetAck_MoneroRingCtSig::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
inline std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  return _s;
}
inline const std::string& MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::release_message() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}

// optional uint32 rv_type = 3;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_has_rv_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_rv_type() const {
  return _internal_has_rv_type();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_rv_type() {
  _impl_.rv_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_rv_type() const {
  return _impl_.rv_type_;
}
inline uint32_t MoneroTransactionAllOutSetAck_MoneroRingCtSig::rv_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
  return _internal_rv_type();
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::_internal_set_rv_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rv_type_ = value;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_rv_type(uint32_t value) {
  _internal_set_rv_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetAck

// optional bytes extra = 1;
inline bool MoneroTransactionAllOutSetAck::_internal_has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionAllOutSetAck::has_extra() const {
  return _internal_has_extra();
}
inline void MoneroTransactionAllOutSetAck::clear_extra() {
  _impl_.extra_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionAllOutSetAck::extra() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionAllOutSetAck::set_extra(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.extra_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
inline std::string* MoneroTransactionAllOutSetAck::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  return _s;
}
inline const std::string& MoneroTransactionAllOutSetAck::_internal_extra() const {
  return _impl_.extra_.Get();
}
inline void MoneroTransactionAllOutSetAck::_internal_set_extra(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.extra_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck::_internal_mutable_extra() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.extra_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck::release_extra() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  if (!_internal_has_extra()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.extra_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionAllOutSetAck::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}

// optional bytes tx_prefix_hash = 2;
inline bool MoneroTransactionAllOutSetAck::_internal_has_tx_prefix_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionAllOutSetAck::has_tx_prefix_hash() const {
  return _internal_has_tx_prefix_hash();
}
inline void MoneroTransactionAllOutSetAck::clear_tx_prefix_hash() {
  _impl_.tx_prefix_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionAllOutSetAck::tx_prefix_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  return _internal_tx_prefix_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tx_prefix_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
inline std::string* MoneroTransactionAllOutSetAck::mutable_tx_prefix_hash() {
  std::string* _s = _internal_mutable_tx_prefix_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  return _s;
}
inline const std::string& MoneroTransactionAllOutSetAck::_internal_tx_prefix_hash() const {
  return _impl_.tx_prefix_hash_.Get();
}
inline void MoneroTransactionAllOutSetAck::_internal_set_tx_prefix_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tx_prefix_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck::_internal_mutable_tx_prefix_hash() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tx_prefix_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck::release_tx_prefix_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  if (!_internal_has_tx_prefix_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tx_prefix_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_prefix_hash_.IsDefault()) {
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionAllOutSetAck::set_allocated_tx_prefix_hash(std::string* tx_prefix_hash) {
  if (tx_prefix_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tx_prefix_hash_.SetAllocated(tx_prefix_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_prefix_hash_.IsDefault()) {
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}

// optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;
inline bool MoneroTransactionAllOutSetAck::_internal_has_rv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rv_ != nullptr);
  return value;
}
inline bool MoneroTransactionAllOutSetAck::has_rv() const {
  return _internal_has_rv();
}
inline void MoneroTransactionAllOutSetAck::clear_rv() {
  if (_impl_.rv_ != nullptr) _impl_.rv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& MoneroTransactionAllOutSetAck::_internal_rv() const {
  const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* p = _impl_.rv_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig&>(
      ::hw::trezor::messages::monero::_MoneroTransactionAllOutSetAck_MoneroRingCtSig_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& MoneroTransactionAllOutSetAck::rv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  return _internal_rv();
}
inline void MoneroTransactionAllOutSetAck::unsafe_arena_set_allocated_rv(
    ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rv_);
  }
  _impl_.rv_ = rv;
  if (rv) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::release_rv() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* temp = _impl_.rv_;
  _impl_.rv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::unsafe_arena_release_rv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* temp = _impl_.rv_;
  _impl_.rv_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::_internal_mutable_rv() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rv_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig>(GetArenaForAllocation());
    _impl_.rv_ = p;
  }
  return _impl_.rv_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::mutable_rv() {
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* _msg = _internal_mutable_rv();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  return _msg;
}
inline void MoneroTransactionAllOutSetAck::set_allocated_rv(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rv_;
  }
  if (rv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rv);
    if (message_arena != submessage_arena) {
      rv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rv, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.rv_ = rv;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
}

// optional bytes full_message_hash = 5;
inline bool MoneroTransactionAllOutSetAck::_internal_has_full_message_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionAllOutSetAck::has_full_message_hash() const {
  return _internal_has_full_message_hash();
}
inline void MoneroTransactionAllOutSetAck::clear_full_message_hash() {
  _impl_.full_message_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionAllOutSetAck::full_message_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
  return _internal_full_message_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionAllOutSetAck::set_full_message_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.full_message_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}
inline std::string* MoneroTransactionAllOutSetAck::mutable_full_message_hash() {
  std::string* _s = _internal_mutable_full_message_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
  return _s;
}
inline const std::string& MoneroTransactionAllOutSetAck::_internal_full_message_hash() const {
  return _impl_.full_message_hash_.Get();
}
inline void MoneroTransactionAllOutSetAck::_internal_set_full_message_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.full_message_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck::_internal_mutable_full_message_hash() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.full_message_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionAllOutSetAck::release_full_message_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
  if (!_internal_has_full_message_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.full_message_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_message_hash_.IsDefault()) {
    _impl_.full_message_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionAllOutSetAck::set_allocated_full_message_hash(std::string* full_message_hash) {
  if (full_message_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.full_message_hash_.SetAllocated(full_message_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.full_message_hash_.IsDefault()) {
    _impl_.full_message_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.full_message_hash)
}

// -------------------------------------------------------------------

// MoneroTransactionSignInputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionSignInputRequest::_internal_has_src_entr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_entr_ != nullptr);
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_src_entr() const {
  return _internal_has_src_entr();
}
inline void MoneroTransactionSignInputRequest::clear_src_entr() {
  if (_impl_.src_entr_ != nullptr) _impl_.src_entr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSignInputRequest::_internal_src_entr() const {
  const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* p = _impl_.src_entr_;
  return p != nullptr ? *p : reinterpret_cast<const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry&>(
      ::hw::trezor::messages::monero::_MoneroTransactionSourceEntry_default_instance_);
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSignInputRequest::src_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  return _internal_src_entr();
}
inline void MoneroTransactionSignInputRequest::unsafe_arena_set_allocated_src_entr(
    ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_entr_);
  }
  _impl_.src_entr_ = src_entr;
  if (src_entr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::release_src_entr() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = _impl_.src_entr_;
  _impl_.src_entr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::unsafe_arena_release_src_entr() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = _impl_.src_entr_;
  _impl_.src_entr_ = nullptr;
  return temp;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::_internal_mutable_src_entr() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.src_entr_ == nullptr) {
    auto* p = CreateMaybeMessage<::hw::trezor::messages::monero::MoneroTransactionSourceEntry>(GetArenaForAllocation());
    _impl_.src_entr_ = p;
  }
  return _impl_.src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::mutable_src_entr() {
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* _msg = _internal_mutable_src_entr();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  return _msg;
}
inline void MoneroTransactionSignInputRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.src_entr_;
  }
  if (src_entr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src_entr);
    if (message_arena != submessage_arena) {
      src_entr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_entr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.src_entr_ = src_entr;
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
}

// optional bytes vini = 2;
inline bool MoneroTransactionSignInputRequest::_internal_has_vini() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_vini() const {
  return _internal_has_vini();
}
inline void MoneroTransactionSignInputRequest::clear_vini() {
  _impl_.vini_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSignInputRequest::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  return _internal_vini();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputRequest::set_vini(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.vini_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
inline std::string* MoneroTransactionSignInputRequest::mutable_vini() {
  std::string* _s = _internal_mutable_vini();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  return _s;
}
inline const std::string& MoneroTransactionSignInputRequest::_internal_vini() const {
  return _impl_.vini_.Get();
}
inline void MoneroTransactionSignInputRequest::_internal_set_vini(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vini_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::_internal_mutable_vini() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vini_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::release_vini() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  if (!_internal_has_vini()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.vini_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_.IsDefault()) {
    _impl_.vini_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputRequest::set_allocated_vini(std::string* vini) {
  if (vini != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vini_.SetAllocated(vini, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_.IsDefault()) {
    _impl_.vini_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}

// optional bytes vini_hmac = 3;
inline bool MoneroTransactionSignInputRequest::_internal_has_vini_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_vini_hmac() const {
  return _internal_has_vini_hmac();
}
inline void MoneroTransactionSignInputRequest::clear_vini_hmac() {
  _impl_.vini_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSignInputRequest::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  return _internal_vini_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputRequest::set_vini_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vini_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
inline std::string* MoneroTransactionSignInputRequest::mutable_vini_hmac() {
  std::string* _s = _internal_mutable_vini_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  return _s;
}
inline const std::string& MoneroTransactionSignInputRequest::_internal_vini_hmac() const {
  return _impl_.vini_hmac_.Get();
}
inline void MoneroTransactionSignInputRequest::_internal_set_vini_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vini_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::_internal_mutable_vini_hmac() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vini_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::release_vini_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  if (!_internal_has_vini_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vini_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_hmac_.IsDefault()) {
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputRequest::set_allocated_vini_hmac(std::string* vini_hmac) {
  if (vini_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vini_hmac_.SetAllocated(vini_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vini_hmac_.IsDefault()) {
    _impl_.vini_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}

// optional bytes pseudo_out = 4;
inline bool MoneroTransactionSignInputRequest::_internal_has_pseudo_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_pseudo_out() const {
  return _internal_has_pseudo_out();
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out() {
  _impl_.pseudo_out_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionSignInputRequest::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  return _internal_pseudo_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputRequest::set_pseudo_out(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.pseudo_out_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
inline std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out() {
  std::string* _s = _internal_mutable_pseudo_out();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  return _s;
}
inline const std::string& MoneroTransactionSignInputRequest::_internal_pseudo_out() const {
  return _impl_.pseudo_out_.Get();
}
inline void MoneroTransactionSignInputRequest::_internal_set_pseudo_out(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pseudo_out_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::_internal_mutable_pseudo_out() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.pseudo_out_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  if (!_internal_has_pseudo_out()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.pseudo_out_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out(std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pseudo_out_.SetAllocated(pseudo_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}

// optional bytes pseudo_out_hmac = 5;
inline bool MoneroTransactionSignInputRequest::_internal_has_pseudo_out_hmac() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_pseudo_out_hmac() const {
  return _internal_has_pseudo_out_hmac();
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out_hmac() {
  _impl_.pseudo_out_hmac_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroTransactionSignInputRequest::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  return _internal_pseudo_out_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.pseudo_out_hmac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
inline std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out_hmac() {
  std::string* _s = _internal_mutable_pseudo_out_hmac();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  return _s;
}
inline const std::string& MoneroTransactionSignInputRequest::_internal_pseudo_out_hmac() const {
  return _impl_.pseudo_out_hmac_.Get();
}
inline void MoneroTransactionSignInputRequest::_internal_set_pseudo_out_hmac(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pseudo_out_hmac_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::_internal_mutable_pseudo_out_hmac() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.pseudo_out_hmac_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::release_pseudo_out_hmac() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  if (!_internal_has_pseudo_out_hmac()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.pseudo_out_hmac_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_hmac_.IsDefault()) {
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out_hmac(std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.pseudo_out_hmac_.SetAllocated(pseudo_out_hmac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_hmac_.IsDefault()) {
    _impl_.pseudo_out_hmac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}

// optional bytes pseudo_out_alpha = 6;
inline bool MoneroTransactionSignInputRequest::_internal_has_pseudo_out_alpha() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_pseudo_out_alpha() const {
  return _internal_has_pseudo_out_alpha();
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out_alpha() {
  _impl_.pseudo_out_alpha_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MoneroTransactionSignInputRequest::pseudo_out_alpha() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
  return _internal_pseudo_out_alpha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputRequest::set_pseudo_out_alpha(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.pseudo_out_alpha_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}
inline std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out_alpha() {
  std::string* _s = _internal_mutable_pseudo_out_alpha();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
  return _s;
}
inline const std::string& MoneroTransactionSignInputRequest::_internal_pseudo_out_alpha() const {
  return _impl_.pseudo_out_alpha_.Get();
}
inline void MoneroTransactionSignInputRequest::_internal_set_pseudo_out_alpha(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pseudo_out_alpha_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::_internal_mutable_pseudo_out_alpha() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pseudo_out_alpha_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::release_pseudo_out_alpha() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
  if (!_internal_has_pseudo_out_alpha()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.pseudo_out_alpha_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_alpha_.IsDefault()) {
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out_alpha(std::string* pseudo_out_alpha) {
  if (pseudo_out_alpha != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pseudo_out_alpha_.SetAllocated(pseudo_out_alpha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_alpha_.IsDefault()) {
    _impl_.pseudo_out_alpha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_alpha)
}

// optional bytes spend_key = 7;
inline bool MoneroTransactionSignInputRequest::_internal_has_spend_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_spend_key() const {
  return _internal_has_spend_key();
}
inline void MoneroTransactionSignInputRequest::clear_spend_key() {
  _impl_.spend_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MoneroTransactionSignInputRequest::spend_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
  return _internal_spend_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputRequest::set_spend_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.spend_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}
inline std::string* MoneroTransactionSignInputRequest::mutable_spend_key() {
  std::string* _s = _internal_mutable_spend_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
  return _s;
}
inline const std::string& MoneroTransactionSignInputRequest::_internal_spend_key() const {
  return _impl_.spend_key_.Get();
}
inline void MoneroTransactionSignInputRequest::_internal_set_spend_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.spend_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::_internal_mutable_spend_key() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.spend_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputRequest::release_spend_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
  if (!_internal_has_spend_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.spend_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_key_.IsDefault()) {
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputRequest::set_allocated_spend_key(std::string* spend_key) {
  if (spend_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.spend_key_.SetAllocated(spend_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spend_key_.IsDefault()) {
    _impl_.spend_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_key)
}

// optional uint32 orig_idx = 8;
inline bool MoneroTransactionSignInputRequest::_internal_has_orig_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputRequest::has_orig_idx() const {
  return _internal_has_orig_idx();
}
inline void MoneroTransactionSignInputRequest::clear_orig_idx() {
  _impl_.orig_idx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t MoneroTransactionSignInputRequest::_internal_orig_idx() const {
  return _impl_.orig_idx_;
}
inline uint32_t MoneroTransactionSignInputRequest::orig_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.orig_idx)
  return _internal_orig_idx();
}
inline void MoneroTransactionSignInputRequest::_internal_set_orig_idx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.orig_idx_ = value;
}
inline void MoneroTransactionSignInputRequest::set_orig_idx(uint32_t value) {
  _internal_set_orig_idx(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.orig_idx)
}

// -------------------------------------------------------------------

// MoneroTransactionSignInputAck

// optional bytes signature = 1;
inline bool MoneroTransactionSignInputAck::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputAck::has_signature() const {
  return _internal_has_signature();
}
inline void MoneroTransactionSignInputAck::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionSignInputAck::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputAck::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
inline std::string* MoneroTransactionSignInputAck::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  return _s;
}
inline const std::string& MoneroTransactionSignInputAck::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void MoneroTransactionSignInputAck::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputAck::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputAck::release_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputAck::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}

// optional bytes pseudo_out = 2;
inline bool MoneroTransactionSignInputAck::_internal_has_pseudo_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionSignInputAck::has_pseudo_out() const {
  return _internal_has_pseudo_out();
}
inline void MoneroTransactionSignInputAck::clear_pseudo_out() {
  _impl_.pseudo_out_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionSignInputAck::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputAck.pseudo_out)
  return _internal_pseudo_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionSignInputAck::set_pseudo_out(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pseudo_out_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputAck.pseudo_out)
}
inline std::string* MoneroTransactionSignInputAck::mutable_pseudo_out() {
  std::string* _s = _internal_mutable_pseudo_out();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputAck.pseudo_out)
  return _s;
}
inline const std::string& MoneroTransactionSignInputAck::_internal_pseudo_out() const {
  return _impl_.pseudo_out_.Get();
}
inline void MoneroTransactionSignInputAck::_internal_set_pseudo_out(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pseudo_out_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputAck::_internal_mutable_pseudo_out() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pseudo_out_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionSignInputAck::release_pseudo_out() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionSignInputAck.pseudo_out)
  if (!_internal_has_pseudo_out()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pseudo_out_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionSignInputAck::set_allocated_pseudo_out(std::string* pseudo_out) {
  if (pseudo_out != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pseudo_out_.SetAllocated(pseudo_out, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pseudo_out_.IsDefault()) {
    _impl_.pseudo_out_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputAck.pseudo_out)
}

// -------------------------------------------------------------------

// MoneroTransactionFinalRequest

// -------------------------------------------------------------------

// MoneroTransactionFinalAck

// optional bytes cout_key = 1;
inline bool MoneroTransactionFinalAck::_internal_has_cout_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroTransactionFinalAck::has_cout_key() const {
  return _internal_has_cout_key();
}
inline void MoneroTransactionFinalAck::clear_cout_key() {
  _impl_.cout_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroTransactionFinalAck::cout_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  return _internal_cout_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionFinalAck::set_cout_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cout_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
inline std::string* MoneroTransactionFinalAck::mutable_cout_key() {
  std::string* _s = _internal_mutable_cout_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  return _s;
}
inline const std::string& MoneroTransactionFinalAck::_internal_cout_key() const {
  return _impl_.cout_key_.Get();
}
inline void MoneroTransactionFinalAck::_internal_set_cout_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cout_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::_internal_mutable_cout_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cout_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::release_cout_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  if (!_internal_has_cout_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cout_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cout_key_.IsDefault()) {
    _impl_.cout_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionFinalAck::set_allocated_cout_key(std::string* cout_key) {
  if (cout_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cout_key_.SetAllocated(cout_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cout_key_.IsDefault()) {
    _impl_.cout_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}

// optional bytes salt = 2;
inline bool MoneroTransactionFinalAck::_internal_has_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroTransactionFinalAck::has_salt() const {
  return _internal_has_salt();
}
inline void MoneroTransactionFinalAck::clear_salt() {
  _impl_.salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroTransactionFinalAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionFinalAck::set_salt(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
inline std::string* MoneroTransactionFinalAck::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  return _s;
}
inline const std::string& MoneroTransactionFinalAck::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void MoneroTransactionFinalAck::_internal_set_salt(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::_internal_mutable_salt() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::release_salt() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  if (!_internal_has_salt()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionFinalAck::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}

// optional bytes rand_mult = 3;
inline bool MoneroTransactionFinalAck::_internal_has_rand_mult() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroTransactionFinalAck::has_rand_mult() const {
  return _internal_has_rand_mult();
}
inline void MoneroTransactionFinalAck::clear_rand_mult() {
  _impl_.rand_mult_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroTransactionFinalAck::rand_mult() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  return _internal_rand_mult();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionFinalAck::set_rand_mult(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.rand_mult_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
inline std::string* MoneroTransactionFinalAck::mutable_rand_mult() {
  std::string* _s = _internal_mutable_rand_mult();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  return _s;
}
inline const std::string& MoneroTransactionFinalAck::_internal_rand_mult() const {
  return _impl_.rand_mult_.Get();
}
inline void MoneroTransactionFinalAck::_internal_set_rand_mult(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rand_mult_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::_internal_mutable_rand_mult() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.rand_mult_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::release_rand_mult() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  if (!_internal_has_rand_mult()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.rand_mult_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rand_mult_.IsDefault()) {
    _impl_.rand_mult_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionFinalAck::set_allocated_rand_mult(std::string* rand_mult) {
  if (rand_mult != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rand_mult_.SetAllocated(rand_mult, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rand_mult_.IsDefault()) {
    _impl_.rand_mult_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}

// optional bytes tx_enc_keys = 4;
inline bool MoneroTransactionFinalAck::_internal_has_tx_enc_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroTransactionFinalAck::has_tx_enc_keys() const {
  return _internal_has_tx_enc_keys();
}
inline void MoneroTransactionFinalAck::clear_tx_enc_keys() {
  _impl_.tx_enc_keys_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroTransactionFinalAck::tx_enc_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  return _internal_tx_enc_keys();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionFinalAck::set_tx_enc_keys(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.tx_enc_keys_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
inline std::string* MoneroTransactionFinalAck::mutable_tx_enc_keys() {
  std::string* _s = _internal_mutable_tx_enc_keys();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  return _s;
}
inline const std::string& MoneroTransactionFinalAck::_internal_tx_enc_keys() const {
  return _impl_.tx_enc_keys_.Get();
}
inline void MoneroTransactionFinalAck::_internal_set_tx_enc_keys(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tx_enc_keys_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::_internal_mutable_tx_enc_keys() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tx_enc_keys_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::release_tx_enc_keys() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  if (!_internal_has_tx_enc_keys()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.tx_enc_keys_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_enc_keys_.IsDefault()) {
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionFinalAck::set_allocated_tx_enc_keys(std::string* tx_enc_keys) {
  if (tx_enc_keys != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tx_enc_keys_.SetAllocated(tx_enc_keys, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_enc_keys_.IsDefault()) {
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}

// optional bytes opening_key = 5;
inline bool MoneroTransactionFinalAck::_internal_has_opening_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroTransactionFinalAck::has_opening_key() const {
  return _internal_has_opening_key();
}
inline void MoneroTransactionFinalAck::clear_opening_key() {
  _impl_.opening_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MoneroTransactionFinalAck::opening_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.opening_key)
  return _internal_opening_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroTransactionFinalAck::set_opening_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.opening_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.opening_key)
}
inline std::string* MoneroTransactionFinalAck::mutable_opening_key() {
  std::string* _s = _internal_mutable_opening_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.opening_key)
  return _s;
}
inline const std::string& MoneroTransactionFinalAck::_internal_opening_key() const {
  return _impl_.opening_key_.Get();
}
inline void MoneroTransactionFinalAck::_internal_set_opening_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.opening_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::_internal_mutable_opening_key() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.opening_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroTransactionFinalAck::release_opening_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroTransactionFinalAck.opening_key)
  if (!_internal_has_opening_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.opening_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.opening_key_.IsDefault()) {
    _impl_.opening_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroTransactionFinalAck::set_allocated_opening_key(std::string* opening_key) {
  if (opening_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.opening_key_.SetAllocated(opening_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.opening_key_.IsDefault()) {
    _impl_.opening_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.opening_key)
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList

// required uint32 account = 1;
inline bool MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_has_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::has_account() const {
  return _internal_has_account();
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_account() {
  _impl_.account_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_account() const {
  return _impl_.account_;
}
inline uint32_t MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
  return _internal_account();
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_set_account(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.account_ = value;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_account(uint32_t value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
}

// repeated uint32 minor_indices = 2;
inline int MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_minor_indices_size() const {
  return _impl_.minor_indices_.size();
}
inline int MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices_size() const {
  return _internal_minor_indices_size();
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_minor_indices() {
  _impl_.minor_indices_.Clear();
}
inline uint32_t MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_minor_indices(int index) const {
  return _impl_.minor_indices_.Get(index);
}
inline uint32_t MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return _internal_minor_indices(index);
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_minor_indices(int index, uint32_t value) {
  _impl_.minor_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_add_minor_indices(uint32_t value) {
  _impl_.minor_indices_.Add(value);
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::add_minor_indices(uint32_t value) {
  _internal_add_minor_indices(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_minor_indices() const {
  return _impl_.minor_indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return _internal_minor_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::_internal_mutable_minor_indices() {
  return &_impl_.minor_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::mutable_minor_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return _internal_mutable_minor_indices();
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitRequest

// required uint64 num = 1;
inline bool MoneroKeyImageExportInitRequest::_internal_has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroKeyImageExportInitRequest::has_num() const {
  return _internal_has_num();
}
inline void MoneroKeyImageExportInitRequest::clear_num() {
  _impl_.num_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t MoneroKeyImageExportInitRequest::_internal_num() const {
  return _impl_.num_;
}
inline uint64_t MoneroKeyImageExportInitRequest::num() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
  return _internal_num();
}
inline void MoneroKeyImageExportInitRequest::_internal_set_num(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_ = value;
}
inline void MoneroKeyImageExportInitRequest::set_num(uint64_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
}

// required bytes hash = 2;
inline bool MoneroKeyImageExportInitRequest::_internal_has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroKeyImageExportInitRequest::has_hash() const {
  return _internal_has_hash();
}
inline void MoneroKeyImageExportInitRequest::clear_hash() {
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroKeyImageExportInitRequest::hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroKeyImageExportInitRequest::set_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
inline std::string* MoneroKeyImageExportInitRequest::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  return _s;
}
inline const std::string& MoneroKeyImageExportInitRequest::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void MoneroKeyImageExportInitRequest::_internal_set_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroKeyImageExportInitRequest::_internal_mutable_hash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroKeyImageExportInitRequest::release_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroKeyImageExportInitRequest::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}

// repeated uint32 address_n = 3;
inline int MoneroKeyImageExportInitRequest::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int MoneroKeyImageExportInitRequest::address_n_size() const {
  return _internal_address_n_size();
}
inline void MoneroKeyImageExportInitRequest::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t MoneroKeyImageExportInitRequest::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t MoneroKeyImageExportInitRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return _internal_address_n(index);
}
inline void MoneroKeyImageExportInitRequest::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
}
inline void MoneroKeyImageExportInitRequest::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void MoneroKeyImageExportInitRequest::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroKeyImageExportInitRequest::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroKeyImageExportInitRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroKeyImageExportInitRequest::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroKeyImageExportInitRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return _internal_mutable_address_n();
}

// optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 4 [default = MAINNET];
inline bool MoneroKeyImageExportInitRequest::_internal_has_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroKeyImageExportInitRequest::has_network_type() const {
  return _internal_has_network_type();
}
inline void MoneroKeyImageExportInitRequest::clear_network_type() {
  _impl_.network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroKeyImageExportInitRequest::_internal_network_type() const {
  return static_cast< ::hw::trezor::messages::monero::MoneroNetworkType >(_impl_.network_type_);
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroKeyImageExportInitRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
  return _internal_network_type();
}
inline void MoneroKeyImageExportInitRequest::_internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  assert(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.network_type_ = value;
}
inline void MoneroKeyImageExportInitRequest::set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
}

// repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
inline int MoneroKeyImageExportInitRequest::_internal_subs_size() const {
  return _impl_.subs_.size();
}
inline int MoneroKeyImageExportInitRequest::subs_size() const {
  return _internal_subs_size();
}
inline void MoneroKeyImageExportInitRequest::clear_subs() {
  _impl_.subs_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::mutable_subs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return _impl_.subs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >*
MoneroKeyImageExportInitRequest::mutable_subs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return &_impl_.subs_;
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& MoneroKeyImageExportInitRequest::_internal_subs(int index) const {
  return _impl_.subs_.Get(index);
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& MoneroKeyImageExportInitRequest::subs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return _internal_subs(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::_internal_add_subs() {
  return _impl_.subs_.Add();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::add_subs() {
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* _add = _internal_add_subs();
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >&
MoneroKeyImageExportInitRequest::subs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return _impl_.subs_;
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitAck

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepRequest_MoneroTransferDetails

// required bytes out_key = 1;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_has_out_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_out_key() const {
  return _internal_has_out_key();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_out_key() {
  _impl_.out_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::out_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  return _internal_out_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.out_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_out_key() {
  std::string* _s = _internal_mutable_out_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  return _s;
}
inline const std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_out_key() const {
  return _impl_.out_key_.Get();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_set_out_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.out_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_mutable_out_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.out_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::release_out_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  if (!_internal_has_out_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.out_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.out_key_.IsDefault()) {
    _impl_.out_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_allocated_out_key(std::string* out_key) {
  if (out_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.out_key_.SetAllocated(out_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.out_key_.IsDefault()) {
    _impl_.out_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}

// required bytes tx_pub_key = 2;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_has_tx_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_tx_pub_key() const {
  return _internal_has_tx_pub_key();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_tx_pub_key() {
  _impl_.tx_pub_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::tx_pub_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  return _internal_tx_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tx_pub_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_tx_pub_key() {
  std::string* _s = _internal_mutable_tx_pub_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  return _s;
}
inline const std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_tx_pub_key() const {
  return _impl_.tx_pub_key_.Get();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_set_tx_pub_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tx_pub_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_mutable_tx_pub_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tx_pub_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::release_tx_pub_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  if (!_internal_has_tx_pub_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tx_pub_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_pub_key_.IsDefault()) {
    _impl_.tx_pub_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_allocated_tx_pub_key(std::string* tx_pub_key) {
  if (tx_pub_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tx_pub_key_.SetAllocated(tx_pub_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_pub_key_.IsDefault()) {
    _impl_.tx_pub_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}

// repeated bytes additional_tx_pub_keys = 3;
inline int MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_additional_tx_pub_keys_size() const {
  return _impl_.additional_tx_pub_keys_.size();
}
inline int MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys_size() const {
  return _internal_additional_tx_pub_keys_size();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_additional_tx_pub_keys() {
  _impl_.additional_tx_pub_keys_.Clear();
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys() {
  std::string* _s = _internal_add_additional_tx_pub_keys();
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return _s;
}
inline const std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_additional_tx_pub_keys(int index) const {
  return _impl_.additional_tx_pub_keys_.Get(index);
}
inline const std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return _internal_additional_tx_pub_keys(index);
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_additional_tx_pub_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return _impl_.additional_tx_pub_keys_.Mutable(index);
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const std::string& value) {
  _impl_.additional_tx_pub_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, std::string&& value) {
  _impl_.additional_tx_pub_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.additional_tx_pub_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const void* value, size_t size) {
  _impl_.additional_tx_pub_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_add_additional_tx_pub_keys() {
  return _impl_.additional_tx_pub_keys_.Add();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const std::string& value) {
  _impl_.additional_tx_pub_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(std::string&& value) {
  _impl_.additional_tx_pub_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.additional_tx_pub_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const void* value, size_t size) {
  _impl_.additional_tx_pub_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return _impl_.additional_tx_pub_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_additional_tx_pub_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return &_impl_.additional_tx_pub_keys_;
}

// required uint64 internal_output_index = 4;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_has_internal_output_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_internal_output_index() const {
  return _internal_has_internal_output_index();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_internal_output_index() {
  _impl_.internal_output_index_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_internal_output_index() const {
  return _impl_.internal_output_index_;
}
inline uint64_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::internal_output_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
  return _internal_internal_output_index();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_set_internal_output_index(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.internal_output_index_ = value;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_internal_output_index(uint64_t value) {
  _internal_set_internal_output_index(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
}

// optional uint32 sub_addr_major = 5;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_has_sub_addr_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_sub_addr_major() const {
  return _internal_has_sub_addr_major();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_sub_addr_major() {
  _impl_.sub_addr_major_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_sub_addr_major() const {
  return _impl_.sub_addr_major_;
}
inline uint32_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::sub_addr_major() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.sub_addr_major)
  return _internal_sub_addr_major();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_set_sub_addr_major(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sub_addr_major_ = value;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_sub_addr_major(uint32_t value) {
  _internal_set_sub_addr_major(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.sub_addr_major)
}

// optional uint32 sub_addr_minor = 6;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_has_sub_addr_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_sub_addr_minor() const {
  return _internal_has_sub_addr_minor();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_sub_addr_minor() {
  _impl_.sub_addr_minor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_sub_addr_minor() const {
  return _impl_.sub_addr_minor_;
}
inline uint32_t MoneroKeyImageSyncStepRequest_MoneroTransferDetails::sub_addr_minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.sub_addr_minor)
  return _internal_sub_addr_minor();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::_internal_set_sub_addr_minor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sub_addr_minor_ = value;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_sub_addr_minor(uint32_t value) {
  _internal_set_sub_addr_minor(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.sub_addr_minor)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepRequest

// repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
inline int MoneroKeyImageSyncStepRequest::_internal_tdis_size() const {
  return _impl_.tdis_.size();
}
inline int MoneroKeyImageSyncStepRequest::tdis_size() const {
  return _internal_tdis_size();
}
inline void MoneroKeyImageSyncStepRequest::clear_tdis() {
  _impl_.tdis_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::mutable_tdis(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return _impl_.tdis_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >*
MoneroKeyImageSyncStepRequest::mutable_tdis() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return &_impl_.tdis_;
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& MoneroKeyImageSyncStepRequest::_internal_tdis(int index) const {
  return _impl_.tdis_.Get(index);
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& MoneroKeyImageSyncStepRequest::tdis(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return _internal_tdis(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::_internal_add_tdis() {
  return _impl_.tdis_.Add();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::add_tdis() {
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* _add = _internal_add_tdis();
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >&
MoneroKeyImageSyncStepRequest::tdis() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return _impl_.tdis_;
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepAck_MoneroExportedKeyImage

// optional bytes iv = 1;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_has_iv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_iv() const {
  return _internal_has_iv();
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_iv() {
  _impl_.iv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::iv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
inline std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  return _s;
}
inline const std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_set_iv(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_mutable_iv() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_iv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.iv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}

// optional bytes blob = 3;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_has_blob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_blob() const {
  return _internal_has_blob();
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_blob() {
  _impl_.blob_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::blob() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  return _internal_blob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.blob_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
inline std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_blob() {
  std::string* _s = _internal_mutable_blob();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  return _s;
}
inline const std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_blob() const {
  return _impl_.blob_.Get();
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_set_blob(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.blob_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::_internal_mutable_blob() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.blob_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_blob() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  if (!_internal_has_blob()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.blob_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blob_.IsDefault()) {
    _impl_.blob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.blob_.SetAllocated(blob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blob_.IsDefault()) {
    _impl_.blob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepAck

// repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
inline int MoneroKeyImageSyncStepAck::_internal_kis_size() const {
  return _impl_.kis_.size();
}
inline int MoneroKeyImageSyncStepAck::kis_size() const {
  return _internal_kis_size();
}
inline void MoneroKeyImageSyncStepAck::clear_kis() {
  _impl_.kis_.Clear();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::mutable_kis(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return _impl_.kis_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >*
MoneroKeyImageSyncStepAck::mutable_kis() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return &_impl_.kis_;
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& MoneroKeyImageSyncStepAck::_internal_kis(int index) const {
  return _impl_.kis_.Get(index);
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& MoneroKeyImageSyncStepAck::kis(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return _internal_kis(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::_internal_add_kis() {
  return _impl_.kis_.Add();
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::add_kis() {
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* _add = _internal_add_kis();
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >&
MoneroKeyImageSyncStepAck::kis() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return _impl_.kis_;
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncFinalRequest

// -------------------------------------------------------------------

// MoneroKeyImageSyncFinalAck

// optional bytes enc_key = 1;
inline bool MoneroKeyImageSyncFinalAck::_internal_has_enc_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroKeyImageSyncFinalAck::has_enc_key() const {
  return _internal_has_enc_key();
}
inline void MoneroKeyImageSyncFinalAck::clear_enc_key() {
  _impl_.enc_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroKeyImageSyncFinalAck::enc_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  return _internal_enc_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroKeyImageSyncFinalAck::set_enc_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.enc_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
inline std::string* MoneroKeyImageSyncFinalAck::mutable_enc_key() {
  std::string* _s = _internal_mutable_enc_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  return _s;
}
inline const std::string& MoneroKeyImageSyncFinalAck::_internal_enc_key() const {
  return _impl_.enc_key_.Get();
}
inline void MoneroKeyImageSyncFinalAck::_internal_set_enc_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enc_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncFinalAck::_internal_mutable_enc_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.enc_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroKeyImageSyncFinalAck::release_enc_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  if (!_internal_has_enc_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.enc_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enc_key_.IsDefault()) {
    _impl_.enc_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroKeyImageSyncFinalAck::set_allocated_enc_key(std::string* enc_key) {
  if (enc_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.enc_key_.SetAllocated(enc_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enc_key_.IsDefault()) {
    _impl_.enc_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}

// -------------------------------------------------------------------

// MoneroGetTxKeyRequest

// repeated uint32 address_n = 1;
inline int MoneroGetTxKeyRequest::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int MoneroGetTxKeyRequest::address_n_size() const {
  return _internal_address_n_size();
}
inline void MoneroGetTxKeyRequest::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t MoneroGetTxKeyRequest::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t MoneroGetTxKeyRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
  return _internal_address_n(index);
}
inline void MoneroGetTxKeyRequest::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
}
inline void MoneroGetTxKeyRequest::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void MoneroGetTxKeyRequest::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroGetTxKeyRequest::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroGetTxKeyRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroGetTxKeyRequest::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroGetTxKeyRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetTxKeyRequest.address_n)
  return _internal_mutable_address_n();
}

// optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
inline bool MoneroGetTxKeyRequest::_internal_has_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_network_type() const {
  return _internal_has_network_type();
}
inline void MoneroGetTxKeyRequest::clear_network_type() {
  _impl_.network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroGetTxKeyRequest::_internal_network_type() const {
  return static_cast< ::hw::trezor::messages::monero::MoneroNetworkType >(_impl_.network_type_);
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroGetTxKeyRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.network_type)
  return _internal_network_type();
}
inline void MoneroGetTxKeyRequest::_internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  assert(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.network_type_ = value;
}
inline void MoneroGetTxKeyRequest::set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.network_type)
}

// required bytes salt1 = 3;
inline bool MoneroGetTxKeyRequest::_internal_has_salt1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_salt1() const {
  return _internal_has_salt1();
}
inline void MoneroGetTxKeyRequest::clear_salt1() {
  _impl_.salt1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroGetTxKeyRequest::salt1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
  return _internal_salt1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyRequest::set_salt1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.salt1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}
inline std::string* MoneroGetTxKeyRequest::mutable_salt1() {
  std::string* _s = _internal_mutable_salt1();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
  return _s;
}
inline const std::string& MoneroGetTxKeyRequest::_internal_salt1() const {
  return _impl_.salt1_.Get();
}
inline void MoneroGetTxKeyRequest::_internal_set_salt1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.salt1_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::_internal_mutable_salt1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.salt1_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::release_salt1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
  if (!_internal_has_salt1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.salt1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt1_.IsDefault()) {
    _impl_.salt1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyRequest::set_allocated_salt1(std::string* salt1) {
  if (salt1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.salt1_.SetAllocated(salt1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt1_.IsDefault()) {
    _impl_.salt1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt1)
}

// required bytes salt2 = 4;
inline bool MoneroGetTxKeyRequest::_internal_has_salt2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_salt2() const {
  return _internal_has_salt2();
}
inline void MoneroGetTxKeyRequest::clear_salt2() {
  _impl_.salt2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroGetTxKeyRequest::salt2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
  return _internal_salt2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyRequest::set_salt2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.salt2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}
inline std::string* MoneroGetTxKeyRequest::mutable_salt2() {
  std::string* _s = _internal_mutable_salt2();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
  return _s;
}
inline const std::string& MoneroGetTxKeyRequest::_internal_salt2() const {
  return _impl_.salt2_.Get();
}
inline void MoneroGetTxKeyRequest::_internal_set_salt2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.salt2_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::_internal_mutable_salt2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.salt2_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::release_salt2() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
  if (!_internal_has_salt2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.salt2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt2_.IsDefault()) {
    _impl_.salt2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyRequest::set_allocated_salt2(std::string* salt2) {
  if (salt2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.salt2_.SetAllocated(salt2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt2_.IsDefault()) {
    _impl_.salt2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.salt2)
}

// required bytes tx_enc_keys = 5;
inline bool MoneroGetTxKeyRequest::_internal_has_tx_enc_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_tx_enc_keys() const {
  return _internal_has_tx_enc_keys();
}
inline void MoneroGetTxKeyRequest::clear_tx_enc_keys() {
  _impl_.tx_enc_keys_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroGetTxKeyRequest::tx_enc_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
  return _internal_tx_enc_keys();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyRequest::set_tx_enc_keys(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.tx_enc_keys_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}
inline std::string* MoneroGetTxKeyRequest::mutable_tx_enc_keys() {
  std::string* _s = _internal_mutable_tx_enc_keys();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
  return _s;
}
inline const std::string& MoneroGetTxKeyRequest::_internal_tx_enc_keys() const {
  return _impl_.tx_enc_keys_.Get();
}
inline void MoneroGetTxKeyRequest::_internal_set_tx_enc_keys(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tx_enc_keys_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::_internal_mutable_tx_enc_keys() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.tx_enc_keys_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::release_tx_enc_keys() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
  if (!_internal_has_tx_enc_keys()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.tx_enc_keys_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_enc_keys_.IsDefault()) {
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyRequest::set_allocated_tx_enc_keys(std::string* tx_enc_keys) {
  if (tx_enc_keys != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tx_enc_keys_.SetAllocated(tx_enc_keys, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_enc_keys_.IsDefault()) {
    _impl_.tx_enc_keys_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_enc_keys)
}

// required bytes tx_prefix_hash = 6;
inline bool MoneroGetTxKeyRequest::_internal_has_tx_prefix_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_tx_prefix_hash() const {
  return _internal_has_tx_prefix_hash();
}
inline void MoneroGetTxKeyRequest::clear_tx_prefix_hash() {
  _impl_.tx_prefix_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MoneroGetTxKeyRequest::tx_prefix_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
  return _internal_tx_prefix_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyRequest::set_tx_prefix_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.tx_prefix_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}
inline std::string* MoneroGetTxKeyRequest::mutable_tx_prefix_hash() {
  std::string* _s = _internal_mutable_tx_prefix_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
  return _s;
}
inline const std::string& MoneroGetTxKeyRequest::_internal_tx_prefix_hash() const {
  return _impl_.tx_prefix_hash_.Get();
}
inline void MoneroGetTxKeyRequest::_internal_set_tx_prefix_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tx_prefix_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::_internal_mutable_tx_prefix_hash() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tx_prefix_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::release_tx_prefix_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
  if (!_internal_has_tx_prefix_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.tx_prefix_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_prefix_hash_.IsDefault()) {
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyRequest::set_allocated_tx_prefix_hash(std::string* tx_prefix_hash) {
  if (tx_prefix_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tx_prefix_hash_.SetAllocated(tx_prefix_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_prefix_hash_.IsDefault()) {
    _impl_.tx_prefix_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.tx_prefix_hash)
}

// optional uint32 reason = 7;
inline bool MoneroGetTxKeyRequest::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_reason() const {
  return _internal_has_reason();
}
inline void MoneroGetTxKeyRequest::clear_reason() {
  _impl_.reason_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t MoneroGetTxKeyRequest::_internal_reason() const {
  return _impl_.reason_;
}
inline uint32_t MoneroGetTxKeyRequest::reason() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.reason)
  return _internal_reason();
}
inline void MoneroGetTxKeyRequest::_internal_set_reason(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.reason_ = value;
}
inline void MoneroGetTxKeyRequest::set_reason(uint32_t value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.reason)
}

// optional bytes view_public_key = 8;
inline bool MoneroGetTxKeyRequest::_internal_has_view_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroGetTxKeyRequest::has_view_public_key() const {
  return _internal_has_view_public_key();
}
inline void MoneroGetTxKeyRequest::clear_view_public_key() {
  _impl_.view_public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MoneroGetTxKeyRequest::view_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
  return _internal_view_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyRequest::set_view_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.view_public_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}
inline std::string* MoneroGetTxKeyRequest::mutable_view_public_key() {
  std::string* _s = _internal_mutable_view_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
  return _s;
}
inline const std::string& MoneroGetTxKeyRequest::_internal_view_public_key() const {
  return _impl_.view_public_key_.Get();
}
inline void MoneroGetTxKeyRequest::_internal_set_view_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.view_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::_internal_mutable_view_public_key() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.view_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyRequest::release_view_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
  if (!_internal_has_view_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.view_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_public_key_.IsDefault()) {
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyRequest::set_allocated_view_public_key(std::string* view_public_key) {
  if (view_public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.view_public_key_.SetAllocated(view_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_public_key_.IsDefault()) {
    _impl_.view_public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyRequest.view_public_key)
}

// -------------------------------------------------------------------

// MoneroGetTxKeyAck

// optional bytes salt = 1;
inline bool MoneroGetTxKeyAck::_internal_has_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroGetTxKeyAck::has_salt() const {
  return _internal_has_salt();
}
inline void MoneroGetTxKeyAck::clear_salt() {
  _impl_.salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroGetTxKeyAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyAck::set_salt(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}
inline std::string* MoneroGetTxKeyAck::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
  return _s;
}
inline const std::string& MoneroGetTxKeyAck::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void MoneroGetTxKeyAck::_internal_set_salt(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyAck::_internal_mutable_salt() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyAck::release_salt() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
  if (!_internal_has_salt()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyAck::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyAck.salt)
}

// optional bytes tx_keys = 2;
inline bool MoneroGetTxKeyAck::_internal_has_tx_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroGetTxKeyAck::has_tx_keys() const {
  return _internal_has_tx_keys();
}
inline void MoneroGetTxKeyAck::clear_tx_keys() {
  _impl_.tx_keys_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroGetTxKeyAck::tx_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
  return _internal_tx_keys();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyAck::set_tx_keys(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.tx_keys_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}
inline std::string* MoneroGetTxKeyAck::mutable_tx_keys() {
  std::string* _s = _internal_mutable_tx_keys();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
  return _s;
}
inline const std::string& MoneroGetTxKeyAck::_internal_tx_keys() const {
  return _impl_.tx_keys_.Get();
}
inline void MoneroGetTxKeyAck::_internal_set_tx_keys(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tx_keys_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyAck::_internal_mutable_tx_keys() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.tx_keys_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyAck::release_tx_keys() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
  if (!_internal_has_tx_keys()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.tx_keys_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_keys_.IsDefault()) {
    _impl_.tx_keys_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyAck::set_allocated_tx_keys(std::string* tx_keys) {
  if (tx_keys != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tx_keys_.SetAllocated(tx_keys, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_keys_.IsDefault()) {
    _impl_.tx_keys_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_keys)
}

// optional bytes tx_derivations = 3;
inline bool MoneroGetTxKeyAck::_internal_has_tx_derivations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroGetTxKeyAck::has_tx_derivations() const {
  return _internal_has_tx_derivations();
}
inline void MoneroGetTxKeyAck::clear_tx_derivations() {
  _impl_.tx_derivations_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MoneroGetTxKeyAck::tx_derivations() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
  return _internal_tx_derivations();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroGetTxKeyAck::set_tx_derivations(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.tx_derivations_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}
inline std::string* MoneroGetTxKeyAck::mutable_tx_derivations() {
  std::string* _s = _internal_mutable_tx_derivations();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
  return _s;
}
inline const std::string& MoneroGetTxKeyAck::_internal_tx_derivations() const {
  return _impl_.tx_derivations_.Get();
}
inline void MoneroGetTxKeyAck::_internal_set_tx_derivations(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tx_derivations_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyAck::_internal_mutable_tx_derivations() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.tx_derivations_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroGetTxKeyAck::release_tx_derivations() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
  if (!_internal_has_tx_derivations()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.tx_derivations_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_derivations_.IsDefault()) {
    _impl_.tx_derivations_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroGetTxKeyAck::set_allocated_tx_derivations(std::string* tx_derivations) {
  if (tx_derivations != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tx_derivations_.SetAllocated(tx_derivations, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_derivations_.IsDefault()) {
    _impl_.tx_derivations_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroGetTxKeyAck.tx_derivations)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshStartRequest

// repeated uint32 address_n = 1;
inline int MoneroLiveRefreshStartRequest::_internal_address_n_size() const {
  return _impl_.address_n_.size();
}
inline int MoneroLiveRefreshStartRequest::address_n_size() const {
  return _internal_address_n_size();
}
inline void MoneroLiveRefreshStartRequest::clear_address_n() {
  _impl_.address_n_.Clear();
}
inline uint32_t MoneroLiveRefreshStartRequest::_internal_address_n(int index) const {
  return _impl_.address_n_.Get(index);
}
inline uint32_t MoneroLiveRefreshStartRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
  return _internal_address_n(index);
}
inline void MoneroLiveRefreshStartRequest::set_address_n(int index, uint32_t value) {
  _impl_.address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
}
inline void MoneroLiveRefreshStartRequest::_internal_add_address_n(uint32_t value) {
  _impl_.address_n_.Add(value);
}
inline void MoneroLiveRefreshStartRequest::add_address_n(uint32_t value) {
  _internal_add_address_n(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroLiveRefreshStartRequest::_internal_address_n() const {
  return _impl_.address_n_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoneroLiveRefreshStartRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
  return _internal_address_n();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroLiveRefreshStartRequest::_internal_mutable_address_n() {
  return &_impl_.address_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoneroLiveRefreshStartRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.address_n)
  return _internal_mutable_address_n();
}

// optional .hw.trezor.messages.monero.MoneroNetworkType network_type = 2 [default = MAINNET];
inline bool MoneroLiveRefreshStartRequest::_internal_has_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStartRequest::has_network_type() const {
  return _internal_has_network_type();
}
inline void MoneroLiveRefreshStartRequest::clear_network_type() {
  _impl_.network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroLiveRefreshStartRequest::_internal_network_type() const {
  return static_cast< ::hw::trezor::messages::monero::MoneroNetworkType >(_impl_.network_type_);
}
inline ::hw::trezor::messages::monero::MoneroNetworkType MoneroLiveRefreshStartRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.network_type)
  return _internal_network_type();
}
inline void MoneroLiveRefreshStartRequest::_internal_set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  assert(::hw::trezor::messages::monero::MoneroNetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.network_type_ = value;
}
inline void MoneroLiveRefreshStartRequest::set_network_type(::hw::trezor::messages::monero::MoneroNetworkType value) {
  _internal_set_network_type(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStartRequest.network_type)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshStartAck

// -------------------------------------------------------------------

// MoneroLiveRefreshStepRequest

// required bytes out_key = 1;
inline bool MoneroLiveRefreshStepRequest::_internal_has_out_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepRequest::has_out_key() const {
  return _internal_has_out_key();
}
inline void MoneroLiveRefreshStepRequest::clear_out_key() {
  _impl_.out_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroLiveRefreshStepRequest::out_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
  return _internal_out_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroLiveRefreshStepRequest::set_out_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.out_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}
inline std::string* MoneroLiveRefreshStepRequest::mutable_out_key() {
  std::string* _s = _internal_mutable_out_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
  return _s;
}
inline const std::string& MoneroLiveRefreshStepRequest::_internal_out_key() const {
  return _impl_.out_key_.Get();
}
inline void MoneroLiveRefreshStepRequest::_internal_set_out_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.out_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepRequest::_internal_mutable_out_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.out_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepRequest::release_out_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
  if (!_internal_has_out_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.out_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.out_key_.IsDefault()) {
    _impl_.out_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroLiveRefreshStepRequest::set_allocated_out_key(std::string* out_key) {
  if (out_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.out_key_.SetAllocated(out_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.out_key_.IsDefault()) {
    _impl_.out_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.out_key)
}

// required bytes recv_deriv = 2;
inline bool MoneroLiveRefreshStepRequest::_internal_has_recv_deriv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepRequest::has_recv_deriv() const {
  return _internal_has_recv_deriv();
}
inline void MoneroLiveRefreshStepRequest::clear_recv_deriv() {
  _impl_.recv_deriv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroLiveRefreshStepRequest::recv_deriv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
  return _internal_recv_deriv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroLiveRefreshStepRequest::set_recv_deriv(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.recv_deriv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}
inline std::string* MoneroLiveRefreshStepRequest::mutable_recv_deriv() {
  std::string* _s = _internal_mutable_recv_deriv();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
  return _s;
}
inline const std::string& MoneroLiveRefreshStepRequest::_internal_recv_deriv() const {
  return _impl_.recv_deriv_.Get();
}
inline void MoneroLiveRefreshStepRequest::_internal_set_recv_deriv(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.recv_deriv_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepRequest::_internal_mutable_recv_deriv() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.recv_deriv_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepRequest::release_recv_deriv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
  if (!_internal_has_recv_deriv()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.recv_deriv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recv_deriv_.IsDefault()) {
    _impl_.recv_deriv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroLiveRefreshStepRequest::set_allocated_recv_deriv(std::string* recv_deriv) {
  if (recv_deriv != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.recv_deriv_.SetAllocated(recv_deriv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recv_deriv_.IsDefault()) {
    _impl_.recv_deriv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.recv_deriv)
}

// required uint64 real_out_idx = 3;
inline bool MoneroLiveRefreshStepRequest::_internal_has_real_out_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepRequest::has_real_out_idx() const {
  return _internal_has_real_out_idx();
}
inline void MoneroLiveRefreshStepRequest::clear_real_out_idx() {
  _impl_.real_out_idx_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t MoneroLiveRefreshStepRequest::_internal_real_out_idx() const {
  return _impl_.real_out_idx_;
}
inline uint64_t MoneroLiveRefreshStepRequest::real_out_idx() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.real_out_idx)
  return _internal_real_out_idx();
}
inline void MoneroLiveRefreshStepRequest::_internal_set_real_out_idx(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.real_out_idx_ = value;
}
inline void MoneroLiveRefreshStepRequest::set_real_out_idx(uint64_t value) {
  _internal_set_real_out_idx(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.real_out_idx)
}

// required uint32 sub_addr_major = 4;
inline bool MoneroLiveRefreshStepRequest::_internal_has_sub_addr_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepRequest::has_sub_addr_major() const {
  return _internal_has_sub_addr_major();
}
inline void MoneroLiveRefreshStepRequest::clear_sub_addr_major() {
  _impl_.sub_addr_major_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoneroLiveRefreshStepRequest::_internal_sub_addr_major() const {
  return _impl_.sub_addr_major_;
}
inline uint32_t MoneroLiveRefreshStepRequest::sub_addr_major() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_major)
  return _internal_sub_addr_major();
}
inline void MoneroLiveRefreshStepRequest::_internal_set_sub_addr_major(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sub_addr_major_ = value;
}
inline void MoneroLiveRefreshStepRequest::set_sub_addr_major(uint32_t value) {
  _internal_set_sub_addr_major(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_major)
}

// required uint32 sub_addr_minor = 5;
inline bool MoneroLiveRefreshStepRequest::_internal_has_sub_addr_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepRequest::has_sub_addr_minor() const {
  return _internal_has_sub_addr_minor();
}
inline void MoneroLiveRefreshStepRequest::clear_sub_addr_minor() {
  _impl_.sub_addr_minor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoneroLiveRefreshStepRequest::_internal_sub_addr_minor() const {
  return _impl_.sub_addr_minor_;
}
inline uint32_t MoneroLiveRefreshStepRequest::sub_addr_minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_minor)
  return _internal_sub_addr_minor();
}
inline void MoneroLiveRefreshStepRequest::_internal_set_sub_addr_minor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sub_addr_minor_ = value;
}
inline void MoneroLiveRefreshStepRequest::set_sub_addr_minor(uint32_t value) {
  _internal_set_sub_addr_minor(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepRequest.sub_addr_minor)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshStepAck

// optional bytes salt = 1;
inline bool MoneroLiveRefreshStepAck::_internal_has_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepAck::has_salt() const {
  return _internal_has_salt();
}
inline void MoneroLiveRefreshStepAck::clear_salt() {
  _impl_.salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MoneroLiveRefreshStepAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
  return _internal_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroLiveRefreshStepAck::set_salt(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}
inline std::string* MoneroLiveRefreshStepAck::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
  return _s;
}
inline const std::string& MoneroLiveRefreshStepAck::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void MoneroLiveRefreshStepAck::_internal_set_salt(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepAck::_internal_mutable_salt() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.salt_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepAck::release_salt() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
  if (!_internal_has_salt()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroLiveRefreshStepAck::set_allocated_salt(std::string* salt) {
  if (salt != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.salt_.SetAllocated(salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.salt_.IsDefault()) {
    _impl_.salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.salt)
}

// optional bytes key_image = 2;
inline bool MoneroLiveRefreshStepAck::_internal_has_key_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoneroLiveRefreshStepAck::has_key_image() const {
  return _internal_has_key_image();
}
inline void MoneroLiveRefreshStepAck::clear_key_image() {
  _impl_.key_image_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MoneroLiveRefreshStepAck::key_image() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
  return _internal_key_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoneroLiveRefreshStepAck::set_key_image(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.key_image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}
inline std::string* MoneroLiveRefreshStepAck::mutable_key_image() {
  std::string* _s = _internal_mutable_key_image();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
  return _s;
}
inline const std::string& MoneroLiveRefreshStepAck::_internal_key_image() const {
  return _impl_.key_image_.Get();
}
inline void MoneroLiveRefreshStepAck::_internal_set_key_image(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_image_.Set(value, GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepAck::_internal_mutable_key_image() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.key_image_.Mutable(GetArenaForAllocation());
}
inline std::string* MoneroLiveRefreshStepAck::release_key_image() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
  if (!_internal_has_key_image()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.key_image_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_image_.IsDefault()) {
    _impl_.key_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MoneroLiveRefreshStepAck::set_allocated_key_image(std::string* key_image) {
  if (key_image != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_image_.SetAllocated(key_image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_image_.IsDefault()) {
    _impl_.key_image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroLiveRefreshStepAck.key_image)
}

// -------------------------------------------------------------------

// MoneroLiveRefreshFinalRequest

// -------------------------------------------------------------------

// MoneroLiveRefreshFinalAck

// -------------------------------------------------------------------

// DebugMoneroDiagRequest

// optional uint64 ins = 1;
inline bool DebugMoneroDiagRequest::_internal_has_ins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugMoneroDiagRequest::has_ins() const {
  return _internal_has_ins();
}
inline void DebugMoneroDiagRequest::clear_ins() {
  _impl_.ins_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DebugMoneroDiagRequest::_internal_ins() const {
  return _impl_.ins_;
}
inline uint64_t DebugMoneroDiagRequest::ins() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
  return _internal_ins();
}
inline void DebugMoneroDiagRequest::_internal_set_ins(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ins_ = value;
}
inline void DebugMoneroDiagRequest::set_ins(uint64_t value) {
  _internal_set_ins(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
}

// optional uint64 p1 = 2;
inline bool DebugMoneroDiagRequest::_internal_has_p1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DebugMoneroDiagRequest::has_p1() const {
  return _internal_has_p1();
}
inline void DebugMoneroDiagRequest::clear_p1() {
  _impl_.p1_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t DebugMoneroDiagRequest::_internal_p1() const {
  return _impl_.p1_;
}
inline uint64_t DebugMoneroDiagRequest::p1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
  return _internal_p1();
}
inline void DebugMoneroDiagRequest::_internal_set_p1(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.p1_ = value;
}
inline void DebugMoneroDiagRequest::set_p1(uint64_t value) {
  _internal_set_p1(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
}

// optional uint64 p2 = 3;
inline bool DebugMoneroDiagRequest::_internal_has_p2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DebugMoneroDiagRequest::has_p2() const {
  return _internal_has_p2();
}
inline void DebugMoneroDiagRequest::clear_p2() {
  _impl_.p2_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t DebugMoneroDiagRequest::_internal_p2() const {
  return _impl_.p2_;
}
inline uint64_t DebugMoneroDiagRequest::p2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
  return _internal_p2();
}
inline void DebugMoneroDiagRequest::_internal_set_p2(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.p2_ = value;
}
inline void DebugMoneroDiagRequest::set_p2(uint64_t value) {
  _internal_set_p2(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
}

// repeated uint64 pd = 4;
inline int DebugMoneroDiagRequest::_internal_pd_size() const {
  return _impl_.pd_.size();
}
inline int DebugMoneroDiagRequest::pd_size() const {
  return _internal_pd_size();
}
inline void DebugMoneroDiagRequest::clear_pd() {
  _impl_.pd_.Clear();
}
inline uint64_t DebugMoneroDiagRequest::_internal_pd(int index) const {
  return _impl_.pd_.Get(index);
}
inline uint64_t DebugMoneroDiagRequest::pd(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return _internal_pd(index);
}
inline void DebugMoneroDiagRequest::set_pd(int index, uint64_t value) {
  _impl_.pd_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
}
inline void DebugMoneroDiagRequest::_internal_add_pd(uint64_t value) {
  _impl_.pd_.Add(value);
}
inline void DebugMoneroDiagRequest::add_pd(uint64_t value) {
  _internal_add_pd(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
DebugMoneroDiagRequest::_internal_pd() const {
  return _impl_.pd_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
DebugMoneroDiagRequest::pd() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return _internal_pd();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
DebugMoneroDiagRequest::_internal_mutable_pd() {
  return &_impl_.pd_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
DebugMoneroDiagRequest::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return _internal_mutable_pd();
}

// optional bytes data1 = 5;
inline bool DebugMoneroDiagRequest::_internal_has_data1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugMoneroDiagRequest::has_data1() const {
  return _internal_has_data1();
}
inline void DebugMoneroDiagRequest::clear_data1() {
  _impl_.data1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DebugMoneroDiagRequest::data1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  return _internal_data1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugMoneroDiagRequest::set_data1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
inline std::string* DebugMoneroDiagRequest::mutable_data1() {
  std::string* _s = _internal_mutable_data1();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  return _s;
}
inline const std::string& DebugMoneroDiagRequest::_internal_data1() const {
  return _impl_.data1_.Get();
}
inline void DebugMoneroDiagRequest::_internal_set_data1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data1_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagRequest::_internal_mutable_data1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data1_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagRequest::release_data1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  if (!_internal_has_data1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data1_.IsDefault()) {
    _impl_.data1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DebugMoneroDiagRequest::set_allocated_data1(std::string* data1) {
  if (data1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data1_.SetAllocated(data1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data1_.IsDefault()) {
    _impl_.data1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}

// optional bytes data2 = 6;
inline bool DebugMoneroDiagRequest::_internal_has_data2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugMoneroDiagRequest::has_data2() const {
  return _internal_has_data2();
}
inline void DebugMoneroDiagRequest::clear_data2() {
  _impl_.data2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DebugMoneroDiagRequest::data2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  return _internal_data2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugMoneroDiagRequest::set_data2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.data2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
inline std::string* DebugMoneroDiagRequest::mutable_data2() {
  std::string* _s = _internal_mutable_data2();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  return _s;
}
inline const std::string& DebugMoneroDiagRequest::_internal_data2() const {
  return _impl_.data2_.Get();
}
inline void DebugMoneroDiagRequest::_internal_set_data2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data2_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagRequest::_internal_mutable_data2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data2_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagRequest::release_data2() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  if (!_internal_has_data2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.data2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data2_.IsDefault()) {
    _impl_.data2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DebugMoneroDiagRequest::set_allocated_data2(std::string* data2) {
  if (data2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data2_.SetAllocated(data2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data2_.IsDefault()) {
    _impl_.data2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}

// -------------------------------------------------------------------

// DebugMoneroDiagAck

// optional uint64 ins = 1;
inline bool DebugMoneroDiagAck::_internal_has_ins() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugMoneroDiagAck::has_ins() const {
  return _internal_has_ins();
}
inline void DebugMoneroDiagAck::clear_ins() {
  _impl_.ins_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t DebugMoneroDiagAck::_internal_ins() const {
  return _impl_.ins_;
}
inline uint64_t DebugMoneroDiagAck::ins() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
  return _internal_ins();
}
inline void DebugMoneroDiagAck::_internal_set_ins(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ins_ = value;
}
inline void DebugMoneroDiagAck::set_ins(uint64_t value) {
  _internal_set_ins(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
}

// optional uint64 p1 = 2;
inline bool DebugMoneroDiagAck::_internal_has_p1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DebugMoneroDiagAck::has_p1() const {
  return _internal_has_p1();
}
inline void DebugMoneroDiagAck::clear_p1() {
  _impl_.p1_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t DebugMoneroDiagAck::_internal_p1() const {
  return _impl_.p1_;
}
inline uint64_t DebugMoneroDiagAck::p1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
  return _internal_p1();
}
inline void DebugMoneroDiagAck::_internal_set_p1(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.p1_ = value;
}
inline void DebugMoneroDiagAck::set_p1(uint64_t value) {
  _internal_set_p1(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
}

// optional uint64 p2 = 3;
inline bool DebugMoneroDiagAck::_internal_has_p2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DebugMoneroDiagAck::has_p2() const {
  return _internal_has_p2();
}
inline void DebugMoneroDiagAck::clear_p2() {
  _impl_.p2_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t DebugMoneroDiagAck::_internal_p2() const {
  return _impl_.p2_;
}
inline uint64_t DebugMoneroDiagAck::p2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
  return _internal_p2();
}
inline void DebugMoneroDiagAck::_internal_set_p2(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.p2_ = value;
}
inline void DebugMoneroDiagAck::set_p2(uint64_t value) {
  _internal_set_p2(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
}

// repeated uint64 pd = 4;
inline int DebugMoneroDiagAck::_internal_pd_size() const {
  return _impl_.pd_.size();
}
inline int DebugMoneroDiagAck::pd_size() const {
  return _internal_pd_size();
}
inline void DebugMoneroDiagAck::clear_pd() {
  _impl_.pd_.Clear();
}
inline uint64_t DebugMoneroDiagAck::_internal_pd(int index) const {
  return _impl_.pd_.Get(index);
}
inline uint64_t DebugMoneroDiagAck::pd(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return _internal_pd(index);
}
inline void DebugMoneroDiagAck::set_pd(int index, uint64_t value) {
  _impl_.pd_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
}
inline void DebugMoneroDiagAck::_internal_add_pd(uint64_t value) {
  _impl_.pd_.Add(value);
}
inline void DebugMoneroDiagAck::add_pd(uint64_t value) {
  _internal_add_pd(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
DebugMoneroDiagAck::_internal_pd() const {
  return _impl_.pd_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
DebugMoneroDiagAck::pd() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return _internal_pd();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
DebugMoneroDiagAck::_internal_mutable_pd() {
  return &_impl_.pd_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
DebugMoneroDiagAck::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return _internal_mutable_pd();
}

// optional bytes data1 = 5;
inline bool DebugMoneroDiagAck::_internal_has_data1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugMoneroDiagAck::has_data1() const {
  return _internal_has_data1();
}
inline void DebugMoneroDiagAck::clear_data1() {
  _impl_.data1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DebugMoneroDiagAck::data1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  return _internal_data1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugMoneroDiagAck::set_data1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
inline std::string* DebugMoneroDiagAck::mutable_data1() {
  std::string* _s = _internal_mutable_data1();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  return _s;
}
inline const std::string& DebugMoneroDiagAck::_internal_data1() const {
  return _impl_.data1_.Get();
}
inline void DebugMoneroDiagAck::_internal_set_data1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data1_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagAck::_internal_mutable_data1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data1_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagAck::release_data1() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  if (!_internal_has_data1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data1_.IsDefault()) {
    _impl_.data1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DebugMoneroDiagAck::set_allocated_data1(std::string* data1) {
  if (data1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data1_.SetAllocated(data1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data1_.IsDefault()) {
    _impl_.data1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}

// optional bytes data2 = 6;
inline bool DebugMoneroDiagAck::_internal_has_data2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugMoneroDiagAck::has_data2() const {
  return _internal_has_data2();
}
inline void DebugMoneroDiagAck::clear_data2() {
  _impl_.data2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DebugMoneroDiagAck::data2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  return _internal_data2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugMoneroDiagAck::set_data2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.data2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
inline std::string* DebugMoneroDiagAck::mutable_data2() {
  std::string* _s = _internal_mutable_data2();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  return _s;
}
inline const std::string& DebugMoneroDiagAck::_internal_data2() const {
  return _impl_.data2_.Get();
}
inline void DebugMoneroDiagAck::_internal_set_data2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data2_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagAck::_internal_mutable_data2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data2_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugMoneroDiagAck::release_data2() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  if (!_internal_has_data2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.data2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data2_.IsDefault()) {
    _impl_.data2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DebugMoneroDiagAck::set_allocated_data2(std::string* data2) {
  if (data2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data2_.SetAllocated(data2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data2_.IsDefault()) {
    _impl_.data2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hw::trezor::messages::monero::MoneroNetworkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::monero::MoneroNetworkType>() {
  return ::hw::trezor::messages::monero::MoneroNetworkType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2dmonero_2eproto
