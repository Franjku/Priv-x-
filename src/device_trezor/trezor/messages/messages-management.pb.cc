// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-management.proto

#include "messages-management.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace hw {
namespace trezor {
namespace messages {
namespace management {
PROTOBUF_CONSTEXPR Initialize::Initialize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.session_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._skip_passphrase_)*/false
  , /*decltype(_impl_.derive_cardano_)*/false} {}
struct InitializeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitializeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitializeDefaultTypeInternal() {}
  union {
    Initialize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitializeDefaultTypeInternal _Initialize_default_instance_;
PROTOBUF_CONSTEXPR GetFeatures::GetFeatures(
    ::_pbi::ConstantInitialized) {}
struct GetFeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFeaturesDefaultTypeInternal() {}
  union {
    GetFeatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFeaturesDefaultTypeInternal _GetFeatures_default_instance_;
PROTOBUF_CONSTEXPR Features::Features(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.capabilities_)*/{}
  , /*decltype(_impl_.vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.revision_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bootloader_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fw_vendor_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.major_version_)*/0u
  , /*decltype(_impl_.minor_version_)*/0u
  , /*decltype(_impl_.patch_version_)*/0u
  , /*decltype(_impl_.bootloader_mode_)*/false
  , /*decltype(_impl_.pin_protection_)*/false
  , /*decltype(_impl_.passphrase_protection_)*/false
  , /*decltype(_impl_.initialized_)*/false
  , /*decltype(_impl_.imported_)*/false
  , /*decltype(_impl_.unlocked_)*/false
  , /*decltype(_impl_._passphrase_cached_)*/false
  , /*decltype(_impl_.firmware_present_)*/false
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.fw_major_)*/0u
  , /*decltype(_impl_.fw_minor_)*/0u
  , /*decltype(_impl_.fw_patch_)*/0u
  , /*decltype(_impl_.needs_backup_)*/false
  , /*decltype(_impl_.unfinished_backup_)*/false
  , /*decltype(_impl_.no_backup_)*/false
  , /*decltype(_impl_.recovery_mode_)*/false
  , /*decltype(_impl_.backup_type_)*/0
  , /*decltype(_impl_.sd_card_present_)*/false
  , /*decltype(_impl_.sd_protection_)*/false
  , /*decltype(_impl_.wipe_code_protection_)*/false
  , /*decltype(_impl_.passphrase_always_on_device_)*/false
  , /*decltype(_impl_.safety_checks_)*/0
  , /*decltype(_impl_.auto_lock_delay_ms_)*/0u
  , /*decltype(_impl_.display_rotation_)*/0u
  , /*decltype(_impl_.experimental_features_)*/false
  , /*decltype(_impl_.busy_)*/false
  , /*decltype(_impl_.hide_passphrase_from_host_)*/false
  , /*decltype(_impl_.homescreen_format_)*/1} {}
struct FeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeaturesDefaultTypeInternal() {}
  union {
    Features _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeaturesDefaultTypeInternal _Features_default_instance_;
PROTOBUF_CONSTEXPR LockDevice::LockDevice(
    ::_pbi::ConstantInitialized) {}
struct LockDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LockDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LockDeviceDefaultTypeInternal() {}
  union {
    LockDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LockDeviceDefaultTypeInternal _LockDevice_default_instance_;
PROTOBUF_CONSTEXPR SetBusy::SetBusy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.expiry_ms_)*/0u} {}
struct SetBusyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetBusyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetBusyDefaultTypeInternal() {}
  union {
    SetBusy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetBusyDefaultTypeInternal _SetBusy_default_instance_;
PROTOBUF_CONSTEXPR EndSession::EndSession(
    ::_pbi::ConstantInitialized) {}
struct EndSessionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndSessionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndSessionDefaultTypeInternal() {}
  union {
    EndSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndSessionDefaultTypeInternal _EndSession_default_instance_;
PROTOBUF_CONSTEXPR ApplySettings::ApplySettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.homescreen_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._passphrase_source_)*/0u
  , /*decltype(_impl_.auto_lock_delay_ms_)*/0u
  , /*decltype(_impl_.display_rotation_)*/0u
  , /*decltype(_impl_.use_passphrase_)*/false
  , /*decltype(_impl_.passphrase_always_on_device_)*/false
  , /*decltype(_impl_.experimental_features_)*/false
  , /*decltype(_impl_.hide_passphrase_from_host_)*/false
  , /*decltype(_impl_.safety_checks_)*/0} {}
struct ApplySettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplySettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplySettingsDefaultTypeInternal() {}
  union {
    ApplySettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplySettingsDefaultTypeInternal _ApplySettings_default_instance_;
PROTOBUF_CONSTEXPR ApplyFlags::ApplyFlags(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.flags_)*/0u} {}
struct ApplyFlagsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyFlagsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyFlagsDefaultTypeInternal() {}
  union {
    ApplyFlags _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyFlagsDefaultTypeInternal _ApplyFlags_default_instance_;
PROTOBUF_CONSTEXPR ChangePin::ChangePin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.remove_)*/false} {}
struct ChangePinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangePinDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangePinDefaultTypeInternal() {}
  union {
    ChangePin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangePinDefaultTypeInternal _ChangePin_default_instance_;
PROTOBUF_CONSTEXPR ChangeWipeCode::ChangeWipeCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.remove_)*/false} {}
struct ChangeWipeCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeWipeCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeWipeCodeDefaultTypeInternal() {}
  union {
    ChangeWipeCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeWipeCodeDefaultTypeInternal _ChangeWipeCode_default_instance_;
PROTOBUF_CONSTEXPR SdProtect::SdProtect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.operation_)*/0} {}
struct SdProtectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SdProtectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SdProtectDefaultTypeInternal() {}
  union {
    SdProtect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SdProtectDefaultTypeInternal _SdProtect_default_instance_;
PROTOBUF_CONSTEXPR Ping::Ping(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.button_protection_)*/false} {}
struct PingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PingDefaultTypeInternal() {}
  union {
    Ping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PingDefaultTypeInternal _Ping_default_instance_;
PROTOBUF_CONSTEXPR Cancel::Cancel(
    ::_pbi::ConstantInitialized) {}
struct CancelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CancelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CancelDefaultTypeInternal() {}
  union {
    Cancel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CancelDefaultTypeInternal _Cancel_default_instance_;
PROTOBUF_CONSTEXPR GetEntropy::GetEntropy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.size_)*/0u} {}
struct GetEntropyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetEntropyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetEntropyDefaultTypeInternal() {}
  union {
    GetEntropy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetEntropyDefaultTypeInternal _GetEntropy_default_instance_;
PROTOBUF_CONSTEXPR Entropy::Entropy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entropy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct EntropyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntropyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntropyDefaultTypeInternal() {}
  union {
    Entropy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntropyDefaultTypeInternal _Entropy_default_instance_;
PROTOBUF_CONSTEXPR GetFirmwareHash::GetFirmwareHash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.challenge_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GetFirmwareHashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetFirmwareHashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetFirmwareHashDefaultTypeInternal() {}
  union {
    GetFirmwareHash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetFirmwareHashDefaultTypeInternal _GetFirmwareHash_default_instance_;
PROTOBUF_CONSTEXPR FirmwareHash::FirmwareHash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct FirmwareHashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FirmwareHashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FirmwareHashDefaultTypeInternal() {}
  union {
    FirmwareHash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FirmwareHashDefaultTypeInternal _FirmwareHash_default_instance_;
PROTOBUF_CONSTEXPR WipeDevice::WipeDevice(
    ::_pbi::ConstantInitialized) {}
struct WipeDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WipeDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WipeDeviceDefaultTypeInternal() {}
  union {
    WipeDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WipeDeviceDefaultTypeInternal _WipeDevice_default_instance_;
PROTOBUF_CONSTEXPR LoadDevice::LoadDevice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mnemonics_)*/{}
  , /*decltype(_impl_.pin_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{nullptr, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.passphrase_protection_)*/false
  , /*decltype(_impl_.skip_checksum_)*/false
  , /*decltype(_impl_.needs_backup_)*/false
  , /*decltype(_impl_.no_backup_)*/false
  , /*decltype(_impl_.u2f_counter_)*/0u} {}
struct LoadDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadDeviceDefaultTypeInternal() {}
  union {
    LoadDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadDeviceDefaultTypeInternal _LoadDevice_default_instance_;
PROTOBUF_CONSTEXPR ResetDevice::ResetDevice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.language_)*/{nullptr, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_random_)*/false
  , /*decltype(_impl_.passphrase_protection_)*/false
  , /*decltype(_impl_.pin_protection_)*/false
  , /*decltype(_impl_.skip_backup_)*/false
  , /*decltype(_impl_.u2f_counter_)*/0u
  , /*decltype(_impl_.no_backup_)*/false
  , /*decltype(_impl_.backup_type_)*/0
  , /*decltype(_impl_.strength_)*/256u} {}
struct ResetDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetDeviceDefaultTypeInternal() {}
  union {
    ResetDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetDeviceDefaultTypeInternal _ResetDevice_default_instance_;
PROTOBUF_CONSTEXPR BackupDevice::BackupDevice(
    ::_pbi::ConstantInitialized) {}
struct BackupDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BackupDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BackupDeviceDefaultTypeInternal() {}
  union {
    BackupDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BackupDeviceDefaultTypeInternal _BackupDevice_default_instance_;
PROTOBUF_CONSTEXPR EntropyRequest::EntropyRequest(
    ::_pbi::ConstantInitialized) {}
struct EntropyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntropyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntropyRequestDefaultTypeInternal() {}
  union {
    EntropyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntropyRequestDefaultTypeInternal _EntropyRequest_default_instance_;
PROTOBUF_CONSTEXPR EntropyAck::EntropyAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entropy_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct EntropyAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntropyAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntropyAckDefaultTypeInternal() {}
  union {
    EntropyAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntropyAckDefaultTypeInternal _EntropyAck_default_instance_;
PROTOBUF_CONSTEXPR RecoveryDevice::RecoveryDevice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.word_count_)*/0u
  , /*decltype(_impl_.passphrase_protection_)*/false
  , /*decltype(_impl_.pin_protection_)*/false
  , /*decltype(_impl_.enforce_wordlist_)*/false
  , /*decltype(_impl_.dry_run_)*/false
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.u2f_counter_)*/0u} {}
struct RecoveryDeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecoveryDeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecoveryDeviceDefaultTypeInternal() {}
  union {
    RecoveryDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecoveryDeviceDefaultTypeInternal _RecoveryDevice_default_instance_;
PROTOBUF_CONSTEXPR WordRequest::WordRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0} {}
struct WordRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WordRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WordRequestDefaultTypeInternal() {}
  union {
    WordRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WordRequestDefaultTypeInternal _WordRequest_default_instance_;
PROTOBUF_CONSTEXPR WordAck::WordAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.word_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct WordAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WordAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WordAckDefaultTypeInternal() {}
  union {
    WordAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WordAckDefaultTypeInternal _WordAck_default_instance_;
PROTOBUF_CONSTEXPR SetU2FCounter::SetU2FCounter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.u2f_counter_)*/0u} {}
struct SetU2FCounterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetU2FCounterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetU2FCounterDefaultTypeInternal() {}
  union {
    SetU2FCounter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetU2FCounterDefaultTypeInternal _SetU2FCounter_default_instance_;
PROTOBUF_CONSTEXPR GetNextU2FCounter::GetNextU2FCounter(
    ::_pbi::ConstantInitialized) {}
struct GetNextU2FCounterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNextU2FCounterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNextU2FCounterDefaultTypeInternal() {}
  union {
    GetNextU2FCounter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNextU2FCounterDefaultTypeInternal _GetNextU2FCounter_default_instance_;
PROTOBUF_CONSTEXPR NextU2FCounter::NextU2FCounter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.u2f_counter_)*/0u} {}
struct NextU2FCounterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NextU2FCounterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NextU2FCounterDefaultTypeInternal() {}
  union {
    NextU2FCounter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NextU2FCounterDefaultTypeInternal _NextU2FCounter_default_instance_;
PROTOBUF_CONSTEXPR DoPreauthorized::DoPreauthorized(
    ::_pbi::ConstantInitialized) {}
struct DoPreauthorizedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoPreauthorizedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoPreauthorizedDefaultTypeInternal() {}
  union {
    DoPreauthorized _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoPreauthorizedDefaultTypeInternal _DoPreauthorized_default_instance_;
PROTOBUF_CONSTEXPR PreauthorizedRequest::PreauthorizedRequest(
    ::_pbi::ConstantInitialized) {}
struct PreauthorizedRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PreauthorizedRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PreauthorizedRequestDefaultTypeInternal() {}
  union {
    PreauthorizedRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PreauthorizedRequestDefaultTypeInternal _PreauthorizedRequest_default_instance_;
PROTOBUF_CONSTEXPR CancelAuthorization::CancelAuthorization(
    ::_pbi::ConstantInitialized) {}
struct CancelAuthorizationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CancelAuthorizationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CancelAuthorizationDefaultTypeInternal() {}
  union {
    CancelAuthorization _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CancelAuthorizationDefaultTypeInternal _CancelAuthorization_default_instance_;
PROTOBUF_CONSTEXPR RebootToBootloader::RebootToBootloader(
    ::_pbi::ConstantInitialized) {}
struct RebootToBootloaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RebootToBootloaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RebootToBootloaderDefaultTypeInternal() {}
  union {
    RebootToBootloader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RebootToBootloaderDefaultTypeInternal _RebootToBootloader_default_instance_;
PROTOBUF_CONSTEXPR GetNonce::GetNonce(
    ::_pbi::ConstantInitialized) {}
struct GetNonceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNonceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNonceDefaultTypeInternal() {}
  union {
    GetNonce _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNonceDefaultTypeInternal _GetNonce_default_instance_;
PROTOBUF_CONSTEXPR Nonce::Nonce(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nonce_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct NonceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NonceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NonceDefaultTypeInternal() {}
  union {
    Nonce _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NonceDefaultTypeInternal _Nonce_default_instance_;
PROTOBUF_CONSTEXPR UnlockPath::UnlockPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_n_)*/{}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct UnlockPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnlockPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnlockPathDefaultTypeInternal() {}
  union {
    UnlockPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnlockPathDefaultTypeInternal _UnlockPath_default_instance_;
PROTOBUF_CONSTEXPR UnlockedPathRequest::UnlockedPathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct UnlockedPathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnlockedPathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnlockedPathRequestDefaultTypeInternal() {}
  union {
    UnlockedPathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnlockedPathRequestDefaultTypeInternal _UnlockedPathRequest_default_instance_;
}  // namespace management
}  // namespace messages
}  // namespace trezor
}  // namespace hw
static ::_pb::Metadata file_level_metadata_messages_2dmanagement_2eproto[37];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_messages_2dmanagement_2eproto[7];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_messages_2dmanagement_2eproto = nullptr;

const uint32_t TableStruct_messages_2dmanagement_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Initialize, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Initialize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Initialize, _impl_.session_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Initialize, _impl_._skip_passphrase_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Initialize, _impl_.derive_cardano_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetFeatures, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.vendor_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.major_version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.minor_version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.patch_version_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.bootloader_mode_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.device_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.pin_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.passphrase_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.label_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.initialized_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.revision_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.bootloader_hash_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.imported_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.unlocked_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_._passphrase_cached_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.firmware_present_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.needs_backup_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.model_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.fw_major_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.fw_minor_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.fw_patch_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.fw_vendor_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.unfinished_backup_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.no_backup_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.recovery_mode_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.capabilities_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.backup_type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.sd_card_present_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.sd_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.wipe_code_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.session_id_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.passphrase_always_on_device_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.safety_checks_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.auto_lock_delay_ms_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.display_rotation_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.experimental_features_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.busy_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.homescreen_format_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Features, _impl_.hide_passphrase_from_host_),
  0,
  9,
  10,
  11,
  12,
  1,
  13,
  14,
  2,
  3,
  15,
  4,
  5,
  16,
  17,
  18,
  19,
  24,
  20,
  6,
  21,
  22,
  23,
  7,
  25,
  26,
  27,
  ~0u,
  28,
  29,
  30,
  31,
  8,
  32,
  33,
  34,
  35,
  36,
  37,
  39,
  38,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LockDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SetBusy, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SetBusy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SetBusy, _impl_.expiry_ms_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::EndSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.label_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.use_passphrase_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.homescreen_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_._passphrase_source_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.auto_lock_delay_ms_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.display_rotation_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.passphrase_always_on_device_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.safety_checks_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.experimental_features_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplySettings, _impl_.hide_passphrase_from_host_),
  0,
  1,
  6,
  2,
  3,
  4,
  5,
  7,
  10,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplyFlags, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplyFlags, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ApplyFlags, _impl_.flags_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ChangePin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ChangePin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ChangePin, _impl_.remove_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ChangeWipeCode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ChangeWipeCode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ChangeWipeCode, _impl_.remove_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SdProtect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SdProtect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SdProtect, _impl_.operation_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Ping, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Ping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Ping, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Ping, _impl_.button_protection_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Cancel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetEntropy, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetEntropy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetEntropy, _impl_.size_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Entropy, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Entropy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Entropy, _impl_.entropy_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetFirmwareHash, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetFirmwareHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetFirmwareHash, _impl_.challenge_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::FirmwareHash, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::FirmwareHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::FirmwareHash, _impl_.hash_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WipeDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.mnemonics_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.pin_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.passphrase_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.label_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.skip_checksum_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.u2f_counter_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.needs_backup_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::LoadDevice, _impl_.no_backup_),
  ~0u,
  0,
  3,
  1,
  2,
  4,
  7,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.display_random_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.strength_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.passphrase_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.pin_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.label_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.u2f_counter_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.skip_backup_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.no_backup_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::ResetDevice, _impl_.backup_type_),
  2,
  9,
  3,
  4,
  0,
  1,
  6,
  5,
  7,
  8,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::BackupDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::EntropyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::EntropyAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::EntropyAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::EntropyAck, _impl_.entropy_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.word_count_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.passphrase_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.pin_protection_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.label_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.enforce_wordlist_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.u2f_counter_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RecoveryDevice, _impl_.dry_run_),
  2,
  3,
  4,
  0,
  1,
  5,
  7,
  8,
  6,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WordRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WordRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WordRequest, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WordAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WordAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::WordAck, _impl_.word_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SetU2FCounter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SetU2FCounter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::SetU2FCounter, _impl_.u2f_counter_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetNextU2FCounter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::NextU2FCounter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::NextU2FCounter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::NextU2FCounter, _impl_.u2f_counter_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::DoPreauthorized, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::PreauthorizedRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::CancelAuthorization, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::RebootToBootloader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::GetNonce, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Nonce, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Nonce, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::Nonce, _impl_.nonce_),
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockPath, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockPath, _impl_.address_n_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockPath, _impl_.mac_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockedPathRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockedPathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::hw::trezor::messages::management::UnlockedPathRequest, _impl_.mac_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::hw::trezor::messages::management::Initialize)},
  { 12, -1, -1, sizeof(::hw::trezor::messages::management::GetFeatures)},
  { 18, 65, -1, sizeof(::hw::trezor::messages::management::Features)},
  { 106, -1, -1, sizeof(::hw::trezor::messages::management::LockDevice)},
  { 112, 119, -1, sizeof(::hw::trezor::messages::management::SetBusy)},
  { 120, -1, -1, sizeof(::hw::trezor::messages::management::EndSession)},
  { 126, 143, -1, sizeof(::hw::trezor::messages::management::ApplySettings)},
  { 154, 161, -1, sizeof(::hw::trezor::messages::management::ApplyFlags)},
  { 162, 169, -1, sizeof(::hw::trezor::messages::management::ChangePin)},
  { 170, 177, -1, sizeof(::hw::trezor::messages::management::ChangeWipeCode)},
  { 178, 185, -1, sizeof(::hw::trezor::messages::management::SdProtect)},
  { 186, 194, -1, sizeof(::hw::trezor::messages::management::Ping)},
  { 196, -1, -1, sizeof(::hw::trezor::messages::management::Cancel)},
  { 202, 209, -1, sizeof(::hw::trezor::messages::management::GetEntropy)},
  { 210, 217, -1, sizeof(::hw::trezor::messages::management::Entropy)},
  { 218, 225, -1, sizeof(::hw::trezor::messages::management::GetFirmwareHash)},
  { 226, 233, -1, sizeof(::hw::trezor::messages::management::FirmwareHash)},
  { 234, -1, -1, sizeof(::hw::trezor::messages::management::WipeDevice)},
  { 240, 255, -1, sizeof(::hw::trezor::messages::management::LoadDevice)},
  { 264, 280, -1, sizeof(::hw::trezor::messages::management::ResetDevice)},
  { 290, -1, -1, sizeof(::hw::trezor::messages::management::BackupDevice)},
  { 296, -1, -1, sizeof(::hw::trezor::messages::management::EntropyRequest)},
  { 302, 309, -1, sizeof(::hw::trezor::messages::management::EntropyAck)},
  { 310, 325, -1, sizeof(::hw::trezor::messages::management::RecoveryDevice)},
  { 334, 341, -1, sizeof(::hw::trezor::messages::management::WordRequest)},
  { 342, 349, -1, sizeof(::hw::trezor::messages::management::WordAck)},
  { 350, 357, -1, sizeof(::hw::trezor::messages::management::SetU2FCounter)},
  { 358, -1, -1, sizeof(::hw::trezor::messages::management::GetNextU2FCounter)},
  { 364, 371, -1, sizeof(::hw::trezor::messages::management::NextU2FCounter)},
  { 372, -1, -1, sizeof(::hw::trezor::messages::management::DoPreauthorized)},
  { 378, -1, -1, sizeof(::hw::trezor::messages::management::PreauthorizedRequest)},
  { 384, -1, -1, sizeof(::hw::trezor::messages::management::CancelAuthorization)},
  { 390, -1, -1, sizeof(::hw::trezor::messages::management::RebootToBootloader)},
  { 396, -1, -1, sizeof(::hw::trezor::messages::management::GetNonce)},
  { 402, 409, -1, sizeof(::hw::trezor::messages::management::Nonce)},
  { 410, 418, -1, sizeof(::hw::trezor::messages::management::UnlockPath)},
  { 420, 427, -1, sizeof(::hw::trezor::messages::management::UnlockedPathRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::hw::trezor::messages::management::_Initialize_default_instance_._instance,
  &::hw::trezor::messages::management::_GetFeatures_default_instance_._instance,
  &::hw::trezor::messages::management::_Features_default_instance_._instance,
  &::hw::trezor::messages::management::_LockDevice_default_instance_._instance,
  &::hw::trezor::messages::management::_SetBusy_default_instance_._instance,
  &::hw::trezor::messages::management::_EndSession_default_instance_._instance,
  &::hw::trezor::messages::management::_ApplySettings_default_instance_._instance,
  &::hw::trezor::messages::management::_ApplyFlags_default_instance_._instance,
  &::hw::trezor::messages::management::_ChangePin_default_instance_._instance,
  &::hw::trezor::messages::management::_ChangeWipeCode_default_instance_._instance,
  &::hw::trezor::messages::management::_SdProtect_default_instance_._instance,
  &::hw::trezor::messages::management::_Ping_default_instance_._instance,
  &::hw::trezor::messages::management::_Cancel_default_instance_._instance,
  &::hw::trezor::messages::management::_GetEntropy_default_instance_._instance,
  &::hw::trezor::messages::management::_Entropy_default_instance_._instance,
  &::hw::trezor::messages::management::_GetFirmwareHash_default_instance_._instance,
  &::hw::trezor::messages::management::_FirmwareHash_default_instance_._instance,
  &::hw::trezor::messages::management::_WipeDevice_default_instance_._instance,
  &::hw::trezor::messages::management::_LoadDevice_default_instance_._instance,
  &::hw::trezor::messages::management::_ResetDevice_default_instance_._instance,
  &::hw::trezor::messages::management::_BackupDevice_default_instance_._instance,
  &::hw::trezor::messages::management::_EntropyRequest_default_instance_._instance,
  &::hw::trezor::messages::management::_EntropyAck_default_instance_._instance,
  &::hw::trezor::messages::management::_RecoveryDevice_default_instance_._instance,
  &::hw::trezor::messages::management::_WordRequest_default_instance_._instance,
  &::hw::trezor::messages::management::_WordAck_default_instance_._instance,
  &::hw::trezor::messages::management::_SetU2FCounter_default_instance_._instance,
  &::hw::trezor::messages::management::_GetNextU2FCounter_default_instance_._instance,
  &::hw::trezor::messages::management::_NextU2FCounter_default_instance_._instance,
  &::hw::trezor::messages::management::_DoPreauthorized_default_instance_._instance,
  &::hw::trezor::messages::management::_PreauthorizedRequest_default_instance_._instance,
  &::hw::trezor::messages::management::_CancelAuthorization_default_instance_._instance,
  &::hw::trezor::messages::management::_RebootToBootloader_default_instance_._instance,
  &::hw::trezor::messages::management::_GetNonce_default_instance_._instance,
  &::hw::trezor::messages::management::_Nonce_default_instance_._instance,
  &::hw::trezor::messages::management::_UnlockPath_default_instance_._instance,
  &::hw::trezor::messages::management::_UnlockedPathRequest_default_instance_._instance,
};

const char descriptor_table_protodef_messages_2dmanagement_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\031messages-management.proto\022\035hw.trezor.m"
  "essages.management\032\016messages.proto\"V\n\nIn"
  "itialize\022\022\n\nsession_id\030\001 \001(\014\022\034\n\020_skip_pa"
  "ssphrase\030\002 \001(\010B\002\030\001\022\026\n\016derive_cardano\030\003 \001"
  "(\010\"\r\n\013GetFeatures\"\273\014\n\010Features\022\016\n\006vendor"
  "\030\001 \001(\t\022\025\n\rmajor_version\030\002 \002(\r\022\025\n\rminor_v"
  "ersion\030\003 \002(\r\022\025\n\rpatch_version\030\004 \002(\r\022\027\n\017b"
  "ootloader_mode\030\005 \001(\010\022\021\n\tdevice_id\030\006 \001(\t\022"
  "\026\n\016pin_protection\030\007 \001(\010\022\035\n\025passphrase_pr"
  "otection\030\010 \001(\010\022\020\n\010language\030\t \001(\t\022\r\n\005labe"
  "l\030\n \001(\t\022\023\n\013initialized\030\014 \001(\010\022\020\n\010revision"
  "\030\r \001(\014\022\027\n\017bootloader_hash\030\016 \001(\014\022\020\n\010impor"
  "ted\030\017 \001(\010\022\020\n\010unlocked\030\020 \001(\010\022\036\n\022_passphra"
  "se_cached\030\021 \001(\010B\002\030\001\022\030\n\020firmware_present\030"
  "\022 \001(\010\022\024\n\014needs_backup\030\023 \001(\010\022\r\n\005flags\030\024 \001"
  "(\r\022\r\n\005model\030\025 \001(\t\022\020\n\010fw_major\030\026 \001(\r\022\020\n\010f"
  "w_minor\030\027 \001(\r\022\020\n\010fw_patch\030\030 \001(\r\022\021\n\tfw_ve"
  "ndor\030\031 \001(\t\022\031\n\021unfinished_backup\030\033 \001(\010\022\021\n"
  "\tno_backup\030\034 \001(\010\022\025\n\rrecovery_mode\030\035 \001(\010\022"
  "H\n\014capabilities\030\036 \003(\01622.hw.trezor.messag"
  "es.management.Features.Capability\022>\n\013bac"
  "kup_type\030\037 \001(\0162).hw.trezor.messages.mana"
  "gement.BackupType\022\027\n\017sd_card_present\030  \001"
  "(\010\022\025\n\rsd_protection\030! \001(\010\022\034\n\024wipe_code_p"
  "rotection\030\" \001(\010\022\022\n\nsession_id\030# \001(\014\022#\n\033p"
  "assphrase_always_on_device\030$ \001(\010\022F\n\rsafe"
  "ty_checks\030% \001(\0162/.hw.trezor.messages.man"
  "agement.SafetyCheckLevel\022\032\n\022auto_lock_de"
  "lay_ms\030& \001(\r\022\030\n\020display_rotation\030\' \001(\r\022\035"
  "\n\025experimental_features\030( \001(\010\022\014\n\004busy\030) "
  "\001(\010\022J\n\021homescreen_format\030* \001(\0162/.hw.trez"
  "or.messages.management.HomescreenFormat\022"
  "!\n\031hide_passphrase_from_host\030+ \001(\010\"\312\003\n\nC"
  "apability\022\034\n\022Capability_Bitcoin\020\001\032\004\200\246\035\001\022"
  "\033\n\027Capability_Bitcoin_like\020\002\022\026\n\022Capabili"
  "ty_Binance\020\003\022\026\n\022Capability_Cardano\020\004\022\033\n\021"
  "Capability_Crypto\020\005\032\004\200\246\035\001\022\022\n\016Capability_"
  "EOS\020\006\022\027\n\023Capability_Ethereum\020\007\022\027\n\017Capabi"
  "lity_Lisk\020\010\032\002\010\001\022\025\n\021Capability_Monero\020\t\022\022"
  "\n\016Capability_NEM\020\n\022\025\n\021Capability_Ripple\020"
  "\013\022\026\n\022Capability_Stellar\020\014\022\024\n\020Capability_"
  "Tezos\020\r\022\022\n\016Capability_U2F\020\016\022\033\n\021Capabilit"
  "y_Shamir\020\017\032\004\200\246\035\001\022!\n\027Capability_ShamirGro"
  "ups\020\020\032\004\200\246\035\001\022$\n\032Capability_PassphraseEntr"
  "y\020\021\032\004\200\246\035\001\032\004\310\363\030\001\"\014\n\nLockDevice\"\034\n\007SetBusy"
  "\022\021\n\texpiry_ms\030\001 \001(\r\"\014\n\nEndSession\"\341\002\n\rAp"
  "plySettings\022\020\n\010language\030\001 \001(\t\022\r\n\005label\030\002"
  " \001(\t\022\026\n\016use_passphrase\030\003 \001(\010\022\022\n\nhomescre"
  "en\030\004 \001(\014\022\036\n\022_passphrase_source\030\005 \001(\rB\002\030\001"
  "\022\032\n\022auto_lock_delay_ms\030\006 \001(\r\022\030\n\020display_"
  "rotation\030\007 \001(\r\022#\n\033passphrase_always_on_d"
  "evice\030\010 \001(\010\022F\n\rsafety_checks\030\t \001(\0162/.hw."
  "trezor.messages.management.SafetyCheckLe"
  "vel\022\035\n\025experimental_features\030\n \001(\010\022!\n\031hi"
  "de_passphrase_from_host\030\013 \001(\010\"\033\n\nApplyFl"
  "ags\022\r\n\005flags\030\001 \002(\r\"\033\n\tChangePin\022\016\n\006remov"
  "e\030\001 \001(\010\" \n\016ChangeWipeCode\022\016\n\006remove\030\001 \001("
  "\010\"\237\001\n\tSdProtect\022R\n\toperation\030\001 \002(\0162\?.hw."
  "trezor.messages.management.SdProtect.SdP"
  "rotectOperationType\">\n\026SdProtectOperatio"
  "nType\022\013\n\007DISABLE\020\000\022\n\n\006ENABLE\020\001\022\013\n\007REFRES"
  "H\020\002\"4\n\004Ping\022\021\n\007message\030\001 \001(\t:\000\022\031\n\021button"
  "_protection\030\002 \001(\010\"\010\n\006Cancel\"\032\n\nGetEntrop"
  "y\022\014\n\004size\030\001 \002(\r\"\032\n\007Entropy\022\017\n\007entropy\030\001 "
  "\002(\014\"$\n\017GetFirmwareHash\022\021\n\tchallenge\030\001 \001("
  "\014\"\034\n\014FirmwareHash\022\014\n\004hash\030\001 \002(\014\"\014\n\nWipeD"
  "evice\"\310\001\n\nLoadDevice\022\021\n\tmnemonics\030\001 \003(\t\022"
  "\013\n\003pin\030\003 \001(\t\022\035\n\025passphrase_protection\030\004 "
  "\001(\010\022\027\n\010language\030\005 \001(\t:\005en-US\022\r\n\005label\030\006 "
  "\001(\t\022\025\n\rskip_checksum\030\007 \001(\010\022\023\n\013u2f_counte"
  "r\030\010 \001(\r\022\024\n\014needs_backup\030\t \001(\010\022\021\n\tno_back"
  "up\030\n \001(\010\"\237\002\n\013ResetDevice\022\026\n\016display_rand"
  "om\030\001 \001(\010\022\025\n\010strength\030\002 \001(\r:\003256\022\035\n\025passp"
  "hrase_protection\030\003 \001(\010\022\026\n\016pin_protection"
  "\030\004 \001(\010\022\027\n\010language\030\005 \001(\t:\005en-US\022\r\n\005label"
  "\030\006 \001(\t\022\023\n\013u2f_counter\030\007 \001(\r\022\023\n\013skip_back"
  "up\030\010 \001(\010\022\021\n\tno_backup\030\t \001(\010\022E\n\013backup_ty"
  "pe\030\n \001(\0162).hw.trezor.messages.management"
  ".BackupType:\005Bip39\"\016\n\014BackupDevice\"\020\n\016En"
  "tropyRequest\"\035\n\nEntropyAck\022\017\n\007entropy\030\001 "
  "\002(\014\"\350\002\n\016RecoveryDevice\022\022\n\nword_count\030\001 \001"
  "(\r\022\035\n\025passphrase_protection\030\002 \001(\010\022\026\n\016pin"
  "_protection\030\003 \001(\010\022\020\n\010language\030\004 \001(\t\022\r\n\005l"
  "abel\030\005 \001(\t\022\030\n\020enforce_wordlist\030\006 \001(\010\022N\n\004"
  "type\030\010 \001(\0162@.hw.trezor.messages.manageme"
  "nt.RecoveryDevice.RecoveryDeviceType\022\023\n\013"
  "u2f_counter\030\t \001(\r\022\017\n\007dry_run\030\n \001(\010\"Z\n\022Re"
  "coveryDeviceType\022%\n!RecoveryDeviceType_S"
  "crambledWords\020\000\022\035\n\031RecoveryDeviceType_Ma"
  "trix\020\001\"\277\001\n\013WordRequest\022H\n\004type\030\001 \002(\0162:.h"
  "w.trezor.messages.management.WordRequest"
  ".WordRequestType\"f\n\017WordRequestType\022\031\n\025W"
  "ordRequestType_Plain\020\000\022\033\n\027WordRequestTyp"
  "e_Matrix9\020\001\022\033\n\027WordRequestType_Matrix6\020\002"
  "\"\027\n\007WordAck\022\014\n\004word\030\001 \002(\t\"$\n\rSetU2FCount"
  "er\022\023\n\013u2f_counter\030\001 \002(\r\"\023\n\021GetNextU2FCou"
  "nter\"%\n\016NextU2FCounter\022\023\n\013u2f_counter\030\001 "
  "\002(\r\"\021\n\017DoPreauthorized\"\026\n\024PreauthorizedR"
  "equest\"\025\n\023CancelAuthorization\"\024\n\022RebootT"
  "oBootloader\"\020\n\010GetNonce:\004\210\262\031\001\"\034\n\005Nonce\022\r"
  "\n\005nonce\030\001 \002(\014:\004\210\262\031\001\",\n\nUnlockPath\022\021\n\tadd"
  "ress_n\030\001 \003(\r\022\013\n\003mac\030\002 \001(\014\"\"\n\023UnlockedPat"
  "hRequest\022\013\n\003mac\030\001 \001(\014*>\n\nBackupType\022\t\n\005B"
  "ip39\020\000\022\020\n\014Slip39_Basic\020\001\022\023\n\017Slip39_Advan"
  "ced\020\002*G\n\020SafetyCheckLevel\022\n\n\006Strict\020\000\022\020\n"
  "\014PromptAlways\020\001\022\025\n\021PromptTemporarily\020\002*4"
  "\n\020HomescreenFormat\022\017\n\013Toif144x144\020\001\022\017\n\013J"
  "peg240x240\020\002BB\n#com.satoshilabs.trezor.l"
  "ib.protobufB\027TrezorMessageManagement\200\246\035\001"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_messages_2dmanagement_2eproto_deps[1] = {
  &::descriptor_table_messages_2eproto,
};
static ::_pbi::once_flag descriptor_table_messages_2dmanagement_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_messages_2dmanagement_2eproto = {
    false, false, 4360, descriptor_table_protodef_messages_2dmanagement_2eproto,
    "messages-management.proto",
    &descriptor_table_messages_2dmanagement_2eproto_once, descriptor_table_messages_2dmanagement_2eproto_deps, 1, 37,
    schemas, file_default_instances, TableStruct_messages_2dmanagement_2eproto::offsets,
    file_level_metadata_messages_2dmanagement_2eproto, file_level_enum_descriptors_messages_2dmanagement_2eproto,
    file_level_service_descriptors_messages_2dmanagement_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_messages_2dmanagement_2eproto_getter() {
  return &descriptor_table_messages_2dmanagement_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_messages_2dmanagement_2eproto(&descriptor_table_messages_2dmanagement_2eproto);
namespace hw {
namespace trezor {
namespace messages {
namespace management {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Features_Capability_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[0];
}
bool Features_Capability_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Features_Capability Features::Capability_Bitcoin;
constexpr Features_Capability Features::Capability_Bitcoin_like;
constexpr Features_Capability Features::Capability_Binance;
constexpr Features_Capability Features::Capability_Cardano;
constexpr Features_Capability Features::Capability_Crypto;
constexpr Features_Capability Features::Capability_EOS;
constexpr Features_Capability Features::Capability_Ethereum;
constexpr Features_Capability Features::Capability_Lisk;
constexpr Features_Capability Features::Capability_Monero;
constexpr Features_Capability Features::Capability_NEM;
constexpr Features_Capability Features::Capability_Ripple;
constexpr Features_Capability Features::Capability_Stellar;
constexpr Features_Capability Features::Capability_Tezos;
constexpr Features_Capability Features::Capability_U2F;
constexpr Features_Capability Features::Capability_Shamir;
constexpr Features_Capability Features::Capability_ShamirGroups;
constexpr Features_Capability Features::Capability_PassphraseEntry;
constexpr Features_Capability Features::Capability_MIN;
constexpr Features_Capability Features::Capability_MAX;
constexpr int Features::Capability_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SdProtect_SdProtectOperationType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[1];
}
bool SdProtect_SdProtectOperationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SdProtect_SdProtectOperationType SdProtect::DISABLE;
constexpr SdProtect_SdProtectOperationType SdProtect::ENABLE;
constexpr SdProtect_SdProtectOperationType SdProtect::REFRESH;
constexpr SdProtect_SdProtectOperationType SdProtect::SdProtectOperationType_MIN;
constexpr SdProtect_SdProtectOperationType SdProtect::SdProtectOperationType_MAX;
constexpr int SdProtect::SdProtectOperationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecoveryDevice_RecoveryDeviceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[2];
}
bool RecoveryDevice_RecoveryDeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RecoveryDevice_RecoveryDeviceType RecoveryDevice::RecoveryDeviceType_ScrambledWords;
constexpr RecoveryDevice_RecoveryDeviceType RecoveryDevice::RecoveryDeviceType_Matrix;
constexpr RecoveryDevice_RecoveryDeviceType RecoveryDevice::RecoveryDeviceType_MIN;
constexpr RecoveryDevice_RecoveryDeviceType RecoveryDevice::RecoveryDeviceType_MAX;
constexpr int RecoveryDevice::RecoveryDeviceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WordRequest_WordRequestType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[3];
}
bool WordRequest_WordRequestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WordRequest_WordRequestType WordRequest::WordRequestType_Plain;
constexpr WordRequest_WordRequestType WordRequest::WordRequestType_Matrix9;
constexpr WordRequest_WordRequestType WordRequest::WordRequestType_Matrix6;
constexpr WordRequest_WordRequestType WordRequest::WordRequestType_MIN;
constexpr WordRequest_WordRequestType WordRequest::WordRequestType_MAX;
constexpr int WordRequest::WordRequestType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BackupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[4];
}
bool BackupType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SafetyCheckLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[5];
}
bool SafetyCheckLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HomescreenFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_messages_2dmanagement_2eproto);
  return file_level_enum_descriptors_messages_2dmanagement_2eproto[6];
}
bool HomescreenFormat_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Initialize::_Internal {
 public:
  using HasBits = decltype(std::declval<Initialize>()._impl_._has_bits_);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has__skip_passphrase(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_derive_cardano(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Initialize::Initialize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.Initialize)
}
Initialize::Initialize(const Initialize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Initialize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_._skip_passphrase_){}
    , decltype(_impl_.derive_cardano_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_session_id()) {
    _this->_impl_.session_id_.Set(from._internal_session_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._skip_passphrase_, &from._impl_._skip_passphrase_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.derive_cardano_) -
    reinterpret_cast<char*>(&_impl_._skip_passphrase_)) + sizeof(_impl_.derive_cardano_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.Initialize)
}

inline void Initialize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_._skip_passphrase_){false}
    , decltype(_impl_.derive_cardano_){false}
  };
  _impl_.session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Initialize::~Initialize() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.Initialize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Initialize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.session_id_.Destroy();
}

void Initialize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Initialize::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.Initialize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.session_id_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_._skip_passphrase_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.derive_cardano_) -
      reinterpret_cast<char*>(&_impl_._skip_passphrase_)) + sizeof(_impl_.derive_cardano_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Initialize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool _skip_passphrase = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has__skip_passphrase(&has_bits);
          _impl_._skip_passphrase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool derive_cardano = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_derive_cardano(&has_bits);
          _impl_.derive_cardano_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Initialize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.Initialize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes session_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_session_id(), target);
  }

  // optional bool _skip_passphrase = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal__skip_passphrase(), target);
  }

  // optional bool derive_cardano = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_derive_cardano(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.Initialize)
  return target;
}

size_t Initialize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.Initialize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes session_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_session_id());
    }

    // optional bool _skip_passphrase = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool derive_cardano = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Initialize::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Initialize::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Initialize::GetClassData() const { return &_class_data_; }


void Initialize::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Initialize*>(&to_msg);
  auto& from = static_cast<const Initialize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.Initialize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_session_id(from._internal_session_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_._skip_passphrase_ = from._impl_._skip_passphrase_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.derive_cardano_ = from._impl_.derive_cardano_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Initialize::CopyFrom(const Initialize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.Initialize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Initialize::IsInitialized() const {
  return true;
}

void Initialize::InternalSwap(Initialize* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.session_id_, lhs_arena,
      &other->_impl_.session_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Initialize, _impl_.derive_cardano_)
      + sizeof(Initialize::_impl_.derive_cardano_)
      - PROTOBUF_FIELD_OFFSET(Initialize, _impl_._skip_passphrase_)>(
          reinterpret_cast<char*>(&_impl_._skip_passphrase_),
          reinterpret_cast<char*>(&other->_impl_._skip_passphrase_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Initialize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[0]);
}

// ===================================================================

class GetFeatures::_Internal {
 public:
};

GetFeatures::GetFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.GetFeatures)
}
GetFeatures::GetFeatures(const GetFeatures& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GetFeatures* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.GetFeatures)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFeatures::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFeatures::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GetFeatures::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[1]);
}

// ===================================================================

class Features::_Internal {
 public:
  using HasBits = decltype(std::declval<Features>()._impl_._has_bits_);
  static void set_has_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_major_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_minor_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_patch_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_bootloader_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pin_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_passphrase_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_initialized(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bootloader_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_imported(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_unlocked(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has__passphrase_cached(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_firmware_present(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_needs_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fw_major(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_fw_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_fw_patch(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_fw_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_unfinished_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_no_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_recovery_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_backup_type(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_sd_card_present(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_sd_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_wipe_code_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_passphrase_always_on_device(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_safety_checks(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_auto_lock_delay_ms(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_display_rotation(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_experimental_features(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_busy(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_homescreen_format(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_hide_passphrase_from_host(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000e00) ^ 0x00000e00) != 0;
  }
};

Features::Features(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.Features)
}
Features::Features(const Features& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Features* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.capabilities_){from._impl_.capabilities_}
    , decltype(_impl_.vendor_){}
    , decltype(_impl_.device_id_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.revision_){}
    , decltype(_impl_.bootloader_hash_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.fw_vendor_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.major_version_){}
    , decltype(_impl_.minor_version_){}
    , decltype(_impl_.patch_version_){}
    , decltype(_impl_.bootloader_mode_){}
    , decltype(_impl_.pin_protection_){}
    , decltype(_impl_.passphrase_protection_){}
    , decltype(_impl_.initialized_){}
    , decltype(_impl_.imported_){}
    , decltype(_impl_.unlocked_){}
    , decltype(_impl_._passphrase_cached_){}
    , decltype(_impl_.firmware_present_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.fw_major_){}
    , decltype(_impl_.fw_minor_){}
    , decltype(_impl_.fw_patch_){}
    , decltype(_impl_.needs_backup_){}
    , decltype(_impl_.unfinished_backup_){}
    , decltype(_impl_.no_backup_){}
    , decltype(_impl_.recovery_mode_){}
    , decltype(_impl_.backup_type_){}
    , decltype(_impl_.sd_card_present_){}
    , decltype(_impl_.sd_protection_){}
    , decltype(_impl_.wipe_code_protection_){}
    , decltype(_impl_.passphrase_always_on_device_){}
    , decltype(_impl_.safety_checks_){}
    , decltype(_impl_.auto_lock_delay_ms_){}
    , decltype(_impl_.display_rotation_){}
    , decltype(_impl_.experimental_features_){}
    , decltype(_impl_.busy_){}
    , decltype(_impl_.hide_passphrase_from_host_){}
    , decltype(_impl_.homescreen_format_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor()) {
    _this->_impl_.vendor_.Set(from._internal_vendor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_id()) {
    _this->_impl_.device_id_.Set(from._internal_device_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  _impl_.revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.revision_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_revision()) {
    _this->_impl_.revision_.Set(from._internal_revision(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bootloader_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bootloader_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bootloader_hash()) {
    _this->_impl_.bootloader_hash_.Set(from._internal_bootloader_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fw_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fw_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fw_vendor()) {
    _this->_impl_.fw_vendor_.Set(from._internal_fw_vendor(), 
      _this->GetArenaForAllocation());
  }
  _impl_.session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_session_id()) {
    _this->_impl_.session_id_.Set(from._internal_session_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.major_version_, &from._impl_.major_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.homescreen_format_) -
    reinterpret_cast<char*>(&_impl_.major_version_)) + sizeof(_impl_.homescreen_format_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.Features)
}

inline void Features::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.capabilities_){arena}
    , decltype(_impl_.vendor_){}
    , decltype(_impl_.device_id_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.revision_){}
    , decltype(_impl_.bootloader_hash_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.fw_vendor_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.major_version_){0u}
    , decltype(_impl_.minor_version_){0u}
    , decltype(_impl_.patch_version_){0u}
    , decltype(_impl_.bootloader_mode_){false}
    , decltype(_impl_.pin_protection_){false}
    , decltype(_impl_.passphrase_protection_){false}
    , decltype(_impl_.initialized_){false}
    , decltype(_impl_.imported_){false}
    , decltype(_impl_.unlocked_){false}
    , decltype(_impl_._passphrase_cached_){false}
    , decltype(_impl_.firmware_present_){false}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.fw_major_){0u}
    , decltype(_impl_.fw_minor_){0u}
    , decltype(_impl_.fw_patch_){0u}
    , decltype(_impl_.needs_backup_){false}
    , decltype(_impl_.unfinished_backup_){false}
    , decltype(_impl_.no_backup_){false}
    , decltype(_impl_.recovery_mode_){false}
    , decltype(_impl_.backup_type_){0}
    , decltype(_impl_.sd_card_present_){false}
    , decltype(_impl_.sd_protection_){false}
    , decltype(_impl_.wipe_code_protection_){false}
    , decltype(_impl_.passphrase_always_on_device_){false}
    , decltype(_impl_.safety_checks_){0}
    , decltype(_impl_.auto_lock_delay_ms_){0u}
    , decltype(_impl_.display_rotation_){0u}
    , decltype(_impl_.experimental_features_){false}
    , decltype(_impl_.busy_){false}
    , decltype(_impl_.hide_passphrase_from_host_){false}
    , decltype(_impl_.homescreen_format_){1}
  };
  _impl_.vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.revision_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bootloader_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bootloader_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fw_vendor_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fw_vendor_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Features::~Features() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.Features)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Features::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.capabilities_.~RepeatedField();
  _impl_.vendor_.Destroy();
  _impl_.device_id_.Destroy();
  _impl_.language_.Destroy();
  _impl_.label_.Destroy();
  _impl_.revision_.Destroy();
  _impl_.bootloader_hash_.Destroy();
  _impl_.model_.Destroy();
  _impl_.fw_vendor_.Destroy();
  _impl_.session_id_.Destroy();
}

void Features::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Features::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.Features)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.capabilities_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.vendor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.device_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.revision_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.bootloader_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.fw_vendor_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _impl_.session_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000fe00u) {
    ::memset(&_impl_.major_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.initialized_) -
        reinterpret_cast<char*>(&_impl_.major_version_)) + sizeof(_impl_.initialized_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.imported_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fw_patch_) -
        reinterpret_cast<char*>(&_impl_.imported_)) + sizeof(_impl_.fw_patch_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.needs_backup_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.wipe_code_protection_) -
        reinterpret_cast<char*>(&_impl_.needs_backup_)) + sizeof(_impl_.wipe_code_protection_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.passphrase_always_on_device_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hide_passphrase_from_host_) -
        reinterpret_cast<char*>(&_impl_.passphrase_always_on_device_)) + sizeof(_impl_.hide_passphrase_from_host_));
    _impl_.homescreen_format_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Features::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string vendor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Features.vendor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 major_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_major_version(&_impl_._has_bits_);
          _impl_.major_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 minor_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_minor_version(&_impl_._has_bits_);
          _impl_.minor_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 patch_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_patch_version(&_impl_._has_bits_);
          _impl_.patch_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bootloader_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bootloader_mode(&_impl_._has_bits_);
          _impl_.bootloader_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Features.device_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool pin_protection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_pin_protection(&_impl_._has_bits_);
          _impl_.pin_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool passphrase_protection = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_passphrase_protection(&_impl_._has_bits_);
          _impl_.passphrase_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Features.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string label = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Features.label");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool initialized = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_initialized(&_impl_._has_bits_);
          _impl_.initialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes revision = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_revision();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes bootloader_hash = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_bootloader_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool imported = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_imported(&_impl_._has_bits_);
          _impl_.imported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool unlocked = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_unlocked(&_impl_._has_bits_);
          _impl_.unlocked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool _passphrase_cached = 17 [deprecated = true];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has__passphrase_cached(&_impl_._has_bits_);
          _impl_._passphrase_cached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool firmware_present = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_firmware_present(&_impl_._has_bits_);
          _impl_.firmware_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_backup = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_needs_backup(&_impl_._has_bits_);
          _impl_.needs_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_flags(&_impl_._has_bits_);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Features.model");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fw_major = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_fw_major(&_impl_._has_bits_);
          _impl_.fw_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fw_minor = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_fw_minor(&_impl_._has_bits_);
          _impl_.fw_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fw_patch = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_fw_patch(&_impl_._has_bits_);
          _impl_.fw_patch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string fw_vendor = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_fw_vendor();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Features.fw_vendor");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool unfinished_backup = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_unfinished_backup(&_impl_._has_bits_);
          _impl_.unfinished_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool no_backup = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_no_backup(&_impl_._has_bits_);
          _impl_.no_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool recovery_mode = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_recovery_mode(&_impl_._has_bits_);
          _impl_.recovery_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .hw.trezor.messages.management.Features.Capability capabilities = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::Features_Capability_IsValid(val))) {
              _internal_add_capabilities(static_cast<::hw::trezor::messages::management::Features_Capability>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<240>(ptr));
        } else if (static_cast<uint8_t>(tag) == 242) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_capabilities(), ptr, ctx, ::hw::trezor::messages::management::Features_Capability_IsValid, &_internal_metadata_, 30);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.management.BackupType backup_type = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::BackupType_IsValid(val))) {
            _internal_set_backup_type(static_cast<::hw::trezor::messages::management::BackupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(31, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool sd_card_present = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_sd_card_present(&_impl_._has_bits_);
          _impl_.sd_card_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sd_protection = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sd_protection(&_impl_._has_bits_);
          _impl_.sd_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool wipe_code_protection = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_wipe_code_protection(&_impl_._has_bits_);
          _impl_.wipe_code_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes session_id = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool passphrase_always_on_device = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_passphrase_always_on_device(&_impl_._has_bits_);
          _impl_.passphrase_always_on_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::SafetyCheckLevel_IsValid(val))) {
            _internal_set_safety_checks(static_cast<::hw::trezor::messages::management::SafetyCheckLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(37, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auto_lock_delay_ms = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_auto_lock_delay_ms(&_impl_._has_bits_);
          _impl_.auto_lock_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 display_rotation = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_display_rotation(&_impl_._has_bits_);
          _impl_.display_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool experimental_features = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_experimental_features(&_impl_._has_bits_);
          _impl_.experimental_features_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool busy = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_busy(&_impl_._has_bits_);
          _impl_.busy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.management.HomescreenFormat homescreen_format = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::HomescreenFormat_IsValid(val))) {
            _internal_set_homescreen_format(static_cast<::hw::trezor::messages::management::HomescreenFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(42, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool hide_passphrase_from_host = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_hide_passphrase_from_host(&_impl_._has_bits_);
          _impl_.hide_passphrase_from_host_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Features::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.Features)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string vendor = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vendor().data(), static_cast<int>(this->_internal_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Features.vendor");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vendor(), target);
  }

  // required uint32 major_version = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_major_version(), target);
  }

  // required uint32 minor_version = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_minor_version(), target);
  }

  // required uint32 patch_version = 4;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_patch_version(), target);
  }

  // optional bool bootloader_mode = 5;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bootloader_mode(), target);
  }

  // optional string device_id = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Features.device_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_device_id(), target);
  }

  // optional bool pin_protection = 7;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_pin_protection(), target);
  }

  // optional bool passphrase_protection = 8;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_passphrase_protection(), target);
  }

  // optional string language = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Features.language");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_language(), target);
  }

  // optional string label = 10;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Features.label");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_label(), target);
  }

  // optional bool initialized = 12;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_initialized(), target);
  }

  // optional bytes revision = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_revision(), target);
  }

  // optional bytes bootloader_hash = 14;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_bootloader_hash(), target);
  }

  // optional bool imported = 15;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_imported(), target);
  }

  // optional bool unlocked = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_unlocked(), target);
  }

  // optional bool _passphrase_cached = 17 [deprecated = true];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal__passphrase_cached(), target);
  }

  // optional bool firmware_present = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_firmware_present(), target);
  }

  // optional bool needs_backup = 19;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_needs_backup(), target);
  }

  // optional uint32 flags = 20;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_flags(), target);
  }

  // optional string model = 21;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Features.model");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_model(), target);
  }

  // optional uint32 fw_major = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_fw_major(), target);
  }

  // optional uint32 fw_minor = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_fw_minor(), target);
  }

  // optional uint32 fw_patch = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_fw_patch(), target);
  }

  // optional string fw_vendor = 25;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_fw_vendor().data(), static_cast<int>(this->_internal_fw_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Features.fw_vendor");
    target = stream->WriteStringMaybeAliased(
        25, this->_internal_fw_vendor(), target);
  }

  // optional bool unfinished_backup = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_unfinished_backup(), target);
  }

  // optional bool no_backup = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_no_backup(), target);
  }

  // optional bool recovery_mode = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_recovery_mode(), target);
  }

  // repeated .hw.trezor.messages.management.Features.Capability capabilities = 30;
  for (int i = 0, n = this->_internal_capabilities_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        30, this->_internal_capabilities(i), target);
  }

  // optional .hw.trezor.messages.management.BackupType backup_type = 31;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      31, this->_internal_backup_type(), target);
  }

  // optional bool sd_card_present = 32;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_sd_card_present(), target);
  }

  // optional bool sd_protection = 33;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(33, this->_internal_sd_protection(), target);
  }

  // optional bool wipe_code_protection = 34;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(34, this->_internal_wipe_code_protection(), target);
  }

  // optional bytes session_id = 35;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteBytesMaybeAliased(
        35, this->_internal_session_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool passphrase_always_on_device = 36;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_passphrase_always_on_device(), target);
  }

  // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      37, this->_internal_safety_checks(), target);
  }

  // optional uint32 auto_lock_delay_ms = 38;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(38, this->_internal_auto_lock_delay_ms(), target);
  }

  // optional uint32 display_rotation = 39;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_display_rotation(), target);
  }

  // optional bool experimental_features = 40;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(40, this->_internal_experimental_features(), target);
  }

  // optional bool busy = 41;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(41, this->_internal_busy(), target);
  }

  // optional .hw.trezor.messages.management.HomescreenFormat homescreen_format = 42;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      42, this->_internal_homescreen_format(), target);
  }

  // optional bool hide_passphrase_from_host = 43;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(43, this->_internal_hide_passphrase_from_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.Features)
  return target;
}

size_t Features::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hw.trezor.messages.management.Features)
  size_t total_size = 0;

  if (_internal_has_major_version()) {
    // required uint32 major_version = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_major_version());
  }

  if (_internal_has_minor_version()) {
    // required uint32 minor_version = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_version());
  }

  if (_internal_has_patch_version()) {
    // required uint32 patch_version = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_patch_version());
  }

  return total_size;
}
size_t Features::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.Features)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000e00) ^ 0x00000e00) == 0) {  // All required fields are present.
    // required uint32 major_version = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_major_version());

    // required uint32 minor_version = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_minor_version());

    // required uint32 patch_version = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_patch_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hw.trezor.messages.management.Features.Capability capabilities = 30;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_capabilities_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_capabilities(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string vendor = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor());
    }

    // optional string device_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_id());
    }

    // optional string language = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string label = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional bytes revision = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_revision());
    }

    // optional bytes bootloader_hash = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bootloader_hash());
    }

    // optional string model = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional string fw_vendor = 25;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fw_vendor());
    }

  }
  // optional bytes session_id = 35;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_session_id());
  }

  if (cached_has_bits & 0x0000f000u) {
    // optional bool bootloader_mode = 5;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 7;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool initialized = 12;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool imported = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool unlocked = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool _passphrase_cached = 17 [deprecated = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool firmware_present = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional uint32 flags = 20;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional uint32 fw_major = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_fw_major());
    }

    // optional uint32 fw_minor = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_fw_minor());
    }

    // optional uint32 fw_patch = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_fw_patch());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool needs_backup = 19;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool unfinished_backup = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool no_backup = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool recovery_mode = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional .hw.trezor.messages.management.BackupType backup_type = 31;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_backup_type());
    }

    // optional bool sd_card_present = 32;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional bool sd_protection = 33;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional bool wipe_code_protection = 34;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool passphrase_always_on_device = 36;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 37;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_safety_checks());
    }

    // optional uint32 auto_lock_delay_ms = 38;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_auto_lock_delay_ms());
    }

    // optional uint32 display_rotation = 39;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_display_rotation());
    }

    // optional bool experimental_features = 40;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool busy = 41;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool hide_passphrase_from_host = 43;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional .hw.trezor.messages.management.HomescreenFormat homescreen_format = 42;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_homescreen_format());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Features::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Features::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Features::GetClassData() const { return &_class_data_; }


void Features::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Features*>(&to_msg);
  auto& from = static_cast<const Features&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.Features)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.capabilities_.MergeFrom(from._impl_.capabilities_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_vendor(from._internal_vendor());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_device_id(from._internal_device_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_revision(from._internal_revision());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_bootloader_hash(from._internal_bootloader_hash());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_fw_vendor(from._internal_fw_vendor());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_session_id(from._internal_session_id());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.major_version_ = from._impl_.major_version_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.minor_version_ = from._impl_.minor_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.patch_version_ = from._impl_.patch_version_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.bootloader_mode_ = from._impl_.bootloader_mode_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.pin_protection_ = from._impl_.pin_protection_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.passphrase_protection_ = from._impl_.passphrase_protection_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.initialized_ = from._impl_.initialized_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.imported_ = from._impl_.imported_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.unlocked_ = from._impl_.unlocked_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_._passphrase_cached_ = from._impl_._passphrase_cached_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.firmware_present_ = from._impl_.firmware_present_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.fw_major_ = from._impl_.fw_major_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.fw_minor_ = from._impl_.fw_minor_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.fw_patch_ = from._impl_.fw_patch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.needs_backup_ = from._impl_.needs_backup_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.unfinished_backup_ = from._impl_.unfinished_backup_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.no_backup_ = from._impl_.no_backup_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.recovery_mode_ = from._impl_.recovery_mode_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.backup_type_ = from._impl_.backup_type_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.sd_card_present_ = from._impl_.sd_card_present_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.sd_protection_ = from._impl_.sd_protection_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.wipe_code_protection_ = from._impl_.wipe_code_protection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.passphrase_always_on_device_ = from._impl_.passphrase_always_on_device_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.safety_checks_ = from._impl_.safety_checks_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auto_lock_delay_ms_ = from._impl_.auto_lock_delay_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.display_rotation_ = from._impl_.display_rotation_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.experimental_features_ = from._impl_.experimental_features_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.busy_ = from._impl_.busy_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.hide_passphrase_from_host_ = from._impl_.hide_passphrase_from_host_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.homescreen_format_ = from._impl_.homescreen_format_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Features::CopyFrom(const Features& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.Features)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Features::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Features::InternalSwap(Features* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.capabilities_.InternalSwap(&other->_impl_.capabilities_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vendor_, lhs_arena,
      &other->_impl_.vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_id_, lhs_arena,
      &other->_impl_.device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.revision_, lhs_arena,
      &other->_impl_.revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bootloader_hash_, lhs_arena,
      &other->_impl_.bootloader_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fw_vendor_, lhs_arena,
      &other->_impl_.fw_vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.session_id_, lhs_arena,
      &other->_impl_.session_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Features, _impl_.hide_passphrase_from_host_)
      + sizeof(Features::_impl_.hide_passphrase_from_host_)
      - PROTOBUF_FIELD_OFFSET(Features, _impl_.major_version_)>(
          reinterpret_cast<char*>(&_impl_.major_version_),
          reinterpret_cast<char*>(&other->_impl_.major_version_));
  swap(_impl_.homescreen_format_, other->_impl_.homescreen_format_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Features::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[2]);
}

// ===================================================================

class LockDevice::_Internal {
 public:
};

LockDevice::LockDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.LockDevice)
}
LockDevice::LockDevice(const LockDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  LockDevice* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.LockDevice)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LockDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LockDevice::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata LockDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[3]);
}

// ===================================================================

class SetBusy::_Internal {
 public:
  using HasBits = decltype(std::declval<SetBusy>()._impl_._has_bits_);
  static void set_has_expiry_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SetBusy::SetBusy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.SetBusy)
}
SetBusy::SetBusy(const SetBusy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetBusy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.expiry_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.expiry_ms_ = from._impl_.expiry_ms_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.SetBusy)
}

inline void SetBusy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.expiry_ms_){0u}
  };
}

SetBusy::~SetBusy() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.SetBusy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetBusy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetBusy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetBusy::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.SetBusy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.expiry_ms_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetBusy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 expiry_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_expiry_ms(&has_bits);
          _impl_.expiry_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetBusy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.SetBusy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 expiry_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_expiry_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.SetBusy)
  return target;
}

size_t SetBusy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.SetBusy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 expiry_ms = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_expiry_ms());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetBusy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetBusy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetBusy::GetClassData() const { return &_class_data_; }


void SetBusy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetBusy*>(&to_msg);
  auto& from = static_cast<const SetBusy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.SetBusy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_expiry_ms()) {
    _this->_internal_set_expiry_ms(from._internal_expiry_ms());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetBusy::CopyFrom(const SetBusy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.SetBusy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetBusy::IsInitialized() const {
  return true;
}

void SetBusy::InternalSwap(SetBusy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.expiry_ms_, other->_impl_.expiry_ms_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetBusy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[4]);
}

// ===================================================================

class EndSession::_Internal {
 public:
};

EndSession::EndSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.EndSession)
}
EndSession::EndSession(const EndSession& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  EndSession* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.EndSession)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EndSession::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EndSession::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata EndSession::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[5]);
}

// ===================================================================

class ApplySettings::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplySettings>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_use_passphrase(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_homescreen(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has__passphrase_source(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_auto_lock_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_display_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_passphrase_always_on_device(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_safety_checks(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_experimental_features(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_hide_passphrase_from_host(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

ApplySettings::ApplySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.ApplySettings)
}
ApplySettings::ApplySettings(const ApplySettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplySettings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.homescreen_){}
    , decltype(_impl_._passphrase_source_){}
    , decltype(_impl_.auto_lock_delay_ms_){}
    , decltype(_impl_.display_rotation_){}
    , decltype(_impl_.use_passphrase_){}
    , decltype(_impl_.passphrase_always_on_device_){}
    , decltype(_impl_.experimental_features_){}
    , decltype(_impl_.hide_passphrase_from_host_){}
    , decltype(_impl_.safety_checks_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  _impl_.homescreen_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.homescreen_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_homescreen()) {
    _this->_impl_.homescreen_.Set(from._internal_homescreen(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_._passphrase_source_, &from._impl_._passphrase_source_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.safety_checks_) -
    reinterpret_cast<char*>(&_impl_._passphrase_source_)) + sizeof(_impl_.safety_checks_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.ApplySettings)
}

inline void ApplySettings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.homescreen_){}
    , decltype(_impl_._passphrase_source_){0u}
    , decltype(_impl_.auto_lock_delay_ms_){0u}
    , decltype(_impl_.display_rotation_){0u}
    , decltype(_impl_.use_passphrase_){false}
    , decltype(_impl_.passphrase_always_on_device_){false}
    , decltype(_impl_.experimental_features_){false}
    , decltype(_impl_.hide_passphrase_from_host_){false}
    , decltype(_impl_.safety_checks_){0}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.homescreen_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.homescreen_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplySettings::~ApplySettings() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.ApplySettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplySettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
  _impl_.label_.Destroy();
  _impl_.homescreen_.Destroy();
}

void ApplySettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplySettings::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.ApplySettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.homescreen_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_._passphrase_source_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.passphrase_always_on_device_) -
        reinterpret_cast<char*>(&_impl_._passphrase_source_)) + sizeof(_impl_.passphrase_always_on_device_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.experimental_features_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.safety_checks_) -
        reinterpret_cast<char*>(&_impl_.experimental_features_)) + sizeof(_impl_.safety_checks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplySettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.ApplySettings.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.ApplySettings.label");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool use_passphrase = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_use_passphrase(&has_bits);
          _impl_.use_passphrase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes homescreen = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_homescreen();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 _passphrase_source = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has__passphrase_source(&has_bits);
          _impl_._passphrase_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auto_lock_delay_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_auto_lock_delay_ms(&has_bits);
          _impl_.auto_lock_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 display_rotation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_display_rotation(&has_bits);
          _impl_.display_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool passphrase_always_on_device = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_passphrase_always_on_device(&has_bits);
          _impl_.passphrase_always_on_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::SafetyCheckLevel_IsValid(val))) {
            _internal_set_safety_checks(static_cast<::hw::trezor::messages::management::SafetyCheckLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool experimental_features = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_experimental_features(&has_bits);
          _impl_.experimental_features_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hide_passphrase_from_host = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_hide_passphrase_from_host(&has_bits);
          _impl_.hide_passphrase_from_host_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplySettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.ApplySettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.ApplySettings.language");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // optional string label = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.ApplySettings.label");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_label(), target);
  }

  // optional bool use_passphrase = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_use_passphrase(), target);
  }

  // optional bytes homescreen = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_homescreen(), target);
  }

  // optional uint32 _passphrase_source = 5 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal__passphrase_source(), target);
  }

  // optional uint32 auto_lock_delay_ms = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_auto_lock_delay_ms(), target);
  }

  // optional uint32 display_rotation = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_display_rotation(), target);
  }

  // optional bool passphrase_always_on_device = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_passphrase_always_on_device(), target);
  }

  // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_safety_checks(), target);
  }

  // optional bool experimental_features = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_experimental_features(), target);
  }

  // optional bool hide_passphrase_from_host = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_hide_passphrase_from_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.ApplySettings)
  return target;
}

size_t ApplySettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.ApplySettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string language = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string label = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional bytes homescreen = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_homescreen());
    }

    // optional uint32 _passphrase_source = 5 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal__passphrase_source());
    }

    // optional uint32 auto_lock_delay_ms = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_auto_lock_delay_ms());
    }

    // optional uint32 display_rotation = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_display_rotation());
    }

    // optional bool use_passphrase = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_always_on_device = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool experimental_features = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool hide_passphrase_from_host = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional .hw.trezor.messages.management.SafetyCheckLevel safety_checks = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_safety_checks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplySettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplySettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplySettings::GetClassData() const { return &_class_data_; }


void ApplySettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplySettings*>(&to_msg);
  auto& from = static_cast<const ApplySettings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.ApplySettings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_homescreen(from._internal_homescreen());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_._passphrase_source_ = from._impl_._passphrase_source_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.auto_lock_delay_ms_ = from._impl_.auto_lock_delay_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.display_rotation_ = from._impl_.display_rotation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.use_passphrase_ = from._impl_.use_passphrase_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.passphrase_always_on_device_ = from._impl_.passphrase_always_on_device_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.experimental_features_ = from._impl_.experimental_features_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.hide_passphrase_from_host_ = from._impl_.hide_passphrase_from_host_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.safety_checks_ = from._impl_.safety_checks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplySettings::CopyFrom(const ApplySettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.ApplySettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplySettings::IsInitialized() const {
  return true;
}

void ApplySettings::InternalSwap(ApplySettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.homescreen_, lhs_arena,
      &other->_impl_.homescreen_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplySettings, _impl_.safety_checks_)
      + sizeof(ApplySettings::_impl_.safety_checks_)
      - PROTOBUF_FIELD_OFFSET(ApplySettings, _impl_._passphrase_source_)>(
          reinterpret_cast<char*>(&_impl_._passphrase_source_),
          reinterpret_cast<char*>(&other->_impl_._passphrase_source_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplySettings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[6]);
}

// ===================================================================

class ApplyFlags::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyFlags>()._impl_._has_bits_);
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ApplyFlags::ApplyFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.ApplyFlags)
}
ApplyFlags::ApplyFlags(const ApplyFlags& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyFlags* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flags_ = from._impl_.flags_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.ApplyFlags)
}

inline void ApplyFlags::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.flags_){0u}
  };
}

ApplyFlags::~ApplyFlags() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.ApplyFlags)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyFlags::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ApplyFlags::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyFlags::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.ApplyFlags)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flags_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyFlags::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyFlags::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.ApplyFlags)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.ApplyFlags)
  return target;
}

size_t ApplyFlags::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.ApplyFlags)
  size_t total_size = 0;

  // required uint32 flags = 1;
  if (_internal_has_flags()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyFlags::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyFlags::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyFlags::GetClassData() const { return &_class_data_; }


void ApplyFlags::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyFlags*>(&to_msg);
  auto& from = static_cast<const ApplyFlags&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.ApplyFlags)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_flags()) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyFlags::CopyFrom(const ApplyFlags& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.ApplyFlags)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyFlags::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ApplyFlags::InternalSwap(ApplyFlags* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.flags_, other->_impl_.flags_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyFlags::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[7]);
}

// ===================================================================

class ChangePin::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangePin>()._impl_._has_bits_);
  static void set_has_remove(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChangePin::ChangePin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.ChangePin)
}
ChangePin::ChangePin(const ChangePin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangePin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remove_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.remove_ = from._impl_.remove_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.ChangePin)
}

inline void ChangePin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remove_){false}
  };
}

ChangePin::~ChangePin() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.ChangePin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangePin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangePin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangePin::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.ChangePin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.remove_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangePin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool remove = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_remove(&has_bits);
          _impl_.remove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangePin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.ChangePin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool remove = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_remove(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.ChangePin)
  return target;
}

size_t ChangePin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.ChangePin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool remove = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangePin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangePin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangePin::GetClassData() const { return &_class_data_; }


void ChangePin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangePin*>(&to_msg);
  auto& from = static_cast<const ChangePin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.ChangePin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_remove()) {
    _this->_internal_set_remove(from._internal_remove());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangePin::CopyFrom(const ChangePin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.ChangePin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangePin::IsInitialized() const {
  return true;
}

void ChangePin::InternalSwap(ChangePin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.remove_, other->_impl_.remove_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangePin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[8]);
}

// ===================================================================

class ChangeWipeCode::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeWipeCode>()._impl_._has_bits_);
  static void set_has_remove(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChangeWipeCode::ChangeWipeCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.ChangeWipeCode)
}
ChangeWipeCode::ChangeWipeCode(const ChangeWipeCode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeWipeCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remove_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.remove_ = from._impl_.remove_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.ChangeWipeCode)
}

inline void ChangeWipeCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remove_){false}
  };
}

ChangeWipeCode::~ChangeWipeCode() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.ChangeWipeCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeWipeCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChangeWipeCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeWipeCode::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.ChangeWipeCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.remove_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeWipeCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool remove = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_remove(&has_bits);
          _impl_.remove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeWipeCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.ChangeWipeCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool remove = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_remove(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.ChangeWipeCode)
  return target;
}

size_t ChangeWipeCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.ChangeWipeCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool remove = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeWipeCode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeWipeCode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeWipeCode::GetClassData() const { return &_class_data_; }


void ChangeWipeCode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeWipeCode*>(&to_msg);
  auto& from = static_cast<const ChangeWipeCode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.ChangeWipeCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_remove()) {
    _this->_internal_set_remove(from._internal_remove());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeWipeCode::CopyFrom(const ChangeWipeCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.ChangeWipeCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeWipeCode::IsInitialized() const {
  return true;
}

void ChangeWipeCode::InternalSwap(ChangeWipeCode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.remove_, other->_impl_.remove_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeWipeCode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[9]);
}

// ===================================================================

class SdProtect::_Internal {
 public:
  using HasBits = decltype(std::declval<SdProtect>()._impl_._has_bits_);
  static void set_has_operation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SdProtect::SdProtect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.SdProtect)
}
SdProtect::SdProtect(const SdProtect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SdProtect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.operation_ = from._impl_.operation_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.SdProtect)
}

inline void SdProtect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.operation_){0}
  };
}

SdProtect::~SdProtect() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.SdProtect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SdProtect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SdProtect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SdProtect::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.SdProtect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.operation_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SdProtect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::SdProtect_SdProtectOperationType_IsValid(val))) {
            _internal_set_operation(static_cast<::hw::trezor::messages::management::SdProtect_SdProtectOperationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SdProtect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.SdProtect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_operation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.SdProtect)
  return target;
}

size_t SdProtect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.SdProtect)
  size_t total_size = 0;

  // required .hw.trezor.messages.management.SdProtect.SdProtectOperationType operation = 1;
  if (_internal_has_operation()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_operation());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SdProtect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SdProtect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SdProtect::GetClassData() const { return &_class_data_; }


void SdProtect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SdProtect*>(&to_msg);
  auto& from = static_cast<const SdProtect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.SdProtect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_operation()) {
    _this->_internal_set_operation(from._internal_operation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SdProtect::CopyFrom(const SdProtect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.SdProtect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SdProtect::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SdProtect::InternalSwap(SdProtect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.operation_, other->_impl_.operation_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SdProtect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[10]);
}

// ===================================================================

class Ping::_Internal {
 public:
  using HasBits = decltype(std::declval<Ping>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_button_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Ping::Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.Ping)
}
Ping::Ping(const Ping& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ping* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.button_protection_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.button_protection_ = from._impl_.button_protection_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.Ping)
}

inline void Ping::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.button_protection_){false}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Ping::~Ping() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.Ping)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void Ping::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ping::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.Ping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_.button_protection_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1 [default = ""];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.Ping.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool button_protection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_button_protection(&has_bits);
          _impl_.button_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.Ping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string message = 1 [default = ""];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.Ping.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // optional bool button_protection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_button_protection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.Ping)
  return target;
}

size_t Ping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.Ping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 1 [default = ""];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional bool button_protection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ping::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ping::GetClassData() const { return &_class_data_; }


void Ping::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ping*>(&to_msg);
  auto& from = static_cast<const Ping&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.Ping)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.button_protection_ = from._impl_.button_protection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ping::CopyFrom(const Ping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.Ping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping::IsInitialized() const {
  return true;
}

void Ping::InternalSwap(Ping* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.button_protection_, other->_impl_.button_protection_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Ping::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[11]);
}

// ===================================================================

class Cancel::_Internal {
 public:
};

Cancel::Cancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.Cancel)
}
Cancel::Cancel(const Cancel& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Cancel* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.Cancel)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cancel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cancel::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Cancel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[12]);
}

// ===================================================================

class GetEntropy::_Internal {
 public:
  using HasBits = decltype(std::declval<GetEntropy>()._impl_._has_bits_);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetEntropy::GetEntropy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.GetEntropy)
}
GetEntropy::GetEntropy(const GetEntropy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetEntropy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.size_ = from._impl_.size_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.GetEntropy)
}

inline void GetEntropy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_){0u}
  };
}

GetEntropy::~GetEntropy() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.GetEntropy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetEntropy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetEntropy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetEntropy::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.GetEntropy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.size_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetEntropy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetEntropy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.GetEntropy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.GetEntropy)
  return target;
}

size_t GetEntropy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.GetEntropy)
  size_t total_size = 0;

  // required uint32 size = 1;
  if (_internal_has_size()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetEntropy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetEntropy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetEntropy::GetClassData() const { return &_class_data_; }


void GetEntropy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetEntropy*>(&to_msg);
  auto& from = static_cast<const GetEntropy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.GetEntropy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_size()) {
    _this->_internal_set_size(from._internal_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetEntropy::CopyFrom(const GetEntropy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.GetEntropy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetEntropy::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GetEntropy::InternalSwap(GetEntropy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.size_, other->_impl_.size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetEntropy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[13]);
}

// ===================================================================

class Entropy::_Internal {
 public:
  using HasBits = decltype(std::declval<Entropy>()._impl_._has_bits_);
  static void set_has_entropy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Entropy::Entropy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.Entropy)
}
Entropy::Entropy(const Entropy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Entropy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entropy_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entropy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entropy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entropy()) {
    _this->_impl_.entropy_.Set(from._internal_entropy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.Entropy)
}

inline void Entropy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entropy_){}
  };
  _impl_.entropy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entropy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Entropy::~Entropy() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.Entropy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Entropy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entropy_.Destroy();
}

void Entropy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Entropy::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.Entropy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.entropy_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Entropy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes entropy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_entropy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Entropy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.Entropy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes entropy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_entropy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.Entropy)
  return target;
}

size_t Entropy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.Entropy)
  size_t total_size = 0;

  // required bytes entropy = 1;
  if (_internal_has_entropy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_entropy());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Entropy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Entropy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Entropy::GetClassData() const { return &_class_data_; }


void Entropy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Entropy*>(&to_msg);
  auto& from = static_cast<const Entropy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.Entropy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_entropy()) {
    _this->_internal_set_entropy(from._internal_entropy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Entropy::CopyFrom(const Entropy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.Entropy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entropy::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Entropy::InternalSwap(Entropy* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entropy_, lhs_arena,
      &other->_impl_.entropy_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Entropy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[14]);
}

// ===================================================================

class GetFirmwareHash::_Internal {
 public:
  using HasBits = decltype(std::declval<GetFirmwareHash>()._impl_._has_bits_);
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetFirmwareHash::GetFirmwareHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.GetFirmwareHash)
}
GetFirmwareHash::GetFirmwareHash(const GetFirmwareHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetFirmwareHash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.challenge_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.challenge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.challenge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_challenge()) {
    _this->_impl_.challenge_.Set(from._internal_challenge(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.GetFirmwareHash)
}

inline void GetFirmwareHash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.challenge_){}
  };
  _impl_.challenge_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.challenge_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetFirmwareHash::~GetFirmwareHash() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.GetFirmwareHash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetFirmwareHash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.challenge_.Destroy();
}

void GetFirmwareHash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetFirmwareHash::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.GetFirmwareHash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.challenge_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFirmwareHash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes challenge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_challenge();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFirmwareHash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.GetFirmwareHash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes challenge = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_challenge(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.GetFirmwareHash)
  return target;
}

size_t GetFirmwareHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.GetFirmwareHash)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes challenge = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_challenge());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFirmwareHash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetFirmwareHash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFirmwareHash::GetClassData() const { return &_class_data_; }


void GetFirmwareHash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetFirmwareHash*>(&to_msg);
  auto& from = static_cast<const GetFirmwareHash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.GetFirmwareHash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_challenge()) {
    _this->_internal_set_challenge(from._internal_challenge());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFirmwareHash::CopyFrom(const GetFirmwareHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.GetFirmwareHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFirmwareHash::IsInitialized() const {
  return true;
}

void GetFirmwareHash::InternalSwap(GetFirmwareHash* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.challenge_, lhs_arena,
      &other->_impl_.challenge_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFirmwareHash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[15]);
}

// ===================================================================

class FirmwareHash::_Internal {
 public:
  using HasBits = decltype(std::declval<FirmwareHash>()._impl_._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FirmwareHash::FirmwareHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.FirmwareHash)
}
FirmwareHash::FirmwareHash(const FirmwareHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FirmwareHash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.FirmwareHash)
}

inline void FirmwareHash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FirmwareHash::~FirmwareHash() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.FirmwareHash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FirmwareHash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
}

void FirmwareHash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FirmwareHash::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.FirmwareHash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.hash_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FirmwareHash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FirmwareHash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.FirmwareHash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.FirmwareHash)
  return target;
}

size_t FirmwareHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.FirmwareHash)
  size_t total_size = 0;

  // required bytes hash = 1;
  if (_internal_has_hash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FirmwareHash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FirmwareHash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FirmwareHash::GetClassData() const { return &_class_data_; }


void FirmwareHash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FirmwareHash*>(&to_msg);
  auto& from = static_cast<const FirmwareHash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.FirmwareHash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hash()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FirmwareHash::CopyFrom(const FirmwareHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.FirmwareHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareHash::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FirmwareHash::InternalSwap(FirmwareHash* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata FirmwareHash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[16]);
}

// ===================================================================

class WipeDevice::_Internal {
 public:
};

WipeDevice::WipeDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.WipeDevice)
}
WipeDevice::WipeDevice(const WipeDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  WipeDevice* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.WipeDevice)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WipeDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WipeDevice::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata WipeDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[17]);
}

// ===================================================================

class LoadDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadDevice>()._impl_._has_bits_);
  static void set_has_pin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_passphrase_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skip_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_u2f_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_needs_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_no_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString LoadDevice::Impl_::_i_give_permission_to_break_this_code_default_language_{{{"en-US", 5}}, {nullptr}};
LoadDevice::LoadDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.LoadDevice)
}
LoadDevice::LoadDevice(const LoadDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadDevice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mnemonics_){from._impl_.mnemonics_}
    , decltype(_impl_.pin_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.passphrase_protection_){}
    , decltype(_impl_.skip_checksum_){}
    , decltype(_impl_.needs_backup_){}
    , decltype(_impl_.no_backup_){}
    , decltype(_impl_.u2f_counter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pin()) {
    _this->_impl_.pin_.Set(from._internal_pin(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.passphrase_protection_, &from._impl_.passphrase_protection_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.u2f_counter_) -
    reinterpret_cast<char*>(&_impl_.passphrase_protection_)) + sizeof(_impl_.u2f_counter_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.LoadDevice)
}

inline void LoadDevice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mnemonics_){arena}
    , decltype(_impl_.pin_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.passphrase_protection_){false}
    , decltype(_impl_.skip_checksum_){false}
    , decltype(_impl_.needs_backup_){false}
    , decltype(_impl_.no_backup_){false}
    , decltype(_impl_.u2f_counter_){0u}
  };
  _impl_.pin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoadDevice::~LoadDevice() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.LoadDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mnemonics_.~RepeatedPtrField();
  _impl_.pin_.Destroy();
  _impl_.language_.Destroy();
  _impl_.label_.Destroy();
}

void LoadDevice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.LoadDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mnemonics_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.pin_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.language_.ClearToDefault(::hw::trezor::messages::management::LoadDevice::Impl_::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
       }
    if (cached_has_bits & 0x00000004u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.passphrase_protection_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.u2f_counter_) -
        reinterpret_cast<char*>(&_impl_.passphrase_protection_)) + sizeof(_impl_.u2f_counter_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string mnemonics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mnemonics();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.LoadDevice.mnemonics");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string pin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_pin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.LoadDevice.pin");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool passphrase_protection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_passphrase_protection(&has_bits);
          _impl_.passphrase_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 5 [default = "en-US"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.LoadDevice.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string label = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.LoadDevice.label");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_checksum = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_skip_checksum(&has_bits);
          _impl_.skip_checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u2f_counter = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_u2f_counter(&has_bits);
          _impl_.u2f_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_backup = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_needs_backup(&has_bits);
          _impl_.needs_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool no_backup = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_no_backup(&has_bits);
          _impl_.no_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.LoadDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string mnemonics = 1;
  for (int i = 0, n = this->_internal_mnemonics_size(); i < n; i++) {
    const auto& s = this->_internal_mnemonics(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.LoadDevice.mnemonics");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pin = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pin().data(), static_cast<int>(this->_internal_pin().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.LoadDevice.pin");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_pin(), target);
  }

  // optional bool passphrase_protection = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_passphrase_protection(), target);
  }

  // optional string language = 5 [default = "en-US"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.LoadDevice.language");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_language(), target);
  }

  // optional string label = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.LoadDevice.label");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_label(), target);
  }

  // optional bool skip_checksum = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_skip_checksum(), target);
  }

  // optional uint32 u2f_counter = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_u2f_counter(), target);
  }

  // optional bool needs_backup = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_needs_backup(), target);
  }

  // optional bool no_backup = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_no_backup(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.LoadDevice)
  return target;
}

size_t LoadDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.LoadDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string mnemonics = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.mnemonics_.size());
  for (int i = 0, n = _impl_.mnemonics_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.mnemonics_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string pin = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pin());
    }

    // optional string language = 5 [default = "en-US"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string label = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional bool passphrase_protection = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool skip_checksum = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool needs_backup = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool no_backup = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 u2f_counter = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u2f_counter());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadDevice::GetClassData() const { return &_class_data_; }


void LoadDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadDevice*>(&to_msg);
  auto& from = static_cast<const LoadDevice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.LoadDevice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mnemonics_.MergeFrom(from._impl_.mnemonics_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pin(from._internal_pin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.passphrase_protection_ = from._impl_.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.skip_checksum_ = from._impl_.skip_checksum_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.needs_backup_ = from._impl_.needs_backup_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.no_backup_ = from._impl_.no_backup_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.u2f_counter_ = from._impl_.u2f_counter_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadDevice::CopyFrom(const LoadDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.LoadDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadDevice::IsInitialized() const {
  return true;
}

void LoadDevice::InternalSwap(LoadDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mnemonics_.InternalSwap(&other->_impl_.mnemonics_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pin_, lhs_arena,
      &other->_impl_.pin_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoadDevice, _impl_.u2f_counter_)
      + sizeof(LoadDevice::_impl_.u2f_counter_)
      - PROTOBUF_FIELD_OFFSET(LoadDevice, _impl_.passphrase_protection_)>(
          reinterpret_cast<char*>(&_impl_.passphrase_protection_),
          reinterpret_cast<char*>(&other->_impl_.passphrase_protection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[18]);
}

// ===================================================================

class ResetDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<ResetDevice>()._impl_._has_bits_);
  static void set_has_display_random(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_strength(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_passphrase_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pin_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_u2f_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_skip_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_no_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_backup_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString ResetDevice::Impl_::_i_give_permission_to_break_this_code_default_language_{{{"en-US", 5}}, {nullptr}};
ResetDevice::ResetDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.ResetDevice)
}
ResetDevice::ResetDevice(const ResetDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResetDevice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.display_random_){}
    , decltype(_impl_.passphrase_protection_){}
    , decltype(_impl_.pin_protection_){}
    , decltype(_impl_.skip_backup_){}
    , decltype(_impl_.u2f_counter_){}
    , decltype(_impl_.no_backup_){}
    , decltype(_impl_.backup_type_){}
    , decltype(_impl_.strength_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.display_random_, &from._impl_.display_random_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.strength_) -
    reinterpret_cast<char*>(&_impl_.display_random_)) + sizeof(_impl_.strength_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.ResetDevice)
}

inline void ResetDevice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.display_random_){false}
    , decltype(_impl_.passphrase_protection_){false}
    , decltype(_impl_.pin_protection_){false}
    , decltype(_impl_.skip_backup_){false}
    , decltype(_impl_.u2f_counter_){0u}
    , decltype(_impl_.no_backup_){false}
    , decltype(_impl_.backup_type_){0}
    , decltype(_impl_.strength_){256u}
  };
  _impl_.language_.InitDefault();
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResetDevice::~ResetDevice() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.ResetDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
  _impl_.label_.Destroy();
}

void ResetDevice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResetDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.ResetDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.language_.ClearToDefault(::hw::trezor::messages::management::ResetDevice::Impl_::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
       }
    if (cached_has_bits & 0x00000002u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.display_random_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.no_backup_) -
        reinterpret_cast<char*>(&_impl_.display_random_)) + sizeof(_impl_.no_backup_));
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.backup_type_ = 0;
    _impl_.strength_ = 256u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResetDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool display_random = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_display_random(&has_bits);
          _impl_.display_random_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 strength = 2 [default = 256];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_strength(&has_bits);
          _impl_.strength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool passphrase_protection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_passphrase_protection(&has_bits);
          _impl_.passphrase_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pin_protection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pin_protection(&has_bits);
          _impl_.pin_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 5 [default = "en-US"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.ResetDevice.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string label = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.ResetDevice.label");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u2f_counter = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_u2f_counter(&has_bits);
          _impl_.u2f_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_backup = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_skip_backup(&has_bits);
          _impl_.skip_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool no_backup = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_no_backup(&has_bits);
          _impl_.no_backup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.management.BackupType backup_type = 10 [default = Bip39];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::BackupType_IsValid(val))) {
            _internal_set_backup_type(static_cast<::hw::trezor::messages::management::BackupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.ResetDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool display_random = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_display_random(), target);
  }

  // optional uint32 strength = 2 [default = 256];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_strength(), target);
  }

  // optional bool passphrase_protection = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_passphrase_protection(), target);
  }

  // optional bool pin_protection = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_pin_protection(), target);
  }

  // optional string language = 5 [default = "en-US"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.ResetDevice.language");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_language(), target);
  }

  // optional string label = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.ResetDevice.label");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_label(), target);
  }

  // optional uint32 u2f_counter = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_u2f_counter(), target);
  }

  // optional bool skip_backup = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_skip_backup(), target);
  }

  // optional bool no_backup = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_no_backup(), target);
  }

  // optional .hw.trezor.messages.management.BackupType backup_type = 10 [default = Bip39];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_backup_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.ResetDevice)
  return target;
}

size_t ResetDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.ResetDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string language = 5 [default = "en-US"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string label = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional bool display_random = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool skip_backup = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional uint32 u2f_counter = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u2f_counter());
    }

    // optional bool no_backup = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .hw.trezor.messages.management.BackupType backup_type = 10 [default = Bip39];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_backup_type());
    }

    // optional uint32 strength = 2 [default = 256];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_strength());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResetDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResetDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResetDevice::GetClassData() const { return &_class_data_; }


void ResetDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResetDevice*>(&to_msg);
  auto& from = static_cast<const ResetDevice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.ResetDevice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.display_random_ = from._impl_.display_random_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.passphrase_protection_ = from._impl_.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pin_protection_ = from._impl_.pin_protection_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.skip_backup_ = from._impl_.skip_backup_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.u2f_counter_ = from._impl_.u2f_counter_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.no_backup_ = from._impl_.no_backup_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.backup_type_ = from._impl_.backup_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.strength_ = from._impl_.strength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResetDevice::CopyFrom(const ResetDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.ResetDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetDevice::IsInitialized() const {
  return true;
}

void ResetDevice::InternalSwap(ResetDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ResetDevice, _impl_.backup_type_)
      + sizeof(ResetDevice::_impl_.backup_type_)
      - PROTOBUF_FIELD_OFFSET(ResetDevice, _impl_.display_random_)>(
          reinterpret_cast<char*>(&_impl_.display_random_),
          reinterpret_cast<char*>(&other->_impl_.display_random_));
  swap(_impl_.strength_, other->_impl_.strength_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResetDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[19]);
}

// ===================================================================

class BackupDevice::_Internal {
 public:
};

BackupDevice::BackupDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.BackupDevice)
}
BackupDevice::BackupDevice(const BackupDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  BackupDevice* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.BackupDevice)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BackupDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BackupDevice::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata BackupDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[20]);
}

// ===================================================================

class EntropyRequest::_Internal {
 public:
};

EntropyRequest::EntropyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.EntropyRequest)
}
EntropyRequest::EntropyRequest(const EntropyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  EntropyRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.EntropyRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntropyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntropyRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata EntropyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[21]);
}

// ===================================================================

class EntropyAck::_Internal {
 public:
  using HasBits = decltype(std::declval<EntropyAck>()._impl_._has_bits_);
  static void set_has_entropy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EntropyAck::EntropyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.EntropyAck)
}
EntropyAck::EntropyAck(const EntropyAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EntropyAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entropy_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entropy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entropy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entropy()) {
    _this->_impl_.entropy_.Set(from._internal_entropy(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.EntropyAck)
}

inline void EntropyAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entropy_){}
  };
  _impl_.entropy_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entropy_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EntropyAck::~EntropyAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.EntropyAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EntropyAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entropy_.Destroy();
}

void EntropyAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EntropyAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.EntropyAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.entropy_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EntropyAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes entropy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_entropy();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EntropyAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.EntropyAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes entropy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_entropy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.EntropyAck)
  return target;
}

size_t EntropyAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.EntropyAck)
  size_t total_size = 0;

  // required bytes entropy = 1;
  if (_internal_has_entropy()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_entropy());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntropyAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EntropyAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntropyAck::GetClassData() const { return &_class_data_; }


void EntropyAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EntropyAck*>(&to_msg);
  auto& from = static_cast<const EntropyAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.EntropyAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_entropy()) {
    _this->_internal_set_entropy(from._internal_entropy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EntropyAck::CopyFrom(const EntropyAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.EntropyAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyAck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EntropyAck::InternalSwap(EntropyAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entropy_, lhs_arena,
      &other->_impl_.entropy_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata EntropyAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[22]);
}

// ===================================================================

class RecoveryDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<RecoveryDevice>()._impl_._has_bits_);
  static void set_has_word_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_passphrase_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pin_protection(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enforce_wordlist(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_u2f_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_dry_run(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

RecoveryDevice::RecoveryDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.RecoveryDevice)
}
RecoveryDevice::RecoveryDevice(const RecoveryDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecoveryDevice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.word_count_){}
    , decltype(_impl_.passphrase_protection_){}
    , decltype(_impl_.pin_protection_){}
    , decltype(_impl_.enforce_wordlist_){}
    , decltype(_impl_.dry_run_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.u2f_counter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.word_count_, &from._impl_.word_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.u2f_counter_) -
    reinterpret_cast<char*>(&_impl_.word_count_)) + sizeof(_impl_.u2f_counter_));
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.RecoveryDevice)
}

inline void RecoveryDevice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.label_){}
    , decltype(_impl_.word_count_){0u}
    , decltype(_impl_.passphrase_protection_){false}
    , decltype(_impl_.pin_protection_){false}
    , decltype(_impl_.enforce_wordlist_){false}
    , decltype(_impl_.dry_run_){false}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.u2f_counter_){0u}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RecoveryDevice::~RecoveryDevice() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.RecoveryDevice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecoveryDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
  _impl_.label_.Destroy();
}

void RecoveryDevice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecoveryDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.RecoveryDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.word_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.word_count_)) + sizeof(_impl_.type_));
  }
  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecoveryDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 word_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_word_count(&has_bits);
          _impl_.word_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool passphrase_protection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_passphrase_protection(&has_bits);
          _impl_.passphrase_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pin_protection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pin_protection(&has_bits);
          _impl_.pin_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.RecoveryDevice.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string label = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.RecoveryDevice.label");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool enforce_wordlist = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_enforce_wordlist(&has_bits);
          _impl_.enforce_wordlist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType_IsValid(val))) {
            _internal_set_type(static_cast<::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u2f_counter = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_u2f_counter(&has_bits);
          _impl_.u2f_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dry_run = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_dry_run(&has_bits);
          _impl_.dry_run_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecoveryDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.RecoveryDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 word_count = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_word_count(), target);
  }

  // optional bool passphrase_protection = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_passphrase_protection(), target);
  }

  // optional bool pin_protection = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_pin_protection(), target);
  }

  // optional string language = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.RecoveryDevice.language");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_language(), target);
  }

  // optional string label = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.RecoveryDevice.label");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_label(), target);
  }

  // optional bool enforce_wordlist = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_enforce_wordlist(), target);
  }

  // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_type(), target);
  }

  // optional uint32 u2f_counter = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_u2f_counter(), target);
  }

  // optional bool dry_run = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_dry_run(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.RecoveryDevice)
  return target;
}

size_t RecoveryDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.RecoveryDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string language = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string label = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional uint32 word_count = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_word_count());
    }

    // optional bool passphrase_protection = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool enforce_wordlist = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool dry_run = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  // optional uint32 u2f_counter = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u2f_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecoveryDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecoveryDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecoveryDevice::GetClassData() const { return &_class_data_; }


void RecoveryDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecoveryDevice*>(&to_msg);
  auto& from = static_cast<const RecoveryDevice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.RecoveryDevice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.word_count_ = from._impl_.word_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.passphrase_protection_ = from._impl_.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.pin_protection_ = from._impl_.pin_protection_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.enforce_wordlist_ = from._impl_.enforce_wordlist_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.dry_run_ = from._impl_.dry_run_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_u2f_counter(from._internal_u2f_counter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecoveryDevice::CopyFrom(const RecoveryDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.RecoveryDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveryDevice::IsInitialized() const {
  return true;
}

void RecoveryDevice::InternalSwap(RecoveryDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RecoveryDevice, _impl_.u2f_counter_)
      + sizeof(RecoveryDevice::_impl_.u2f_counter_)
      - PROTOBUF_FIELD_OFFSET(RecoveryDevice, _impl_.word_count_)>(
          reinterpret_cast<char*>(&_impl_.word_count_),
          reinterpret_cast<char*>(&other->_impl_.word_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RecoveryDevice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[23]);
}

// ===================================================================

class WordRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<WordRequest>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

WordRequest::WordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.WordRequest)
}
WordRequest::WordRequest(const WordRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WordRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.WordRequest)
}

inline void WordRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
  };
}

WordRequest::~WordRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.WordRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WordRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WordRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WordRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.WordRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WordRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hw::trezor::messages::management::WordRequest_WordRequestType_IsValid(val))) {
            _internal_set_type(static_cast<::hw::trezor::messages::management::WordRequest_WordRequestType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WordRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.WordRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.WordRequest)
  return target;
}

size_t WordRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.WordRequest)
  size_t total_size = 0;

  // required .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WordRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WordRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WordRequest::GetClassData() const { return &_class_data_; }


void WordRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WordRequest*>(&to_msg);
  auto& from = static_cast<const WordRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.WordRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WordRequest::CopyFrom(const WordRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.WordRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void WordRequest::InternalSwap(WordRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WordRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[24]);
}

// ===================================================================

class WordAck::_Internal {
 public:
  using HasBits = decltype(std::declval<WordAck>()._impl_._has_bits_);
  static void set_has_word(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

WordAck::WordAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.WordAck)
}
WordAck::WordAck(const WordAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WordAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.word_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.word_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.word_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_word()) {
    _this->_impl_.word_.Set(from._internal_word(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.WordAck)
}

inline void WordAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.word_){}
  };
  _impl_.word_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.word_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WordAck::~WordAck() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.WordAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WordAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.word_.Destroy();
}

void WordAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WordAck::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.WordAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.word_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WordAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string word = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_word();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "hw.trezor.messages.management.WordAck.word");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WordAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.WordAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string word = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_word().data(), static_cast<int>(this->_internal_word().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "hw.trezor.messages.management.WordAck.word");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_word(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.WordAck)
  return target;
}

size_t WordAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.WordAck)
  size_t total_size = 0;

  // required string word = 1;
  if (_internal_has_word()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_word());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WordAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WordAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WordAck::GetClassData() const { return &_class_data_; }


void WordAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WordAck*>(&to_msg);
  auto& from = static_cast<const WordAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.WordAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_word()) {
    _this->_internal_set_word(from._internal_word());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WordAck::CopyFrom(const WordAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.WordAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordAck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void WordAck::InternalSwap(WordAck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.word_, lhs_arena,
      &other->_impl_.word_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata WordAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[25]);
}

// ===================================================================

class SetU2FCounter::_Internal {
 public:
  using HasBits = decltype(std::declval<SetU2FCounter>()._impl_._has_bits_);
  static void set_has_u2f_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SetU2FCounter::SetU2FCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.SetU2FCounter)
}
SetU2FCounter::SetU2FCounter(const SetU2FCounter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetU2FCounter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u2f_counter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.u2f_counter_ = from._impl_.u2f_counter_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.SetU2FCounter)
}

inline void SetU2FCounter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u2f_counter_){0u}
  };
}

SetU2FCounter::~SetU2FCounter() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.SetU2FCounter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetU2FCounter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetU2FCounter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetU2FCounter::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.SetU2FCounter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetU2FCounter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 u2f_counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_u2f_counter(&has_bits);
          _impl_.u2f_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetU2FCounter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.SetU2FCounter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 u2f_counter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_u2f_counter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.SetU2FCounter)
  return target;
}

size_t SetU2FCounter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.SetU2FCounter)
  size_t total_size = 0;

  // required uint32 u2f_counter = 1;
  if (_internal_has_u2f_counter()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u2f_counter());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetU2FCounter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetU2FCounter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetU2FCounter::GetClassData() const { return &_class_data_; }


void SetU2FCounter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetU2FCounter*>(&to_msg);
  auto& from = static_cast<const SetU2FCounter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.SetU2FCounter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_u2f_counter()) {
    _this->_internal_set_u2f_counter(from._internal_u2f_counter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetU2FCounter::CopyFrom(const SetU2FCounter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.SetU2FCounter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetU2FCounter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SetU2FCounter::InternalSwap(SetU2FCounter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.u2f_counter_, other->_impl_.u2f_counter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetU2FCounter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[26]);
}

// ===================================================================

class GetNextU2FCounter::_Internal {
 public:
};

GetNextU2FCounter::GetNextU2FCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.GetNextU2FCounter)
}
GetNextU2FCounter::GetNextU2FCounter(const GetNextU2FCounter& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GetNextU2FCounter* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.GetNextU2FCounter)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNextU2FCounter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNextU2FCounter::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GetNextU2FCounter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[27]);
}

// ===================================================================

class NextU2FCounter::_Internal {
 public:
  using HasBits = decltype(std::declval<NextU2FCounter>()._impl_._has_bits_);
  static void set_has_u2f_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

NextU2FCounter::NextU2FCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.NextU2FCounter)
}
NextU2FCounter::NextU2FCounter(const NextU2FCounter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NextU2FCounter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u2f_counter_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.u2f_counter_ = from._impl_.u2f_counter_;
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.NextU2FCounter)
}

inline void NextU2FCounter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.u2f_counter_){0u}
  };
}

NextU2FCounter::~NextU2FCounter() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.NextU2FCounter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NextU2FCounter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NextU2FCounter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NextU2FCounter::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.NextU2FCounter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.u2f_counter_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NextU2FCounter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 u2f_counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_u2f_counter(&has_bits);
          _impl_.u2f_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NextU2FCounter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.NextU2FCounter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 u2f_counter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_u2f_counter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.NextU2FCounter)
  return target;
}

size_t NextU2FCounter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.NextU2FCounter)
  size_t total_size = 0;

  // required uint32 u2f_counter = 1;
  if (_internal_has_u2f_counter()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u2f_counter());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NextU2FCounter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NextU2FCounter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NextU2FCounter::GetClassData() const { return &_class_data_; }


void NextU2FCounter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NextU2FCounter*>(&to_msg);
  auto& from = static_cast<const NextU2FCounter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.NextU2FCounter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_u2f_counter()) {
    _this->_internal_set_u2f_counter(from._internal_u2f_counter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NextU2FCounter::CopyFrom(const NextU2FCounter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.NextU2FCounter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NextU2FCounter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void NextU2FCounter::InternalSwap(NextU2FCounter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.u2f_counter_, other->_impl_.u2f_counter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NextU2FCounter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[28]);
}

// ===================================================================

class DoPreauthorized::_Internal {
 public:
};

DoPreauthorized::DoPreauthorized(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.DoPreauthorized)
}
DoPreauthorized::DoPreauthorized(const DoPreauthorized& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DoPreauthorized* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.DoPreauthorized)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoPreauthorized::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoPreauthorized::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DoPreauthorized::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[29]);
}

// ===================================================================

class PreauthorizedRequest::_Internal {
 public:
};

PreauthorizedRequest::PreauthorizedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.PreauthorizedRequest)
}
PreauthorizedRequest::PreauthorizedRequest(const PreauthorizedRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PreauthorizedRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.PreauthorizedRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PreauthorizedRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PreauthorizedRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PreauthorizedRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[30]);
}

// ===================================================================

class CancelAuthorization::_Internal {
 public:
};

CancelAuthorization::CancelAuthorization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.CancelAuthorization)
}
CancelAuthorization::CancelAuthorization(const CancelAuthorization& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CancelAuthorization* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.CancelAuthorization)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CancelAuthorization::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CancelAuthorization::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CancelAuthorization::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[31]);
}

// ===================================================================

class RebootToBootloader::_Internal {
 public:
};

RebootToBootloader::RebootToBootloader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.RebootToBootloader)
}
RebootToBootloader::RebootToBootloader(const RebootToBootloader& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  RebootToBootloader* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.RebootToBootloader)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RebootToBootloader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RebootToBootloader::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RebootToBootloader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[32]);
}

// ===================================================================

class GetNonce::_Internal {
 public:
};

GetNonce::GetNonce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.GetNonce)
}
GetNonce::GetNonce(const GetNonce& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GetNonce* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.GetNonce)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNonce::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNonce::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GetNonce::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[33]);
}

// ===================================================================

class Nonce::_Internal {
 public:
  using HasBits = decltype(std::declval<Nonce>()._impl_._has_bits_);
  static void set_has_nonce(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Nonce::Nonce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.Nonce)
}
Nonce::Nonce(const Nonce& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Nonce* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nonce_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nonce_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nonce_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nonce()) {
    _this->_impl_.nonce_.Set(from._internal_nonce(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.Nonce)
}

inline void Nonce::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nonce_){}
  };
  _impl_.nonce_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nonce_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Nonce::~Nonce() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.Nonce)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Nonce::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nonce_.Destroy();
}

void Nonce::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Nonce::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.Nonce)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.nonce_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Nonce::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nonce();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Nonce::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.Nonce)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes nonce = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nonce(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.Nonce)
  return target;
}

size_t Nonce::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.Nonce)
  size_t total_size = 0;

  // required bytes nonce = 1;
  if (_internal_has_nonce()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nonce());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Nonce::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Nonce::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Nonce::GetClassData() const { return &_class_data_; }


void Nonce::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Nonce*>(&to_msg);
  auto& from = static_cast<const Nonce&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.Nonce)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nonce()) {
    _this->_internal_set_nonce(from._internal_nonce());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Nonce::CopyFrom(const Nonce& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.Nonce)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Nonce::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Nonce::InternalSwap(Nonce* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nonce_, lhs_arena,
      &other->_impl_.nonce_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Nonce::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[34]);
}

// ===================================================================

class UnlockPath::_Internal {
 public:
  using HasBits = decltype(std::declval<UnlockPath>()._impl_._has_bits_);
  static void set_has_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UnlockPath::UnlockPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.UnlockPath)
}
UnlockPath::UnlockPath(const UnlockPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnlockPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){from._impl_.address_n_}
    , decltype(_impl_.mac_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.UnlockPath)
}

inline void UnlockPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_n_){arena}
    , decltype(_impl_.mac_){}
  };
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnlockPath::~UnlockPath() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.UnlockPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnlockPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_n_.~RepeatedField();
  _impl_.mac_.Destroy();
}

void UnlockPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnlockPath::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.UnlockPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.address_n_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.mac_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnlockPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 address_n = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_address_n(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_address_n(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes mac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnlockPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.UnlockPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->_internal_address_n_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_address_n(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes mac = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_mac(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.UnlockPath)
  return target;
}

size_t UnlockPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.UnlockPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.address_n_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_address_n_size());
    total_size += data_size;
  }

  // optional bytes mac = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnlockPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnlockPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnlockPath::GetClassData() const { return &_class_data_; }


void UnlockPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnlockPath*>(&to_msg);
  auto& from = static_cast<const UnlockPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.UnlockPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.address_n_.MergeFrom(from._impl_.address_n_);
  if (from._internal_has_mac()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnlockPath::CopyFrom(const UnlockPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.UnlockPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnlockPath::IsInitialized() const {
  return true;
}

void UnlockPath::InternalSwap(UnlockPath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.address_n_.InternalSwap(&other->_impl_.address_n_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UnlockPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[35]);
}

// ===================================================================

class UnlockedPathRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UnlockedPathRequest>()._impl_._has_bits_);
  static void set_has_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UnlockedPathRequest::UnlockedPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:hw.trezor.messages.management.UnlockedPathRequest)
}
UnlockedPathRequest::UnlockedPathRequest(const UnlockedPathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnlockedPathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mac_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:hw.trezor.messages.management.UnlockedPathRequest)
}

inline void UnlockedPathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mac_){}
  };
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnlockedPathRequest::~UnlockedPathRequest() {
  // @@protoc_insertion_point(destructor:hw.trezor.messages.management.UnlockedPathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnlockedPathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mac_.Destroy();
}

void UnlockedPathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnlockedPathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hw.trezor.messages.management.UnlockedPathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.mac_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnlockedPathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes mac = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnlockedPathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:hw.trezor.messages.management.UnlockedPathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes mac = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_mac(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hw.trezor.messages.management.UnlockedPathRequest)
  return target;
}

size_t UnlockedPathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hw.trezor.messages.management.UnlockedPathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes mac = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnlockedPathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnlockedPathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnlockedPathRequest::GetClassData() const { return &_class_data_; }


void UnlockedPathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnlockedPathRequest*>(&to_msg);
  auto& from = static_cast<const UnlockedPathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:hw.trezor.messages.management.UnlockedPathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mac()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnlockedPathRequest::CopyFrom(const UnlockedPathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hw.trezor.messages.management.UnlockedPathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnlockedPathRequest::IsInitialized() const {
  return true;
}

void UnlockedPathRequest::InternalSwap(UnlockedPathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UnlockedPathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_messages_2dmanagement_2eproto_getter, &descriptor_table_messages_2dmanagement_2eproto_once,
      file_level_metadata_messages_2dmanagement_2eproto[36]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace management
}  // namespace messages
}  // namespace trezor
}  // namespace hw
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::Initialize*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::Initialize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::Initialize >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::GetFeatures*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::GetFeatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::GetFeatures >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::Features*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::Features >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::Features >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::LockDevice*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::LockDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::LockDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::SetBusy*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::SetBusy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::SetBusy >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::EndSession*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::EndSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::EndSession >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::ApplySettings*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::ApplySettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::ApplySettings >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::ApplyFlags*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::ApplyFlags >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::ApplyFlags >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::ChangePin*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::ChangePin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::ChangePin >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::ChangeWipeCode*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::ChangeWipeCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::ChangeWipeCode >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::SdProtect*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::SdProtect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::SdProtect >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::Ping*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::Ping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::Ping >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::Cancel*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::Cancel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::Cancel >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::GetEntropy*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::GetEntropy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::GetEntropy >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::Entropy*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::Entropy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::Entropy >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::GetFirmwareHash*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::GetFirmwareHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::GetFirmwareHash >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::FirmwareHash*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::FirmwareHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::FirmwareHash >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::WipeDevice*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::WipeDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::WipeDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::LoadDevice*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::LoadDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::LoadDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::ResetDevice*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::ResetDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::ResetDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::BackupDevice*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::BackupDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::BackupDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::EntropyRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::EntropyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::EntropyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::EntropyAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::EntropyAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::EntropyAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::RecoveryDevice*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::RecoveryDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::RecoveryDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::WordRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::WordRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::WordRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::WordAck*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::WordAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::WordAck >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::SetU2FCounter*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::SetU2FCounter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::SetU2FCounter >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::GetNextU2FCounter*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::GetNextU2FCounter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::GetNextU2FCounter >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::NextU2FCounter*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::NextU2FCounter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::NextU2FCounter >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::DoPreauthorized*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::DoPreauthorized >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::DoPreauthorized >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::PreauthorizedRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::PreauthorizedRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::PreauthorizedRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::CancelAuthorization*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::CancelAuthorization >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::CancelAuthorization >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::RebootToBootloader*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::RebootToBootloader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::RebootToBootloader >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::GetNonce*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::GetNonce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::GetNonce >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::Nonce*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::Nonce >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::Nonce >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::UnlockPath*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::UnlockPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::UnlockPath >(arena);
}
template<> PROTOBUF_NOINLINE ::hw::trezor::messages::management::UnlockedPathRequest*
Arena::CreateMaybeMessage< ::hw::trezor::messages::management::UnlockedPathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::hw::trezor::messages::management::UnlockedPathRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
